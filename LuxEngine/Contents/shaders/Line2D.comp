#version 450

#define WORKGROUP_SIZE 32			//The x and y size of the workgroup
#define gx gl_GlobalInvocationID.x	//The x coordinate of the shader call. This does not depend on the workgroup size
#define gy gl_GlobalInvocationID.y	//The y coordinate of the shader call. This does not depend on the workgroup size
#define g gl_GlobalInvocationID
const vec2 pm = { 1, -1 };	//Plus-minus vector for fast vec2 operations
const vec2 mp = { -1, 1 };	//Minus-plus vector for fast vec2 operations
float rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }


//TODO squared distance aa*bb




layout (local_size_x = WORKGROUP_SIZE * WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

layout(std430, binding = 0) buffer colorOutput_{ vec4 colorOutput[]; };
layout(std430, binding = 1) buffer windowSize_{ uint width; uint height; };
layout(std430, binding = 2) buffer zBuffer_{ uint zBuffer[]; };

layout(binding = 3) uniform lineData_{
	vec2 fp0;   	//Position of the first point
	vec2 fp1;		//Position of the second point
	vec4 col0;		//Color of the first point
	vec4 col1;		//Color of the second point
	float wd0;		//Width of the first point
	float wd1;		//Width of the second point
	uint ID;		//TODO
};







void setPixelColor(vec2 pos, vec4 col) {
	uint i = uint(pos.y) * width + uint(pos.x);

	//TODO use ordered render and component cache
	if(zBuffer[i] <= ID) {
	zBuffer[i] = ID;
		colorOutput[i] = col;
//		colorOutput[i] = vec4(float(ID)/2);
	}
}




void drawLine() {
	ivec2 p0 = ivec2(fp0 * vec2(width, height));
	ivec2 p1 = ivec2(fp1 * vec2(width, height));
	//Calculate length and interpolated values
	vec2 lDist = abs(p0 - p1);							//2D distance between the line points
	float lFac = 1 / (distance(p0, p1) / gx);			//Factor of the position of gx in the line length	(inverse of (line length / shader call x))

	vec4 col = mix(col0, col1, lFac);					//Interpolated color
	float wd = mix(wd0, wd1, lFac);						//Interpolated width



	//Find perpendicular sub segment points
	vec2 dir = { (p1.x - p0.x < 0) ? -1 : 1, (p1.y - p0.y < 0) ? -1 : 1 };//Direction of the line				(+1 when going from -y to y or from -x to x, false otherwise)
	vec2 sbOffset = dir * (wd / 2) * normalize(lDist);	//Base segment point offset							(direction * half width * normalized 2D line distance)

	vec2 lRpos = p0 + dir * lDist * lFac;				//Position relative to the first point of the line	(line base point + (direction *  normalized 2D line distance * line factor))
	vec2 s0 = sbOffset.yx * mp + lRpos;					//Fist point of the segment							(inverted base segment offset * -x + relative position)
	vec2 s1 = sbOffset.yx * pm + lRpos;					//Second point of the segment						(inverted base segment offset * -y + relative position)


	//Draw sub segment
	float sLen = distance(s1, s0);						//Length of the segment
	for(float i = 0; i < sLen; i++) {					//Set the current pixel with the interpolated color
		vec2 ppos =											//Calculate the base position of the pixel to draw
			(pm * (dir.x * dir.y)) * (dir *						//Invert position if x and y have different directions
			abs(s1 - s0) * (1 / (sLen / i))) 					//2D segment distance * segment factor
			+ s0;												//+ segment base point

		//TODO use triangle rasterization method
		setPixelColor(ppos, col);							//Set the current pixel with the interpolated color
		setPixelColor(ppos + vec2(1, 0), col);				//Additional pixel to prevent holes in the image
	}
}







void main() {
	ivec2 p0 = ivec2(fp0 * vec2(width, height));
	ivec2 p1 = ivec2(fp1 * vec2(width, height));

	if(gx >= distance(vec2(p0.x, p0.y), vec2(p1.x, p1.y))) return;			//Yeet unnecessary calls
	//TODO implement and add to render optimization exceptions (vertical, horizontal, width 1, non rendered)
	if((wd0 == 0 && wd1 == 0) || (col0.a == 0 && col1.a == 0)) return;		//Null line

	drawLine();
	// colorOutput[width*height/2+width/2] = vec4(0, fp1.y, 0, 1);
	// colorOutput[width*height/2+width/2] = vec4(0, fp1.y, 0, 1);
}
