#include <regex>
#include <filesystem>
#include <fstream>

#include "errors.hpp"
#include "ansi.hpp"
#include "ALC.hpp"

//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING
//FIXME REWRITE THIS WHOLE THING






/**
 * @brief Checks if a character is whitespace (either a space, \n or \t).
 * @return Whether a character is whitespace or not.
 */
static bool isWhitespace(char c) {
    return c == ' ' || c == '\n' || c == '\t';
}




/**
 * @brief Resizes <coords> to remove any leading and trailing whitespace characters.
 * @param s The string <coords> refers to.
 *      Coordinates that point to after the string's last character are set to (ulong)-1.
 * @param coords The coordinates.
 * @return The trimmed coordinates.
 */
static inline ElmCoords trimCoords(std::string s, ElmCoords coords) {
    ulong end     = std::min(coords.end,   s.length());
    ulong start   = std::min(coords.start, s.length());
    ulong curLine = coords.lineNum;

    while(end > coords.start && isWhitespace(s[end])) {
        --end;
    }
    while(start < coords.end && isWhitespace(s[start])) {
        if(s[start] == '\n') ++curLine;
        ++start;
    }


    return ElmCoords(coords.filePathIndex, curLine, start, end, coords.overflow);
}




/**
 * @brief Resizes <coords> to remove any leading and trailing whitespace characters.
 * @param fullCommand The command string <coords> refers to.
 * @param coords The coordinates.
 * @return The trimmed coordinates.
 */
static inline cmd::ElmCoordsCL trimCoords(std::string fullCommand, cmd::ElmCoordsCL coords) {
    ulong end = coords.end;
    ulong start = coords.start;;

    while(end >= coords.start && isWhitespace(fullCommand[end])) {
        --end;
    }
    while(start <= end && isWhitespace(fullCommand[start])) {
        ++start;
    }
    return cmd::ElmCoordsCL(start, end);
}








/**
 * @brief Prints a formatted line indicator and colors it black.
 *      The color is NOT reset after. The caller function will have to manually change it back.
*      This function is NOT thread safe. Use a mutex to ensure other threads don't print at the same time.
    * @param n The number of the line. They start from 0, but the shown number is automatically increased by 1 to make it consistent with text exitors.
    */
static inline void printLineNum(ulong n) {
    cerr << ansi::reset << ansi::bold_black << "\n" << std::right << std::setw(8) << n + 1 << " │ ";
}
















//FIXME    WHEN PRINTING LINES GENERATED BY A MACRO, MAKE IT VERY CLEAR THAT THEY WERE GENERATED
//FIXME    ALSO WRITE WHICH MACRO CALL CREATED IT.
//FIXME    maybe even write a raw version of the lines on the left and a replaced version of them on the right
void utils::printErrorGeneric(ErrorCode errorCode, std::string const &message) {
    cerr++;

    cerr << ansi::bold_red;
    cerr << "Error:";

    // Print the actual error after indenting it by 4 spaces
    cerr
        << ansi::bold_red
        << "\n    "
        << std::regex_replace(std::regex_replace(message, std::regex("\n"), "\n    "), std::regex("\033\\[0m"), ansi::bold_red)
        << "\n";

    // Stop the program
    cerr--;
    exitMain(errorCode);
}








void utils::printErrorCL(ErrorCode errorCode, cmd::ElmCoordsCL const &_relPos, cmd::ElmCoordsCL const &_errPos, std::string const &message, std::string const &fullCommand) {
    cmd::ElmCoordsCL const &relPos = trimCoords(fullCommand, _relPos);
    cmd::ElmCoordsCL const &errPos = trimCoords(fullCommand, _errPos);
    cerr++;

    cerr << ansi::bold_red;
    cerr << "Could not parse command:\n";


    // Print full command and highlight relevant section and error
    const char* lastColor;
    cerr << "    ";
    for(ulong i = 0; i < fullCommand.length(); ++i) {

        // Calculate current color based on the current character index and print it if it differs form the last one
        const char* curColor = ((i >= errPos.start && i <= errPos.end) ? ansi::bold_red : ((i >= relPos.start && i <= relPos.end) ? ansi::magenta : ansi::bright_black)).c_str();
        if(curColor != lastColor) {
            cerr << curColor;
            lastColor = curColor;
        }

        // Actually print the formatted character
        cerr << utils::formatChar(fullCommand[i], i, true);
    }


    // Print the actual error after indenting it by 4 spaces
    cerr << ansi::bold_red << "\n\n    " << std::regex_replace(std::regex_replace(message, std::regex("\n"), "\n    "), std::regex("\033\\[0m"), ansi::bold_red) << "\n";


    // Stop the program
    cerr--;
    exitMain(errorCode);
}








/**
 * @brief Prints an error to stderr, specifying the error type.
 *      This function doesn't stop the program.
 * @param errorType The type of the error.
 * @param errPos The section of the code that caused the error.
 * @param message The error message. This can contain multiple lines.
 *      The error message will be colored red and displayed as bold. ansi::reset will reset to bold red.
 */
void utils::printError(ErrorCode errorCode, ErrType errType, ElmCoords const &_errPos, std::string const &message) {
    printError(errorCode, errType, _errPos, _errPos, message);
}








//FIXME SHOW MULTIPLE FILES IN THE CODE OUTPUT IF A SECTION IS SPLIT BETWEEN MULTIPLE SOURCE FILES
//FIXME SHOW MULTIPLE FILES IN THE CODE OUTPUT IF A SECTION IS SPLIT BETWEEN MULTIPLE SOURCE FILES
/**
 * @brief Stop the program and prints an error to stderr, specifying the error type.
 * @param errorType The type of the error.
 * @param relPos The relevant section of the code.
 * @param errPos The section of the code that caused the error.
 * @param message The error message. This can contain multiple lines.
 *      The error message will be colored red and displayed as bold. ansi::reset will reset to bold red.
 */
void utils::printError(ErrorCode errorCode, ErrType errType, ElmCoords const &_relPos, ElmCoords const &_errPos, std::string const &message) {
    sourceFilePathsLock.lock();
    std::string relFilePath = sourceFilePaths[_relPos.filePathIndex];
    std::string errFilePath = sourceFilePaths[_errPos.filePathIndex];
    sourceFilePathsLock.unlock();

    cerr++;
    cerr << ansi::bold_red;

    // Print error type and location
    if(errType == ErrType::PREPROCESSOR) cerr << "Preprocessor";
    if(errType == ErrType::COMPILER)     cerr << "Compilation";
    cerr << " error:\n";


    // Check original file
    std::ifstream f(errFilePath);
    if(!f.is_open()) {

        // Print location
        if(errFilePath.length()) {
            cerr << "    File │ " << ansi::reset << errFilePath << ansi::bright_black << " (source file unavailable)\n" << ansi::reset;
            cerr << "    Line │ " << ansi::reset << _errPos.lineNum + 1;
        }
    }
    else {

        // Find the line in the original file and calculate the starting index of the preceding line
        std::string s = readFile(f); //TODO use cached raw file
        f.close();
        ElmCoords const &relPos = trimCoords(s, _relPos);
        ElmCoords const &errPos = trimCoords(s, _errPos);
        ulong curLine = std::min(relPos.lineNum, errPos.lineNum); curLine -= !!curLine;
        ulong i       = std::min(relPos.start,   errPos.start);
        do --i; while(i != (ulong)-1L && s[i] != '\n'); if(i == (ulong)-1) i = 0;
        do --i; while(i != (ulong)-1L && s[i] != '\n'); if(i == (ulong)-1) i = 0;
        if(curLine > 0 && s[i] == '\n') ++i;


        // Print location
        ulong errHeight = std::count(s.c_str() + errPos.start, s.c_str() + errPos.end, '\n');
        if(errFilePath.length()) {
            cerr << "    File │ " << ansi::reset << errFilePath << ansi::bold_red << "\n";
            cerr << "    Line │ " << ansi::reset;
            if(errHeight == 0) cerr << errPos.lineNum + 1;
            else               cerr << "From " << errPos.lineNum + 1 << " to " << errPos.lineNum + errHeight + 1;
        }


        // Print all the interested lines and change color according to the indices of the relevant and offending sections
        cerr << "\n";
        printLineNum(curLine);
        ulong relHeight = std::count(s.c_str() + relPos.start, s.c_str() + relPos.end, '\n');
        ulong targetLineNum = std::max(errPos.lineNum + errHeight, relPos.lineNum + relHeight) + 1; //! No need to check useRelevant as its line is always 0 when unused
        const char* lastColor = nullptr;
        ulong col = 0;
        bool overflowed = false;
        for(;; ++i) {


            // Calculate current color based on the current character index and print it if it differs form the last one
            if(errPos.overflow) {
                const char* curColor = ((i >= relPos.start && i <= relPos.end) ? ansi::magenta : ansi::bright_black).c_str();
                if(curColor != lastColor) {
                    cerr << curColor;
                    lastColor = curColor;
                }

                // Print (missing code indicator) if needed
                if(!overflowed && i > errPos.end) {
                    overflowed = true;
                    cerr << ansi::bold_bright_red << " ﹏﹏" << curColor;
                }
            }
            else {
                const char* curColor = ((i >= errPos.start && i <= errPos.end) ? ansi::bold_red : ((i >= relPos.start && i <= relPos.end) ? ansi::magenta : ansi::bright_black)).c_str();
                if(curColor != lastColor) {
                    cerr << curColor;
                    lastColor = curColor;
                }
            }


            // Actually print the formatted character and line number. Manually break if the current line exceeds the last line visible in the code output
            if(s[i] != '\0') {
                cerr << formatChar(s[i], col, false);
                ++col;
                if(s[i] == '\n') {
                    col = 0;
                    ++curLine;
                    if(curLine > targetLineNum) {
                        break;
                    }
                    printLineNum(curLine);
                    cerr << lastColor;
                }
            }
            else break;
        }
    }




    // Print the actual error after indenting it by 4 spaces
    cerr << ansi::bold_red << "\n\n    " << std::regex_replace(std::regex_replace(message, std::regex("\n"), "\n    "), std::regex("\033\\[0m"), ansi::bold_red) << "\n";


    // Stop the program
    cerr--;
    exitMain(errorCode);
}