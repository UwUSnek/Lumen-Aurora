import sys, re, os, pathlib, subprocess
from argparse import Namespace as ns
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/..')
import Utils




# Check argv length
if len(sys.argv) != 3:
    raise Exception(f'Invalid number of arguments: { len(sys.argv) }')


# Read inputs
tmp   : str  = sys.argv[1]          # Input file
flags : list = eval(sys.argv[2])    # Flags to use for gcc



# Read macro expansions
r = list(m.groupdict() for m in re.finditer(
    r'_LNX_INITIALIZER_GENERATOR_TYPE=(?P<type>.*?),'
    r'_LNX_INITIALIZER_GENERATOR_NAME=(?P<name>.*?),'
    r'_LNX_INITIALIZER_GENERATOR_FULLNS=(?P<fullNs>.*?);',
    Utils.PreprocessCpp(tmp, ['-include', 'src/Lynx/Core/Init.hpp', *flags, '-D__LNX_INITIALIZER_GENERATOR__'])
))




# Write initializers header
if r!= None and len(r) > 0:
    with open(output, 'w') as f:
        f.write(
            f'\n//####################################################################################'
            f'\n// This file was generated by Tools/Build/Generators/GenInitializer'
            f'\n// Changes could be overwritten without notice'
            f'\n// !Do not include or compile this file'
            f'\n//####################################################################################'
            f'\n#include "Lynx/Core/Init.hpp"\n\n'
        )

        for i, m in enumerate(r):
            id : str = f'_lnx_init_var_{ m["name"] }'

            if len(m['name']) > 4 and m['name'][-4:] == '_FUN':
                f.write(
                    f'\n\nnamespace { m["fullNs"] }::_pvt{{'
                    f'\n    struct _lnx_init_fun_{ m["name"] }_t;'
                    f'\n}}'
                )


            f.write(
                f'\n\nnamespace { m["fullNs"] }::_pvt {{'
                f'\n    extern bool { id }_is_init; //!Zero initialized'
                f'\n    used        { m["type"] }* { id }_get();'
                # f'\n    used static { m["type"] }* { id }_v = { id }_get();'
                f'\n    extern      { m["type"] }* { id }_v;'
                f'\n'
                f'\n    struct { id }_init_t_call_t{{' #FIXME REMOVE. merge with _get()'
                f'\n        { id }_init_t_call_t(){{'
                f'\n            if(!{ id }_is_init) { id }_v = { id }_get();'
                f'\n        }}'
                f'\n    }};'
                f'\n    used static { id }_init_t_call_t { id }_init_t_call_v;'
                f'\n}}'
            )