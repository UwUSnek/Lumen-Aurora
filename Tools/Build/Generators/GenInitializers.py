import sys, re, os, pathlib, subprocess
from argparse import Namespace as ns
import Utils




# Check argv length
if len(sys.argv) != 4:
    print(f'Invalid number of arguments: { len(sys.argv) }')
    sys.exit(-1)


# Check source file path
source = sys.argv[1]        # String
output = sys.argv[2]        # String
flags  = eval(sys.argv[3])  # List of strings
if not os.path.exists(source):
    print(f'Unable to find source file "{ source }"')
    sys.exit(-2)



# Get the source code and parse out unnecessary whitespace and comments
# code = subprocess.run(['g++', '-fpreprocessed', '-dD', '-E', source], capture_output = True, text = True).stdout
# ncode = subprocess.run(['g++', '-E', source], capture_output = False, text = True).stdout #TODO add include paths
# ncode = subprocess.run(['g++', '-E', '-I.', '-I./src', '-D__LNX_INITIALIZER_GENERATOR__', '-DLNX_DBG', source], capture_output = True, text = True).stdout #TODO add include paths #FIXME REPLACE WITH UTILS.PREPROCESSCPP
#FIXME REPLACE WITH UTILS.PREPROCESSCPP
#                                                                                    FIXME read includes. dont use hard coded LNX_DBG
# ncode:str = (
#     re.sub(r' ?([()\[\]{}+*-\/.!<>=&^|?:%,;])( )?',  r'\g<1>',      # Remove spaces near opeartors
#     re.sub(r'\n',       r'',                                        # Remove newlines
#     re.sub(r' +',       r' ',                                       # Remove whitespace
#     code.expandtabs(4)                                              # Convert tabs to spaces
# ))))
code : str = Utils.preprocessCpp(source, flags + '-D__LNX_INITIALIZER_GENERATOR__')

# Get init macro calls
r = list(m.groupdict() for m in re.finditer(
    r'_LNX_INITIALIZER_GENERATOR_TYPE=(?P<type>.*?),'
    r'_LNX_INITIALIZER_GENERATOR_NAME=(?P<name>.*?),'
    r'_LNX_INITIALIZER_GENERATOR_FULLNS=(?P<fullNs>.*?);',
    code
))


# Write initializers header
if r!= None and len(r) > 0:
    with open(output, 'w') as f:
        f.write(
            f'\n//####################################################################################'
            f'\n// This file was generated by Tools/Build/GenInitializer'
            f'\n// Changes could be overwritten without notice'
            f'\n// !Do not include or compile this file'
            f'\n//####################################################################################'
            f'\n#include "Lynx/Core/Init.hpp"\n\n'
        )

        for i, m in enumerate(r):
            id : str = f'_lnx_init_var_{ m["name"] }'

            if len(m['name']) > 4 and m['name'][-4:] == '_FUN':
                f.write(
                    f'\n\nnamespace { m["fullNs"] }::_pvt{{'
                    f'\n    struct _lnx_init_fun_{ m["name"] }_t;'
                    f'\n}}'
                )


            f.write(
                f'\n\nnamespace { m["fullNs"] }::_pvt {{'
                f'\n    extern bool { id }_is_init; //!Zero initialized'
                f'\n    used        { m["type"] }* { id }_get();'
                # f'\n    used static { m["type"] }* { id }_v = { id }_get();'
                f'\n    extern      { m["type"] }* { id }_v;'
                f'\n'
                f'\n    struct { id }_init_t_call_t{{' #FIXME REMOVE. merge with _get()'
                f'\n        { id }_init_t_call_t(){{'
                f'\n            if(!{ id }_is_init) { id }_v = { id }_get();'
                f'\n        }}'
                f'\n    }};'
                f'\n    used static { id }_init_t_call_t { id }_init_t_call_v;'
                f'\n}}'
            )