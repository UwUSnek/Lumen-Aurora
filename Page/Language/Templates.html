


<!--------------------------------------------------------------------->
<!-- Templates                                                       -->
<!--------------------------------------------------------------------->
<h1 id="templates"></h1>
<p>
    Templates allow structs and routines to generate different declarations based on the explicit template arguments or the passed routine argunents.<br>
    They are compatible with specialization constraints, function parameter packs, default values and reference parameters.
</p>
<p>
    Generated declarations are called template instances, and the act of generating them is called template instantiation.<br>
    A template is instantiated every time the template symbol is referenced in the code.<br>

</p>







<!--------------------------------------------------------------------->
<!-- Template declarations                                           -->
<!--------------------------------------------------------------------->
<h1 id="template-declarations"></h1>
<p>
    Struct and routines that use templates are introduced by the <code><w->template</w-></code> meta keyword,
    followed by the <elm-><code>&lt;</code><code>&gt;</code></elm-> meta keywords, in which the template parameters are specified.<br>
    The rest of the declaration is identical to standard routines or structs.<br>
    Notice that //TODO (maybe?) in specialization constraints, the value of template parameters is decided after the instantiation, but everything else is done from the position of the parameter declaration
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-struct">Template struct declaration</label->
    <label- id="copy.syntax--declaration-template-function">Template function declaration</label->
    <label- id="copy.syntax--declaration-template-operator">Template operator declaration</label->
    <label- id="copy.syntax--declaration-template-signature">Template signature</label->
</syntax->
<example->
    <label->Example</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->add</f->(<t->t</t-> <p->a</p->, <t->t</t-> <p->b</p->){
            <w->return</w-> a <f->+</f-> b;
        }
    </div>
</example->










<!--------------------------------------------------------------------->
<!-- Template parameters                                             -->
<!--------------------------------------------------------------------->
<h1 id="template-parameters"></h1>
<p>
    Template parameters can either be values of enum or integral type or type paths, and can be used as such by each declaration after it has been instantiated.<br>
    Value parameters are declared using their respective type, whilst type parameters have to be declared using the <code><w->type</w-></code> meta keyword.
</p>
<p>
    When referenced, struct templates always require template arguments to be specified explicitly.<br>
    Routine templates, instead, can have their type template arguments deduced from the passed routine parameters.<br>
    If one or more template arguments cannot be deduced and is not passed or one or more value template arguments are required, then all the arguments must be specified explicitly.
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-parameter">Template parameter declaration</label->
</syntax->
<example->
    <label->Example 1</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->twice</f->(<t->t</t-> <p->n</p->){
            <w->return</w-> n <f->*</f-> <k->2</k->;
        }
        <w->template</w->&lt;<t->int</t-> <p->n</p->&gt; <t->int</t-> <f->return_n</f->(){
            <w->return</w-> <k->n</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->auto</t-> var1 = <f->twice</f->(<k->8</k->);         <c->// Ok, type t deduced as ulong</c->
            <t->auto</t-> var2 = <f->twice</f->&lt;<t->float</t->&gt;(<k->8</k->);  <c->// Ok, type t specified as float, 8 is converted to from ulong to float</c->
            <t->auto</t-> var3 = <f->return_n</f->&lt;<k->5</k->&gt;();    <c->// Ok, value n specified as 5</c->
        }
    </div>
    <label->Example 2</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->return_0</f->(){
            <w->return</w-> <k->0</k->;
        }
        <w->template</w->&lt;<t->int</t-> <p->n</p->, <w->type</w-> <t->t</t->&gt; <t->t</t-> <f->mult_by_n</f->(<t->t</t-> <p->arg</p->){
            <w->return</w-> arg <f->*</f-> <k->n</k->;
        }


        <t->void</t-> <f->main</f->(){
            <c->auto var1 = return_0();</c->              <ce->// Error, type t cannot be deduced</ce->
            <t->auto</t-> var2 = <f->return_0</f->&lt;<t->double</t->&gt;();      <c->// Ok, type t specified as double</c->

            <c->auto var3 = mult_by_n&lt;5&gt;(2);</c->         <ce->// Error, value template parameter present. All arguments must be specified</ce->
            <t->auto</t-> var3 = <f->mult_by_n</f->&lt;<k->5</k->, <t->ulong</t->&gt;(<k->2</k->);  <c->// Ok, value n specified as 5, type t specified as ulong</c->
        }
    </div>
</example->










<!--------------------------------------------------------------------->
<!-- Template parameter packs                                        -->
<!--------------------------------------------------------------------->
<h1 id="template-parameter-packs"></h1>
<p>
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-parameter-pack">Template parameter pack declaration</label->
</syntax->
<example->
    <label->Example</label->
    <div>
    </div>
</example->












<!--------------------------------------------------------------------->
<!-- Multi argument type deduction                                   -->
<!--------------------------------------------------------------------->
<h1 id="multi-argument-type-deduction"></h1>
<p>
</p>

</p>
            <p>
    When values of different primitive types are used with <a href="#standard-operators">standard operators</a> which require values of the same type, implicit conversions are performed in orer to avoid data loss.<br>
    Which values are converted depends on the rank of their type.<br>
    All the types with low rank are converted to the type of highest rank.
</p>
<p>
    The only exceptions are the bitwise OR, XOR and AND, where no implicit conversions are performed and the result has the same type of the first operand.<br>
    In assignment operators, the result is converted back to the type of the first operand.
</p>
<div class="table-container"><table>
    <tr>
        <th>Type</th>
        <th>Rank</th>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code></td>
        <td class="center">1</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code></td>
        <td class="center">2</td>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code></td>
        <td class="center">3</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code></td>
        <td class="center">4</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code></td>
        <td class="center">5</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code></td>
        <td class="center">6</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code></td>
        <td class="center">7</td>
    </tr>
</table></div>





<p>
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO



    <b>Function templates</b> are the basis of generic programming.<br>
    They are used to <b>generate functions</b> based on the types passed to function calls.<br>
    //TODO UPDATE SYNTAX
    //TODO MOVE TO TEMPLATES
    //TODO ADD STRUCT TEMPLATES
</p>

<syntax->
    <label- id="copy.syntax--declaration-template-struct">Syntax</label->
    <label- id="copy.syntax--declaration-template-function">Syntax</label->
    <label- id="copy.syntax--declaration-template-operator">Syntax</label->
    <label- id="copy.syntax--declaration-template-signature">Syntax</label->
</syntax->

<p>
    Any function with one or more generic type parameters is considered a function template.<br>
    Generic type parameters are declared in the same way as normal parameters, but the type is replaced by a new identifier preceded by a <code>?</code> <a href="#syntactic-elements">token</a>.<br>
    Parameters declared using the same type identifier will always have the same type in any generated function.
</p>
<example->
    <label->Example</label->
    <div>
        <t->?t</t-> <f->add</f->(<t->?t</t-> <p->a</p->, <t->?t</t-> <p->b</p->, <t->int</t-> <p->c</p->){
            return a + b + c;
        }
        <t->auto</t-> <f->add2</f->(<t->?t</t-> <p->a</p->, <t->?u</t-> <p->b</p->){
            <w->return</w-> a + b;
        }

        <t->void</t-> <f->main</f->(){
            <f->add</f->(<k->0</k->, <k->1</k->, <k->0</k->);        <c->// Generates uint add(uint a, uint b, int c)</c->
            <f->add</f->(<k->1.0</k->, <k->0.4</k->, <k->0.2</k->);  <c->// Generates float add(float a, float b, int c)</c->
            <c->//add(1, 0.4, 1);    </c-><ce->// Error, no match for function "add(int a, float b, int c)"</ce->

            <f->add2</f->(<k->0</k->, <k->1</k->);          <c->// Generates uint add2(uint a, uint b)</c->
            <f->add2</f->(<k->1</k->, <k->0.4</k->);        <c->// Generates float add2(uint a, float b) </c-> // TODO
        }
    </div>
</example->

<p>
    Templates allow multiple definitions.<br>
    The <code><w->when</w-></code> and <code><w->default</w-></code> keywords are used to assign the correct one to the generated function, depending on the types used in it.
</p>
<p>
    The expression used in the <code><w->when</w-></code> specifier must be known in compile time and cannot depend on the value of variables declared inside one of the function definitions.<br>
    Calling the function with types that don't match any definition is a semantic error.<br>
</p>
<example->
    <label->Example</label->
    <div>
        <w->strict</w-> <w->enum</w-> type_id : <t->uint</t-> {
            floating_point, integral, other;
        }

        <t->type_id</t-> <f->get_id</f->(<t->?t</t-> <p->n</p->)
        <w->when</w->(<t->t</t-> == <t->int</t-> || <t->t</t-> == <t->uint</t->) {
            <w->return</w-> type_id.<k->integral</k->;
        }
        <w->when</w->(<t->t</t-> == <t->float</t-> || <t->t</t-> == <t->double</t->) {
            <w->return</w-> type_id.<k->floating_point</k->;
        }
        <w->default</w-> {
            <w->return</w-> type_id.<k->other</k->;
        }


        <t->void</t-> <f->main</f->(){
            <f->get_id</f->(<k->-1</k->);      <c->// Returns type_id.integral</c->
            <f->get_id</f->(<k->0.4</k->);     <c->// Returns type_id.floating_point</c->
            <f->get_id</f->((<k->0.4</k->));   <c->// Returns type_id.other</c->
        }
    </div>
</example->

<p>
    Generated functions can be referenced and called using the name of the template and the types of the parameters enclosed in <code>&lt;</code><code>&gt;</code> characters.
</p>
<example->
    <label->Example</label->
    <div>
        <w->strict</w-> <w->enum</w-> type_id : <t->uint</t-> {
            floating_point, integral, other;
        }

        <t->type_id</t-> <f->get_id</f->(<t->?t</t-> <p->n</p->)
        <w->when</w->(<t->t</t-> == <t->int</t-> || <t->t</t-> == <t->uint</t->) {
            <w->return</w-> type_id.<k->integral</k->;
        }
        <w->when</w->(<t->t</t-> == <t->float</t-> || <t->t</t-> == <t->double</t->) {
            <w->return</w-> type_id.<k->floating_point</k->;
        }
        <w->default</w-> {
            <w->return</w-> type_id.<k->other</k->;
        }


        <t->void</t-> <f->main</f->(){
            <f->get_id</f->&lt;<t->int</t->&gt;(<k->0.4</k->); <c->// Returns type_id.integral</c->
            <f->get_id</f->&lt;<t->double</t->&gt;(<k->1</k->); <c->// Returns type_id.floating_point</c->
            <f->get_id</f->&lt;(<t->double</t->)&gt;((<k->0.4</k->)); <c->// Returns type_id.other</c->
            <c->//get_id&lt;double&gt;((0.4)); </c-><ce->// Error, cannot convert "(double)" tuple to "double"</ce->
        }
    </div>
</example->














<!--------------------------------------------------------------------->
<!-- Abbreviated template sytntax                                    -->
<!--------------------------------------------------------------------->
<h1 id="abbreviated-template-syntax"></h1>

