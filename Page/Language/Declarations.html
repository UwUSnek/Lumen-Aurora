

<!--------------------------------------------------------------------->
<!-- Declarations                                                    -->
<!--------------------------------------------------------------------->
<h1 id="declarations"></h1>
<p>
    This section explains the declaration syntax and usage of each category of user-declared <a href="#semantic-elements">semantic elements</a>, also known as <a href="#name-resolution">symbols</a>.
</p>















<!--------------------------------------------------------------------->
<!-- Namespaces                                                      -->
<!--------------------------------------------------------------------->
<h1 id="declarations.namespaces"></h1>
<p>
    <b>Namespaces</b> are used to create <b>named <a href="#scopes">scopes</a></b> to group <a href="#name-resolution">symbols</a>.<br>
    The <a href="#name-resolution">symbol</a> categories they can contain are the same as their parent <a href="#scopes">scope</a>.<br>
    They cannot contain <a href="#statements">statements</a>.
</p>
<p>
    Namespaces don't affect compiler <a href="#optimizations">optimizations</a> or the <a href="#runtime-performance">runtime performance</a> of the program and can be declared in any <a href="#scopes">scope</a>.<br>
    Unnamed namespaces are allowed. Empty namespaces are also allowed.
</p>
<syntax2->
    <label2- id="copy.syntax--namespace-declaration">Declaration syntax</label2->
</syntax2->

<example2->
    <label2->Example</label2->
    <div>
        <w->namespace</w-> a {
            <t->int</t-> n = <k->4</k->;
        }
        <w->namespace</w-> {
            <t->int</t-> n = <k->4</k->;
        }

        <t->int</t-> n2 = a.<k->n</k->;
    </div>
</example2->
















<!--------------------------------------------------------------------->
<!-- declarations.variables                                          -->
<!--------------------------------------------------------------------->
<h1 id="declarations.variables"></h1>
<p>
    <b>Variables</b> are <b>named memory locations</b> used to <b>store values</b> of the corresponding <a href="#types">type</a>.<br>
    Multiple variables of the same <a href="#types">type</a> can be declared in one declaration. If an initializer <a href="#expressions">expression</a> is not specified, the variable has <a href="#undefined-values">undefined value</a>.<br>
</p>
<p>
    Differently from other <a href="#name-resolution">symbols</a>, each variable <b>must be declared</b> before being <a href="#name-resolution">referenced</a>. Variables <b>cannot be redeclared</b> and their <b><a href="#types">type</a> cannot be changed</b> after the declaration.<br>
</p>
<syntax2->
    <label2- id="copy.syntax--variable-declaration">Declaration syntax</label2->
</syntax2->

<example2->
    <label2->Example</label2->
    <div>
        <t->uint</t-> var = <k->0</k->;              <c->// Ok, var has value 0</c->
        <t->float</t-> nya = <k->5</k-> + <k->var</k->;       <c->// Ok, nya has value 5.0</c->
        <t->bool</t-> var2, &var3 = var2;   <c->// Ok, both var2 and var3 have undefined value.</c->
    </div>
</example2->
<p>
    Variables can be <a href="#references">references</a>.<br>
    The <a href="#const-qualifier"><sgr->const</sgr-> qualifier</a> is applicable to the variable itself and/or its <a href="#references">reference</a> qualifier.
</p>
















<!--------------------------------------------------------------------->
<!-- declarations.types                                              -->
<!--------------------------------------------------------------------->
<h1 id="declarations.types"></h1>
















<!--------------------------------------------------------------------->
<!-- declarations.enums                                              -->
<!--------------------------------------------------------------------->
<h1 id="declarations.enums"></h1>
<p>
    <b>Enums</b> are used to <b>group named <a href="#left-and-right-values">r-values</a></b> of the same <a href="#types">type</a>.<br>
    The base <a href="#types">type</a> of an enum can be specified after its name and it must be one of the <a href="#primitive-types">primitive types</a>, or an enum type.<br>
    Elements are declared in the same way as <a href="#variables">variables</a>, but neither the type is not specified explicitly.
</p>
<p>
    Elements of integral enums which are not initialized are given the value of the preceeding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if they are the first.<br>
    Elements of <a href="#boolean-type">boolean</a> and <a href="#floating-point-types">floating point</a> enums must always be initialized.<br>
    Multiple elements can have the same <a href="#values">value</a>, but each element can only be declared once.<br>
    Empty enums and <a href="#unnamed-types">unnamed enums</a> are allowed. //FIXME inline declarations
</p>
<syntax2->
    <label2- id="copy.syntax--enum-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--enum-declaration-signature">Enum signature</label2->
    <label2- id="copy.syntax--enum-declaration-body">Enum body</label2->
    <label2- id="copy.syntax--enum-declaration-element">Element declaration syntax</label2->
</syntax2->

<p>
    By default, all enum elements behave exactly as if they were declared as const variables with type the base type of the enum.<br>
    When <a href="#implicit-conversions">implicit conversions</a> from other <a href="#types">types</a> are undesirable, enums can be declared as <code><w->strict</w-></code>.<br>
    Strict enums can only be assigned values of the same enum type, but can still be <a href="#implicit-conversions">implicitly converted</a> to other <a href="#types">types</a>.
</p>


<example2->
    <label2->Example 1</label2->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            a, b;              <c->// Ok, a = 0, b = 1</c->
            c = <k->-266250</k->;       <c->// Ok, c = -266250</c->
            d, e = <k->0</k->;          <c->// Ok, d = -266249, e = 0</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <w->enum</w-> <t->c</t-> : <t->double</t-> {
            pi = <k->3.14159</k->;      <c->// Ok</c->
            e  = <k->2.71828</k->;      <c->// Ok</c->
            <c->//phi;             </c-><ce->// Error, uninitialized non-integral enum value</ce->
        }

        <t->void</t-> <f->main</f->(){
            <t->c</t-> a = <k->c.pi</k->;        <c->// Ok</c->
            <t->c</t-> b = <k->3.14159</k->;     <c->// Ok</c->
            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 3</label2->
    <div>
        <w->strict enum</w-> <t->c</t-> : <t->double</t-> {
            pi  = <k->3.14159</k->;
            e   = <k->2.71828</k->;
            phi = <k->1.61803</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->c</t-> a = <k->c.phi</k->;       <c->// Ok</c->
            <c->//c b = 1.61803;   </c-><ce->// Error, cannot convert from double to strict enum</ce->
            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
        }
    </div>
</example2->
















<!--------------------------------------------------------------------->
<!-- declarations.structs                                            -->
<!--------------------------------------------------------------------->
<h1 id="declarations.structs"></h1>
<p>
    <b>Structs</b> are used to <b>group named memory locations</b> of <b>different <a href="#types">types</a></b>.<br>
    The members are declared in the same way as <a href="#variables">variables</a> and can be of any <a href="#types">type</a>, including <a href="#arrays">arrays</a>, other structs and <a href="#references">references</a>.<br>
    They cannot be <a href="#const-qualifier"><code><t->const</t-></code></a> and cannot have initializer values.<br>
</p>
<p>
    Empty structs and <a href="#unnamed-types">unnamed structs</a> are allowed.
</p>
<syntax2->
    <label2- id="copy.syntax--struct-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--struct-declaration-signature">Struct signature</label2->
    <label2- id="copy.syntax--struct-declaration-body">Struct body</label2->
    <label2- id="copy.syntax--struct-declaration-member">Member declaration syntax</label2->
</syntax2->

<example2->
    <label2->Example</label2->
    <div>
        <w->struct</w-> <t->idk</t-> {
            <t->uint</t-> a, b;        <c->// Ok</c->
            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
            <c->//double const d; </c-><ce->// Error, struct members cannot be const</ce->
        }

        <t->void</t-> <f->main</f->(){
            <t->idk</t-> var;
            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
        }
    </div>
</example2->

















<!--------------------------------------------------------------------->
<!-- declarations.routines                                           -->
<!--------------------------------------------------------------------->
<h1 id="declarations.routines"></h1>
<p>
    <b>Routines</b> are the <b>main component</b> of the <b>language</b>. They contain the <a href="#statements"><b>statements</b></a> that will be executed during runtime.<br>
    They are used to organize the module, provide features and prevent code duplication.<br>
    The routine execution starts from its first <a href="#statements">statement</a> and ends after the first encountered <a href="#return-statements">return statement</a>.
</p>
<p>
    There are 2 types of routines: <a href="#declarations.functions">Functions</a> and <a href="#declarations.operators">Operators</a>.<br>
    They use different signatures and <a href="#routine-calls">calling</a> syntaxes but share the same <a href="#declarations.routine-parameters">parameter</a> and body declarations.
</p>
<p>
    Each routine <a href="#return-statement">returns</a> a single value when <a href="#routine-calls">called</a>.<br>
    The <a href="#types">type</a> of the <a href="#return-statement">returned</a> value is defined by the <a href="#types">type</a> of the routine.<br>
    Routines can <a href="#return-statement">return</a> any <a href="#types">type</a>, including <a href="#references">references</a>.<br>
    The <a href="#const-qualifier"><code><w->const</w-></code> qualifier</a> cannot be applied to routines.
</p>















<!--------------------------------------------------------------------->
<!-- declarations.functions                                          -->
<!--------------------------------------------------------------------->
<h1 id="declarations.functions"></h1>
<p>
    <b>Functions</b> are a type of <b><a href="declarations.routines">routine</a></b> that requires parentheses to be called.<br>
    They always use the infix notation and can take any number of <a href="#declarations.routine-parameters">parameters</a>.
</p>
<p>
    Function <a href="#identifiers">identifiers</a> must be alphanumeric.
</p>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-function">Declaration syntax</label2->
    <label2- id="copy.syntax--routine-declaration-function-signature">Function signature</label2->
    <label2- id="copy.syntax--routine-declaration-body">Routine body</label2->
</syntax2->
<example2->
    <label2->Example - Add function</label2->
    <div>
        <t->int</t-> <f->add</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->){
            <w->return</w-> a + b;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = </t-><f->add</f->(<k->4</k->, <k->6</k->)
        }
    </div>
</example2->













<!--------------------------------------------------------------------->
<!-- declarations.operators                                          -->
<!--------------------------------------------------------------------->
<h1 id="declarations.operators"></h1>
<p>
    <b>Operators</b> are a type of <b><a href="#declarations.routines">routine</a></b> that doesn't require parentheses to be <a href="#routine-calls">called</a> and can use <b>multiple <a href="#identifiers">identifiers</a></b>.<br>
    Each <a href="#identifiers">identifier</a> can be prefix, infix or postfix, depending on where it is declared in the operator signature.<br>
    Operators can take any number of <a href="#declarations.routine-parameters">parameters</a>, but they cannot be 0 and must be separated by exactly 1 <a href="#identifiers">identifier</a>.
</p>
<p>
    Operator <a href="#identifiers">identifiers</a> can be alphanumeric or symbolic.<br>
    Declaring consecutive <a href="#idnetifiers">identifiers</a> is not allowed.<br>
    Operator precedence is explained in <a href="#declarations.operator-precedence">Operator precedence</a>.
</p>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-operator">Declaration syntax</label2->
    <label2- id="copy.syntax--routine-declaration-operator-signature">Operator signature</label2->
    <label2- id="copy.syntax--routine-declaration-body">Routine body</label2->
</syntax2->
<example2->
    <label2->Example 1 - Promotion operator</label2->
    <div>
        <t->int</t-> <f->+</f-> (<t->int</t-> <a->n</a->) <w->priority</w->(<k->3</k->) {
            <w->return</w-> n;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> r = <f->+</f->2;
        }
    </div>
</example2->
<example2->
    <label2->Example 2 - Python-like ternary operator</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->if_</f-> (<t->bool</t-> <a->condition</a->) <f->else_</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->15</k->) {
            <w->if</w->(condition) <w->return</w-> a;
            <w->else</w-> <w->return</w-> b;
        }

        <t->void</t-> <f->main</f->(<t->bool</t-> <a->c</a->){
            <t->int</t-> r = 5 <f->if_</f-> c <f->else_</f-> 6;
        }
    </div>
</example2->












<!--------------------------------------------------------------------->
<!-- declarations.routine-parameters                                 -->
<!--------------------------------------------------------------------->
<h1 id="declarations.routine-parameters"></h1>
<p>

</p>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-parameter">Declaration syntax</label2->
</syntax2->












<!--------------------------------------------------------------------->
<!-- declarations.operator-precedence                                  -->
<!--------------------------------------------------------------------->
<h1 id="declarations.operator-precedence"></h1>
<p>
    In <b>absence</b> of <b>parentheses</b>, the order in which <b><a href="#declarations.operators">operators</a></b> in the <b>same <a href="#expressions">expression</a></b> are <b><a href="#operator-calls">called</a></b> depends on their <b>priority</b> and <b>associativity</b>.<br>
    Priority and associativity are specified in the <a href="#declarations.operators">operator signature</a> as a <a href="#compile-time-expressions">compile time</a> <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#expressions">expression</a>
    ranging from <code><k->0</k-></code> to <code><k->15</k-></code>, followed by the <code><w->r</w-></code> or <code><w->l</w-></code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    The value indicates the priority.<br>
    Operators declared with lower values have higher priority and are evaluated first.<br>
    Left-associative operators are always evaluated before right-associative operators with the same priority.
</p>
<p>
    The <code><w->r</w-></code> and <code><w->l</w-></code> <a href="#meta-keywords">meta keywords</a> indicate right and left associativity.<br>
    Associativity defines the order in which operators with the same priority and associativity are evaluated.<br>
    Right-associative operators are evaluated starting from the right, whilst left-associative operators are evaluated starting from the left.<br>
</p>
<example2->
    <label2->Example 1 - Priority</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->o</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->p</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->r</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->q</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->5</k-> <w->r</w->) {
            <w->return</w-> b <f->-</f-> a;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->, <t->int</t-> <a->c</a->){
            <c->// Evaluated as ((a o (b p c)) q a)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c <f->q</f-> a;
        }
    </div>
</example2->
<example2->
    <label2->Example 2 - Associativity</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->o</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->p</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->, <t->int</t-> <a->c</a->){
            <c->// Evaluated as ((a o b) p c)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c
        }
    </div>
</example2->
















<!--------------------------------------------------------------------->
<!-- declarations.specual-functions                                  -->
<!--------------------------------------------------------------------->
<h1 id="declarations.special-functions"></h1>
















<!--------------------------------------------------------------------->
<!-- declarations.templates                                          -->
<!--------------------------------------------------------------------->
<h1 id="declarations.templates"></h1>
















<!--------------------------------------------------------------------->
<!-- declarations.template-constraints                               -->
<!--------------------------------------------------------------------->
<h1 id="declarations.template-constraints"></h1>
















<!--------------------------------------------------------------------->
<!-- declarations.symbol-aliases                                     -->
<!--------------------------------------------------------------------->
<h1 id="declarations.symbol-aliases"></h1>















