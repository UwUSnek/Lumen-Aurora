

<!--------------------------------------------------------------------->
<!-- Types                                                           -->
<!--------------------------------------------------------------------->
<h1 id="types"></h1>
<p>
    <b>Data types</b> define how <b><a href="#values">values</a></b> are <b>interpreted</b> during runtime and how they can be used within <a href="#expressions">expressions</a>.<br>
</p>
<p>
    Both languages are statically types.<br>
    Every <a href="#values">value</a> has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
    The type of each <a href="#values">value</a> must be known at compile time, as there are no runtime type informations.
</p>
<p>
    There are no classes, strings, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
    //FIXME
</p>


<!--------------------------------------------------------------------->
<!-- Primitive types                                                 -->
<!--------------------------------------------------------------------->
<h1 id="primitive-types"></h1>
<p>Lux and Umbra feature <b>7 primitive types</b>, which can be used to define more complex types such as <a href="#structs">structs</a>, <a href="#arrays">arrays</a> and <a href="#tuples">tuples</a>.</p>
<p>
    These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
    Primitive types are <b>not <a href="#keywords">keywords</a></b> and can be <a href="#name-shadowing">shadowed</a> like any other <a href="#semantic-elements">symbol</a>.
</p>
<p>The primitive types are:</p>
<div class="table-container"><table>
    <tr>
        <th>Type name   </th>
        <th>Size (bytes)</th>
        <th>Value type  </th>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Unsigned integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Signed integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Floating point number</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code></td>
        <td class="center">4</td>
        <td>Boolean value</td>
    </tr>
</table></div>
<p>
    All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
</p>


<!--------------------------------------------------------------------->
<!-- Integral types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="integral-types"></h1>
<p>
    <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
    <b>Integral types</b> are used to <b>represent integers</b>.<br>
    Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
</p>
<p>
    All signed integral types use the Two's Complement to represent negative numbers.<br>
    Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c->  1              31</c->
                                            <c->sign           value</c->
                                            <c->│┌───────────────┴─────────────┐</c->  <t->int</t->
                                            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                              <c->32</c->
                                                            <c->value</c->
                                            <c->┌────────────────┴─────────────┐</c->  <t->uint</t->
                                            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->  1                              63</c->
            <c->sign                           value</c->
            <c->│┌───────────────────────────────┴─────────────────────────────┐</c->  <t->long</t->
            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                              <c->64</c->
                                            <c->value</c->
            <c->┌────────────────────────────────┴─────────────────────────────┐</c->  <t->ulong</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
        </div>
</example2->
<p>
    //TODO GL_EXT_shader_explicit_arithmetic_types_int64
</p>


<!--------------------------------------------------------------------->
<!-- Floating point types                                            -->
<!--------------------------------------------------------------------->
<h1 id="floating-point-types"></h1>
<p>
    <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
    <b>Floating point types</b> are used to <b>approximately represent real numbers</b>.<br>
</p>
<p>
    Both floating point types are encoded according to the IEEE 754 Standard.<br>
    Positive and negative inf, nan and signed <code><k->0</k-></code> are all supported.<br>
    <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c-> 1      8          23</c->
                                            <c->sign exponent   mantissa</c->
                                            <c->│┌───┴──┐┌──────────┴──────────┐</c->  <t->float</t->
                                            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                            <c->00000000000000000000000000000000</c->  <k->+0.0</k->
                                            <c->10000000000000000000000000000000</c->  <k->-0.0</k->
                                            <c->01111111100000000000000000000000</c->  <k->+inf</k->
                                            <c->11111111100000000000000000000000</c->  <k->-inf</k->
                                            <c->011111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->
                                            <c->111111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->

            <c-> 1      11                           52</c->
            <c->sign  exponent                    mantissa</c->
            <c->│┌────┴────┐┌─────────────────────────┴────────────────────────┐</c->  <t->double</t->
            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->0000000000000000000000000000000000000000000000000000000000000000</c->  <k->+0.0</k->
            <c->1000000000000000000000000000000000000000000000000000000000000000</c->  <k->-0.0</k->
            <c->0111111110000000000000000000000000000000000000000000000000000000</c->  <k->+inf</k->
            <c->1111111110000000000000000000000000000000000000000000000000000000</c->  <k->-inf</k->
            <c->011111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
            <c->111111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
        </div>
</example2->
<p>
    inf values are generated as required by the standard.<br>
    nan values are not generated for consistency and performance reasons.
</p>


<!--------------------------------------------------------------------->
<!-- Boolean type                                                    -->
<!--------------------------------------------------------------------->
<h1 id="boolean-type"></h1>
<p>
    <code><t->bool</t-></code>.<br>
    The <b>Boolean type</b> is used to <b>represent boolean values</b>.<br>
    <code><k->true</k-></code> and <code><k->false</k-></code> are the only values that can be stored in a <code><t->bool</t-></code>.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                            <c->32</c->
                          <c->value</c->
            <c->┌───────────────┴──────────────┐</c->  <t->bool</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->00000000000000000000000000000001</c->  <k->true</k->
            <c->00000000000000000000000000000000</c->  <k->false</k->
        </div>
</example2->
<p>
    Booleans purposely waste 31 bits for performance reasons.<br>
    Smaller types require additional bitwise operations and expensive conversions between the CPU and GPU data.
</p>



















<!--------------------------------------------------------------------->
<!-- User defined types                                              -->
<!--------------------------------------------------------------------->
<h1 id="user-defined-types"></h1>





<!--------------------------------------------------------------------->
<!-- Enums                                                           -->
<!--------------------------------------------------------------------->
<h1 id="enums"></h1>
<p>
    <b>Enums</b> are used to create <b>new types</b> whose allowed values are a <b>subset</b> of the possible values of their <b>base <a href="#types">type</a></b> and can only be used throught their names.<br>
    The base <a href="#types">type</a> of an enum is specified after its name and, differently from most languages, it can be any type, including <a href="#structs">structs</a> or other enums.<br>
    Enum elements are declared in the same way as <a href="#variables">variables</a>, but the type is not specified explicitly and their initializer values must be <a href="#compile-time-values">known at compile time</a>.<br>
    These elements identify the allowed values.
</p>
<p>
    Elements of <a href="#integral-types">integral</a> enums which are not initialized are given the value of the preceeding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if first.<br>
    Elements of enums with any other base <a href="#types">type</a> must always be initialized.<br>
    Multiple elements can have identical <a href="#values">values</a>, but each <a href="#identifiers">identifier</a> can only be declared once.<br>
    Empty enums are allowed.
</p>

<syntax2->
    <label2- id="copy.syntax--enum-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--enum-declaration-element">Element declaration syntax</label2->
</syntax2->

<p>
    Enum elements are <a href="#constant-values">constant values</a>.
    Expressions with enum type
</p>
<p>
    <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to their base <a href="#types">type</a>
    and those whose base <a href="#types">type</a> is a <a href="#primitive-types">primitive type</a> are implicitly convertible to any <a href="#primitive-types">primitive type</a>,
    following the <a href="#impliti-conversions">implicit conversions rules</a> their base <a href="#types">type</a> is subject to.
</p>


<example2->
    <label2->Example 1</label2->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            a, b;              <c->// a = 0, b = 1</c->
            c = <k->-266250</k->;       <c->// c = -266250</c->
            d, e = <k->0</k->;          <c->// d = -266249, e = 0</c->
        }

        <t->float</t-> <f->main</f->(){
            <w->return</w-> e.<k->c</k->; <c->// Implicitly convert e to float</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <w->struct</w-> <t->s</t-> {
            <t->uint</t-> n1, n2;
        }

        <w->enum</w-> <t->e</t-> : <t->s</t-> {
            a = (<k->10</k->, <k->90</k->),
            b = (<k->8</k->, <k->140</k->),
            c = (<k->50</k->, <k->60</k->)
        }
    </div>
</example2->







<!--------------------------------------------------------------------->
<!-- Structs                                                         -->
<!--------------------------------------------------------------------->
<h1 id="structs"></h1>
<p>
    <b>Structs</b> are used to <b>group named memory locations</b> of <b>different <a href="#types">types</a></b>.<br>
    The members are declared in the same way as <a href="#variables">variables</a> and can be of any <a href="#types">type</a>, including other structs.<br>
    They cannot be <a href="#const-qualifier"><sgr>const</sgr></a> and cannot have initializer values.<br>
</p>
<p>
    Empty structs and <a href="#unnamed-types">unnamed structs</a> are allowed.
</p>
<syntax2->
    <label2- id="copy.syntax--struct-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--struct-declaration-signature">Struct signature</label2->
    <label2- id="copy.syntax--struct-declaration-body">Struct body</label2->
    <label2- id="copy.syntax--struct-declaration-member">Member declaration syntax</label2->
</syntax2->

<example2->
    <label2->Example</label2->
    <div>
        <w->struct</w-> <t->idk</t-> {
            <t->uint</t-> a, b;        <c->// Ok</c->
            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
            <c->//double const d; </c-><ce->// Error, struct members cannot be const</ce->
        }

        <t->void</t-> <f->main</f->(){
            <t->idk</t-> var;
            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
        }
    </div>
</example2->















<!--------------------------------------------------------------------->
<!-- Implicit conversions                                            -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions"></h1>
<p>
    <b>Implicit conversions</b> are performed when an <b><a href="#expressions">expression</a></b> of the <b>incorrect <a href="#types">type</a></b> is used in place of the expected one.<br>
    This includes anything whose syntax requires an <a href="#expressions">expression</a>.<br>
    Conversions are not allowed in <a href="#templates">template</a> calls and inizializer values of <a href="auto-specifier">auto</a> <a href="#semantic-elements">symbols</a>.
</p>
<p>
    <a href="#primitive-types">Primitive types</a> are all implicitly convertible to each other.<br>
    <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to their base <a href="#types">type</a>
    and those whose base <a href="#types">type</a> is a <a href="#primitive-types">primitive type</a> are implicitly convertible to any <a href="#primitive-types">primitive type</a>,
    following the <a href="#impliti-conversions">implicit conversions rules</a> their base <a href="#types">type</a> is subject to.
</p>
<p>
    In Lux, some conversions have <a href="#undefined-values">undefined result</a>.<br>
    In Umbra, the same conversions cause <a href="#undefined-behaviour">undefined behaviour</a>.<br>
    The result of the conversions follow these rules:
    //TODO use fedisableexcept(FE_ALL_EXCEPT);
    //TODO it only works on  floating points. integers throw exceptions anyway
</p>
<div class="table-container"><table>
    <!-- integer -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
            <th><range-val->== <k->-9223372036854775808</k-><br><range-var->long:min</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (uint:<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (ulong:<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
            <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->double:min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648</k-><br><range-var->int:min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-16777216</k-><br><range-var->float:min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+16777216</k-><br><range-var->float:max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647</k-><br><range-var->int:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967295</k-><br><range-var->uint:max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % (uint:<k->max</k-> + <k->1</k->)</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->double:max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->long:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+18446744073709551615</k-><br><range-var->ulong:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>


    <!-- floating point -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
            <th><range-val->== <k->-inf</k-><br><range-var->-double:inf</range-var-><br><range-var->-float:inf</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->double:min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->float:min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->long:min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->int:min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->int:max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->uint:max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->long:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->ulong:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->float:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->double:max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+inf</k-><br><range-var->double:inf</range-var-><br><range-var->float:inf</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val-><f->isnan</f->(n)<br><br><range-var->double:nan</range-var-><br><range-var->float:nan</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
        </tr>

    <!-- bool -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr>
            <th rowspan="2"><t->bool</t-></th>
            <th class="nowrap small"><k->false</k-></th>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr>
            <fake-td></fake-td>
            <th class="nowrap small"><k->true</k-></th>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->true</k-></td>
        </tr>
</table></div>





<!--------------------------------------------------------------------->
<!-- Auto specifier                                                  -->
<!--------------------------------------------------------------------->
<h1 id="auto-specifier"></h1>
<p>
    The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b><a href="#types">type</a></b> when declaring a <a href="#semantic-elements">symbol</a>.<br>
    The actual <a href="#types">type</a> of the <a href="#semantic-elements">symbol</a> is determined by the initializer value if a <a href="#variables">variable</a>, or by the <a href="#return-statement">return value</a> if a <a href="#routines">routine</a>.<br>
</p>
<p>
    <code><t->auto</t-></code> is not allowed in <a href="#structs">struct</a> member declarations or <a href="#routine-parameters">routine parameters</a>.<br>
    The <a href="#types">types</a> of the <a href="#expressions">expressions</a> returned from an <code><t->auto</t-></code> <a href="#routines">routine</a> must match.
</p>
<example2->
    <label2->Example 1</label2->
    <div>
        <t->auto</t-> <f->func</f->(){
            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
        }

        <t->auto</t-> <f->main</f->(){
            <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
            <c->// No return statement, main has type void</c->
        }
    </div>
</example2->




<!--------------------------------------------------------------------->
<!-- Typeof specifier                                                -->
<!--------------------------------------------------------------------->
<h1 id="typeof-specifier"></h1>
<p>
    The <b><code><t->typeof</t-></code></b> specifier is used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b><a href="#expressions">expression</a></b> that is passed to it.<br>
    The <a href="#expressions">expression</a> is exclusively used to determine the type and never evaluated.<br>
    Circular dependencies generate a semantic error. //TODO LINK
</p>

<syntax2->
    <label2- id="copy.syntax--typeof">Syntax</label2->
</syntax2->

<example2->
    <label2->Example 1</label2->
    <div>
        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
            <t->int</t-> a = <k->1</k->;              <c->// a has type int</c->
            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <c->//typeof(b) a(){};</c->  <ce->//Error, circular dependency with b</ce->
        <c->//typeof(a) b(){};</c->  <ce->//Error, circular dependency with a</ce->
    </div>
</example2->


