

<!--------------------------------------------------------------------->
<!-- Types                                                           -->
<!--------------------------------------------------------------------->
<h1 id="types"></h1>
<p>
    <b>Data types</b> define how <b><a href="#values">values</a></b> are <b>interpreted</b> during runtime and how they can be used within <a href="#expressions">expressions</a>.<br>
</p>
<p>
    Both languages are statically types.<br>
    Every <a href="#values">value</a> has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
    The type of each <a href="#values">value</a> must be known at compile time, as there are no runtime type informations.
</p>
<p>
    There are no classes, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
    //FIXME ^

    //TODO specify that types are a subset of symbol paths that contains any path to structs, enums, primitive types or special types, which are all considered symbols
</p>



<!--------------------------------------------------------------------->
<!-- Primitive types                                                 -->
<!--------------------------------------------------------------------->
<h1 id="primitive-types"></h1>
<p>Lux and Umbra feature <b>7 primitive types</b>, which can be used to define more complex types such as <a href="#structs">structs</a>, <a href="#arrays">arrays</a> and <a href="#tuples">tuples</a>.</p>
<p>
    These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
    Primitive types are <b>not <a href="#keywords">keywords</a></b> and can be <a href="#name-shadowing">shadowed</a> like any other <a href="#semantic-elements">symbol</a>.
</p>
<p>The primitive types are:</p>
<div class="table-container"><table>
    <tr>
        <th>Type name   </th>
        <th>Size (bytes)</th>
        <th>Value type  </th>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Unsigned integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Signed integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Floating point number</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code></td>
        <td class="center">4</td>
        <td>Boolean value</td>
    </tr>
</table></div>
<p>
    All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
</p>


<!--------------------------------------------------------------------->
<!-- Integral types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="integral-types"></h1>
<p>
    <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
    <b>Integral types</b> are used to <b>represent integers</b>.<br>
    Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
</p>
<p>
    All signed integral types use the Two's Complement to represent negative numbers.<br>
    Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
</p>
<example->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c->  1              31</c->
                                            <c->sign           value</c->
                                            <c->│┌───────────────┴─────────────┐</c->  <t->int</t->
                                            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                              <c->32</c->
                                                            <c->value</c->
                                            <c->┌────────────────┴─────────────┐</c->  <t->uint</t->
                                            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->  1                              63</c->
            <c->sign                           value</c->
            <c->│┌───────────────────────────────┴─────────────────────────────┐</c->  <t->long</t->
            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                              <c->64</c->
                                            <c->value</c->
            <c->┌────────────────────────────────┴─────────────────────────────┐</c->  <t->ulong</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
        </div>
</example->
<p>
    //TODO GL_EXT_shader_explicit_arithmetic_types_int64
</p>


<!--------------------------------------------------------------------->
<!-- Floating point types                                            -->
<!--------------------------------------------------------------------->
<h1 id="floating-point-types"></h1>
<p>
    <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
    <b>Floating point types</b> are used to <b>approximately represent real numbers</b>.<br>
</p>
<p>
    Both floating point types are encoded according to the IEEE 754 Standard.<br>
    Positive and negative inf, nan and signed <code><k->0</k-></code> are all supported.<br>
    <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
</p>
<example->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c-> 1      8          23</c->
                                            <c->sign exponent   mantissa</c->
                                            <c->│┌───┴──┐┌──────────┴──────────┐</c->  <t->float</t->
                                            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                            <c->00000000000000000000000000000000</c->  <k->+0.0</k->
                                            <c->10000000000000000000000000000000</c->  <k->-0.0</k->
                                            <c->01111111100000000000000000000000</c->  <k->+inf</k->
                                            <c->11111111100000000000000000000000</c->  <k->-inf</k->
                                            <c->011111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->
                                            <c->111111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->

            <c-> 1      11                           52</c->
            <c->sign  exponent                    mantissa</c->
            <c->│┌────┴────┐┌─────────────────────────┴────────────────────────┐</c->  <t->double</t->
            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->0000000000000000000000000000000000000000000000000000000000000000</c->  <k->+0.0</k->
            <c->1000000000000000000000000000000000000000000000000000000000000000</c->  <k->-0.0</k->
            <c->0111111110000000000000000000000000000000000000000000000000000000</c->  <k->+inf</k->
            <c->1111111110000000000000000000000000000000000000000000000000000000</c->  <k->-inf</k->
            <c->011111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
            <c->111111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
        </div>
</example->
<p>
    inf values are generated as required by the standard.<br>
    nan values are not generated for consistency and performance reasons.
</p>


<!--------------------------------------------------------------------->
<!-- Boolean type                                                    -->
<!--------------------------------------------------------------------->
<h1 id="boolean-type"></h1>
<p>
    <code><t->bool</t-></code>.<br>
    The <b>Boolean type</b> is used to <b>represent boolean values</b>.<br>
    <code><k->true</k-></code> and <code><k->false</k-></code> are the only values that can be stored in a <code><t->bool</t-></code>.
</p>
<example->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                            <c->32</c->
                          <c->value</c->
            <c->┌───────────────┴──────────────┐</c->  <t->bool</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->00000000000000000000000000000001</c->  <k->true</k->
            <c->00000000000000000000000000000000</c->  <k->false</k->
        </div>
</example->
<p>
    Booleans purposely waste 31 bits for performance reasons.<br>
    Smaller types require additional bitwise operations and expensive conversions between the CPU and GPU data.
</p>














<!--------------------------------------------------------------------->
<!-- Enums                                                           -->
<!--------------------------------------------------------------------->
<h1 id="enums"></h1>
<p>
    <b>Enums</b> are used to create <b>new types</b> whose allowed values are a <b>subset</b> of the possible values of their <b>base <a href="#types">type</a></b> and can only be used throught their names.<br>
    The base <a href="#types">type</a> of an enum is specified after its name and, differently from most languages, it can be any type, including <a href="#structs">structs</a> or other enums.<br>
    Enum elements are declared in the same way as <a href="#variables">variables</a>, but the type is not specified explicitly and their initializer values must be <a href="#compile-time-values">known at compile time</a>.<br>
    These elements identify the allowed values.
</p>
<p>
    Elements of <a href="#integral-types">integral</a> enums which are not initialized are given the value of the preceding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if first.<br>
    Elements of enums with any other base <a href="#types">type</a> must always be initialized.<br>
    Multiple elements can have identical <a href="#values">values</a>, but each <a href="#identifiers">identifier</a> can only be declared once.<br>
    Empty enums are allowed.
</p>

<syntax->
    <label- id="copy.syntax--enum-declaration">Declaration syntax</label->
    <label- id="copy.syntax--enum-declaration-element">Element declaration syntax</label->
</syntax->

<p>
    Enum elements are <a href="#constant-values">constant values</a>.<br>
    <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to any type their base type is implicitly convertible to and the base type itself.<br>
    This is detailedly explained in <a href="#implicit-conversions">Implicit conversions</a>.
</p>


<example->
    <label->Example</label->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            a, b;              <c->// a = 0, b = 1</c->
            c = <k->-266250</k->;       <c->// c = -266250</c->
            d, e = <k->0</k->;          <c->// d = -266249, e = 0</c->
        }

        <t->float</t-> <f->main</f->(){
            <w->return</w-> e.<k->c</k->; <c->// Implicitly convert e to float</c->
        }
    </div>
</example->














<!--------------------------------------------------------------------->
<!-- Struct enums                                                    -->
<!--------------------------------------------------------------------->
<h1 id="struct-enums"></h1>
<p style="margin-bottom: 0;">
    Enums with a <b>struct</b> as <b>base type</b> behave <b>slightly differently</b> than standard enums:<br>
</p>
<ul><ul>
    <li>Elements are initialized through one of the constructors of the base type and destroyed before the process ends as if they were global variables.</li>
    <li>The size of the type is always 8 bytes, regardless of the size of the base struct.</li>
    <li>Struct methods declared in the base struct are not inherited.</li>
    <li>Creating or destroying enum values doesn't call constructors or destructors declared in the base struct.</li>
</ul></ul>
<example->
    <label->Example</label->
    <div>
        <w->struct</w-> <t->s</t-> {
            <t->uint</t-> n1, n2;
        }

        <w->enum</w-> <t->e</t-> : <t->s</t-> {
            a = (<k->10</k->, <k->90</k->),
            b = (<k->8</k->, <k->140</k->),
            c = (<k->50</k->, <k->60</k->)
        }
    </div>
</example->













//TODO improve wording
<!--------------------------------------------------------------------->
<!-- Automatic enum scoping                                          -->
<!--------------------------------------------------------------------->
<h1 id="automatic-enum-scoping"></h1>
<p>
    <b>Automatic enum scoping</b> can be used to <b>skip</b> the idenfiers of <b>parent scopes</b> in a symbol path and reference an enum element through its name alone.<br>
    This is done by replacing the path to the element with a single <code>.</code> keyword.<br>
    Automatic scoping can only be used where the only accepted values are of a specific enum type.
</p>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <w->enum</w-> <t->day</t-> : <t->uint</t-> {
                    <k->mon</k->, <k->two</k->, <k->wed</k->, <k->thu</k->, <k->fri</k->, <k->sat</k->, <k->sun</k->;
                }

                <t->void</t-> <f->check_day</f->(<t->day</t-> <p->d</p->) {
                    <w->match</w-> d {
                        .<k->mon</k-> to .<k->fri</k-> { io.<f->print</f->(<s->"TwT"</s->); }
                        .<k->sat</k-> or .<k->sun</k-> { io.<f->print</f->(<s->"OwO"</s->); }
                    }
                }

                <t->void</t-> <f->main</f->(){
                    <f->check_day</f->(.<k->sun</k->);
                    io.print("\n");
                    <f->check_day</f->(.<k->mon</k->);
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                OwO
                TwT<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->








<!--------------------------------------------------------------------->
<!-- Structs                                                         -->
<!--------------------------------------------------------------------->
<h1 id="structs"></h1>
<p>
    <b>Structs</b> are used to <b>create</b> new <b>types</b> composed by 0 or more separate members that can have differing type.<br>
    The members are declared in the same way as <a href="#variables">variables</a> but cannot have initializer values.
</p>
<p>
    Empty structs are allowed.<br>
    Struct members can be of any <a href="#types">type</a>, including other structs.
</p>
<syntax->
    <label- id="copy.syntax--struct-declaration">Declaration syntax</label->
    <label- id="copy.syntax--struct-declaration-signature">Struct signature</label->
    <label- id="copy.syntax--struct-declaration-body">Struct body</label->
    <label- id="copy.syntax--specialization-constraint">Specialization constraint</label->
    <label- id="copy.syntax--struct-declaration-member">Member declaration syntax</label->
</syntax->
<example->
    <label->Example</label->
    <div>
        <w->struct</w-> <t->idk</t-> {
            <t->uint</t-> a, b;        <c->// Ok</c->
            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
        }

        <t->void</t-> <f->main</f->(){
            <t->idk</t-> var;
            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
        }
    </div>
</example->










<!--------------------------------------------------------------------->
<!-- Struct methods                                                  -->
<!--------------------------------------------------------------------->
<h1 id="struct-methods"></h1>
<p>
    <b>Structs</b> can contain <b>functions</b>. These functions are called <b>methods</b>.<br>
    They are part of the struct scope and are called in the same way as standard functions.
</p>
<p>
    Struct methods can access the members of the value they are called on, and the special identifier <code>this</code> can be used to reference the value itself.<br>
    If the value they are called on is a constant, <code>this</code> and all the members are also constants. Attempting to change their value generates a semantic error.<br>
    Template methods are allowed.
</p>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example</label->
            <div>
                <c->// 2D uint vector</c->
                <w->struct</w-> <t->uint2</t-> {
                    <t->uint</t-> x, y;

                    <t->void</t-> <f->print</f->(){
                        io.<f->print</f->(<s->"x:"</s-> <f->+</f-> <t->str</t->(x));
                        io.<f->print</f->(<s->"\ny: "</s-> <f->+</f-> <t->str</t->(this.y));
                        <c->// Notice that this. is not required when accessing members</c->
                    }

                }

                <t->void</t-> <f->main</f->(){
                    <t->uint2</t-> v = { <k->15</k->, <k->9</k-> };
                    <k->v</k->.<f->print</f->();
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                x: 15
                y: 9<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->














<!--------------------------------------------------------------------->
<!-- Constructor function                                            -->
<!--------------------------------------------------------------------->
<h1 id="constructor-function"></h1>
<p>
    The <b>constructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is created.<br>
    It has <b>no name</b> and <b>no explicit return type</b> and it's declared using the <code><w->constructor</w-></code> meta keyword. Constructor calls always return an l-value of type their parent struct.<br>
    Differently from other struct methods, the constructor can modify members when called on constant values.
</p>
<p>
    Each struct can only have one constructor, but it can be overloaded.<br>
    Template constructors are allowed, although it is not possible to reference a specific template through the <elm-><code>&lt;</code><code>&gt;</code></elm->
    meta keyword while creating a new value, meaning that the declaration is chosen solely based on the passed arguments.<br>
    Constructors cannot be called after the value has been created, but each constructor declaration can call other declarations in the same struct.
</p>
<p>
    By default, each struct contains one implicit constructor that takes a reference parameter for each member in the same order in which they were declared and initializes them by copying the value from their respective parameter.<br>
    This constructor is not present in structs declared using the <code><w->nodefault</w-></code> meta keyword.<br>
    Constructors are allowed to take no arguments.
</p>
<example->
    <label->Example</label->
    <div>
        <w->struct</w-> <t->uint2</t-> {
            <t->uint</t-> x, y;
        }


        <w->struct</w-> <t->uint3</t-> <w->nodefault</w-> {
            <t->uint</t-> x, y, z;

            <w->constructor</w->(<t->uint2</t-> <p->a</p->, <t->uint</t-> <p->b</p->) {
                x <f->=</f-> a.x;
                y <f->=</f-> a.y;
                z <f->=</f-> b;
            }

            <w->constructor</w->(<t->uint</t-> <p->a</p->, <t->uint2</t-> <p->b</p->) {
                x <f->=</f-> a;
                y <f->=</f-> b.x;
                z <f->=</f-> b.y;
            }
        }


        <t->void</t-> <f->main</f->(){
            <t->uint2</t-> a = { <k->1</k->, <k->2</k-> };     <c->// Default constructor</c->
            <t->uint3</t-> b = { <k->a</k->, <k->5</k-> };     <c->// User-defined constructor</c->
            <t->uint3</t-> c = { <k->5</k->, <k->a</k-> };     <c->// User-defined constructor</c->
            <c->//uint3 d = (1, 2, 3);</c->  <ce->// Error, no suitable constructor declaration</ce->
        }
    </div>
</example->










<!--------------------------------------------------------------------->
<!-- Destructor function                                             -->
<!--------------------------------------------------------------------->
<h1 id="destructor-function"></h1>
<p>
    The <b>destructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is destroyed.<br>
    It has <b>no name</b> and <b>no return value</b> and it's declared using the <code><w->destructor</w-></code> meta keyword.<br>
</p>
<p>
    Each struct can only have one destructor. It cannot be overloaded and cannot take any argument, nor can it be called explicitly.<br>
    Template destructors are not allowed.<br>
    There is no default destructor.
</p>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;
                <t->int</t-> last = <k->0</k->;

                <w->struct</w-> <t->s</t-> {
                    <t->float</t-> n;
                    <t->int</t-> i;

                    <w->constructor</w->(<t->float</t-> <p->n</p->){
                        i <f->=</f-> last<f->++</f->;
                        this.n <f->=</f-> n;
                    }

                    <w->destructor</w->(){
                        io.<f->print</f->(<s->"Destroyed instance n."</s-> <f->+</f-> <t->str</t->(i) <f->+</f-> <s->"\n"</s->);
                    }
                }


                <t->void</t-> <f->main</f->(){
                    <t->s</t-> var = { <k->0.5</k-> };
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                Destroyed instance n.0
                Destroyed instance n.1
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->













<!--------------------------------------------------------------------->
<!-- Struct specialization                                           -->
<!--------------------------------------------------------------------->
<h1 id="struct-specialization"></h1>
<p>//TODO</p>















<!--------------------------------------------------------------------->
<!-- Special types                                                   -->
<!--------------------------------------------------------------------->
<h1 id="special-types"></h1>
<p></p>







<!--------------------------------------------------------------------->
<!-- Void type                                                       -->
<!--------------------------------------------------------------------->
<h1 id="void-type"></h1>
<p>
    The <code><t->void</t-></code> type is used to declare routines that don't return any value.<br>
    It has no other purpose but it can be passed to type template parameters to generate different declarations.
</p>
<example->
    <label->Example 1</label->
    <div>
        <f->uint</f-> counter = <k->0</k->;
        <t->void</t-> <f->inc_counter</f->(){ counter<f->++</f->; }

        <t->void</t-> <f->main</f->(){
            <f->inc_counter</f->();
        }
    </div>
</example->
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example 2</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;
                <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->void</t-> <f->print_template_info</f->()
                <w->when</w->(<t->t</t->::<k->id</k-> <f->!=</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"not void"</s->); }
                <w->when</w->(<t->t</t->::<k->id</k-> <f->==</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"void"</s->); }

                <t->void</t-> <f->main</f->(){
                    <f->print_template_info</f->&lt;<t->void</t->&gt;();
                    <f->print_template_info</f->&lt;<t->int</t->&gt;();
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                void
                not void
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->








<!--------------------------------------------------------------------->
<!-- Pointer types                                                   -->
<!--------------------------------------------------------------------->
<h1 id="pointer-types"></h1>
<p>
    Pointer types are implicit types that can store a memory address of a specific type. Their size is always 8 byes<br>
    They are referenced through the symbol path of the pointed type, also known as base type, followed by the <code>@</code> keyword.<br>
    The <code><t->const</t-></code> meta keyword can be placed between the base type and the <code>@</code> keyword to reference the corresponding const pointer. Const pointers are detailedly explained in <a href="#const-qualifier">Const qualifier</a>.
</p>
<p>
    The <code>@</code> keyword is also used to access the value pointed by a pointer expression.<br>
    The address of any l-value can be retrieved through the <code>$</code> keyword.
</p>
<p>
    Pointer types don't have to be declared. Each existing type but <code><t->void</t-></code> has its own corresponding pointer type and <code><t->const</t-></code> pointer type ready to use, including the pointer types themselves.
    <code><t->void</t-></code> pointers are not allowed.<br>
    There is no limit to the amount of nested pointer types one can use as base type.
</p>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->main</f->(){
                    <t->int</t-> n = <k->5</k->;
                    <t->int@</t-> p = $<k->n</k->;

                    @p = <k->6</k->;
                    io.<f->print</f->(<t->str</t->(<k->n</k->));
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                6<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->









<!--------------------------------------------------------------------->
<!-- Function types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="function-types"></h1>














<!--------------------------------------------------------------------->
<!-- Const qualifier                                                 -->
<!--------------------------------------------------------------------->
<h1 id="const-qualifier"></h1>
<p>
    When used between the base type and the <code>@</code> keyword of a pointer type, the <b><code><t->const</t-></code> qualifier</b> indicates that the type is a <b>const pointer</b>.<br>
    Data accessed by dereferencing a <code><t->const</t-></code> pointer value cannot be modified.<br>
    Non-<code><t->const</t-></code> pointers are implicitly convertible to their respective <code><t->const</t-></code> pointer type. This is explained in <a href="implicit-conversions">Implicit coversions</a>.
</p>
<p>
    <b><code><w->const</w-></code></b> can also be used before the name of a <b>variable</b> or <b>routine parameter</b> to <b>prevent them from being modified</b> after their declaration, although this doesn't turn the type of the symbol into a const type.<br>
    The address of <code><w->const</w-></code> variables or <code><w->const</w-></code> routine parameters is always returned as a <code><t->const</t-></code> pointer.
</p>
<example->
    <label->Example 1 - Const pointer</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->int</t-> var = <k->8</k->;
            <t->int const@</t-> ptr = @<k->var</k->;

            <k->var</k-> <f->=</f-> <k->9</k->;     <c->// Ok</c->
            <c->//@ptr = 9;</c->  <ce->// Error, cannot modify data pointed by const pointers</ce->
        }
    </div>
    <label->Example 2 - Const variable</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->int</t-> var <w->const</w-> = <k->8</k->;

            <c->var = 9;</c->  <ce->// Error, cannot modify const variables</ce->
        }
    </div>
</example->














<!--------------------------------------------------------------------->
<!-- Implicit conversions                                            -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions"></h1>
<p>
    <b>Implicit conversions</b> are performed when an <b><a href="#expressions">expression</a></b> of the <b>incorrect <a href="#types">type</a></b> is used in place of the expected one.<br>
    This includes anything whose syntax requires an <a href="#expressions">expression</a>.<br>
    Conversions are not allowed in <a href="#templates">template</a> calls and inizializer values of <a href="auto-specifier">auto</a> <a href="#semantic-elements">symbols</a>.
</p>
<p>
    <a href="#primitive-types">Primitive types</a> are all implicitly convertible to each other.<br>
    <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to their base <a href="#types">type</a>
    and those whose base <a href="#types">type</a> is a <a href="#primitive-types">primitive type</a> are implicitly convertible to any <a href="#primitive-types">primitive type</a>,
    following the <a href="#impliti-conversions">implicit conversions rules</a> their base <a href="#types">type</a> is subject to.
</p>
<p>
    In Lux, some conversions have <a href="#undefined-values">undefined result</a>.<br>
    In Umbra, the same conversions cause <a href="#undefined-behaviour">undefined behaviour</a>.<br>
    The result of the conversions follow these rules:
    //TODO use fedisableexcept(FE_ALL_EXCEPT);
    //TODO it only works on  floating points. integers throw exceptions anyway
</p>
<div class="table-container"><table>
    <!-- integer -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
            <th><range-val->== <k->-9223372036854775808</k-><br><range-var->long::min</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (uint::<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (ulong::<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
            <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->double::min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648</k-><br><range-var->int::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-16777216</k-><br><range-var->float::min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+16777216</k-><br><range-var->float::max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647</k-><br><range-var->int::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967295</k-><br><range-var->uint::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % (uint::<k->max</k-> + <k->1</k->)</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->double::max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->long::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+18446744073709551615</k-><br><range-var->ulong::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>


    <!-- floating point -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
            <th><range-val->== <k->-inf</k-><br><range-var->-double::inf</range-var-><br><range-var->-float::inf</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->double::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->float::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->long::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->int::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->int::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->uint::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->long::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->ulong::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->float::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->double::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+inf</k-><br><range-var->double::inf</range-var-><br><range-var->float::inf</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val-><f->isnan</f->(n)<br><br><range-var->double::nan</range-var-><br><range-var->float::nan</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
        </tr>

    <!-- bool -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr>
            <th rowspan="2"><t->bool</t-></th>
            <th class="nowrap small"><k->false</k-></th>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr>
            <fake-td></fake-td>
            <th class="nowrap small"><k->true</k-></th>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->true</k-></td>
        </tr>
</table></div>





<!--------------------------------------------------------------------->
<!-- Auto specifier                                                  -->
<!--------------------------------------------------------------------->
<h1 id="auto-specifier"></h1>
<p>
    The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b><a href="#types">type</a></b> when declaring a <a href="#semantic-elements">symbol</a>.<br>
    The actual <a href="#types">type</a> of the <a href="#semantic-elements">symbol</a> is determined by the initializer value if a <a href="#variables">variable</a>, or by the <a href="#return-statement">return value</a> if a <a href="#routines">routine</a>.<br>
</p>
<p>
    <code><t->auto</t-></code> is not allowed in <a href="#structs">struct</a> member declarations or <a href="#routine-parameters">routine parameters</a>.<br>
    The <a href="#types">types</a> of the <a href="#expressions">expressions</a> returned from an <code><t->auto</t-></code> <a href="#routines">routine</a> must match.
</p>
<example->
    <label->Example 1</label->
    <div>
        <t->auto</t-> <f->func</f->(){
            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
        }

        <t->auto</t-> <f->main</f->(){
            <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
            <c->// No return statement, main has type void</c->
        }
    </div>
</example->




<!--------------------------------------------------------------------->
<!-- Typeof specifier                                                -->
<!--------------------------------------------------------------------->
<h1 id="typeof-specifier"></h1>
<p>
    The <b><code><t->typeof</t-></code></b> specifier is used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b><a href="#expressions">expression</a></b> that is passed to it.<br>
    The <a href="#expressions">expression</a> is exclusively used to determine the type and never evaluated.<br>
    Circular dependencies generate a semantic error. //TODO LINK
</p>

<syntax->
    <label- id="copy.syntax--typeof">Syntax</label->
</syntax->

<example->
    <label->Example 1</label->
    <div>
        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
            <t->int</t-> a = <k->1</k->;              <c->// a has type int</c->
            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int</c->
        }
    </div>
</example->
<example->
    <label->Example 2</label->
    <div>
        <c->//typeof(b) a(){};</c->  <ce->//Error, circular dependency with b</ce->
        <c->//typeof(a) b(){};</c->  <ce->//Error, circular dependency with a</ce->
    </div>
</example->


