

<!--------------------------------------------------------------------->
<!-- Types                                                           -->
<!--------------------------------------------------------------------->
<h1 id="types"></h1>
<p>
    <b>Data types</b> define how <b><a href="#values">values</a></b> are <b>interpreted</b> during runtime and how they can be used within <a href="#expressions">expressions</a>.<br>
</p>
<p>
    Both languages are statically types.<br>
    Every <a href="#values">value</a> has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
    The type of each <a href="#values">value</a> must be known at compile time, as there are no runtime type informations.
</p>
<p>
    There are no classes, strings, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
    //FIXME
</p>


<!--------------------------------------------------------------------->
<!-- Primitive types                                                 -->
<!--------------------------------------------------------------------->
<h1 id="primitive-types"></h1>
<p>Lux and Umbra feature <b>7 primitive types</b>, which can be used to define more complex types such as <a href="#structs">structs</a>, <a href="#arrays">arrays</a> and <a href="#tuples">tuples</a>.</p>
<p>
    These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
    Primitive types are <b>not <a href="#keywords">keywords</a></b> and can be <a href="#name-shadowing">shadowed</a> like any other <a href="#semantic-elements">symbol</a>.
</p>
<p>The primitive types are:</p>
<div class="table-container"><table>
    <tr>
        <th>Type name   </th>
        <th>Size (bytes)</th>
        <th>Value type  </th>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Unsigned integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Signed integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Floating point number</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code></td>
        <td class="center">4</td>
        <td>Boolean value</td>
    </tr>
</table></div>
<p>
    All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
</p>


<!--------------------------------------------------------------------->
<!-- Integral types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="integral-types"></h1>
<p>
    <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
    <b>Integral types</b> are used to <b>represent integers</b>.<br>
    Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
</p>
<p>
    All signed integral types use the Two's Complement to represent negative numbers.<br>
    Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c->  1              31</c->
                                            <c->sign           value</c->
                                            <c->│┌───────────────┴─────────────┐</c->  <t->int</t->
                                            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                              <c->32</c->
                                                            <c->value</c->
                                            <c->┌────────────────┴─────────────┐</c->  <t->uint</t->
                                            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->  1                              63</c->
            <c->sign                           value</c->
            <c->│┌───────────────────────────────┴─────────────────────────────┐</c->  <t->long</t->
            <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                              <c->64</c->
                                            <c->value</c->
            <c->┌────────────────────────────────┴─────────────────────────────┐</c->  <t->ulong</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
        </div>
</example2->
<p>
    //TODO GL_EXT_shader_explicit_arithmetic_types_int64
</p>


<!--------------------------------------------------------------------->
<!-- Floating point types                                            -->
<!--------------------------------------------------------------------->
<h1 id="floating-point-types"></h1>
<p>
    <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
    <b>Floating point types</b> are used to <b>approximate real numbers</b>.<br>
</p>
<p>
    Both floating point types are encoded according to the IEEE 754 Standard.<br>
    Positive and negative <code><k->inf</k-></code>, <code><k->nan</k-></code> and signed <code><k->0</k-></code> are all supported.<br>
    <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c-> 1      8          23</c->
                                            <c->sign exponent   mantissa</c->
                                            <c->│┌───┴──┐┌──────────┴──────────┐</c->  <t->float</t->
                                            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                            <c->00000000000000000000000000000000</c->  <k->+0.0</k->
                                            <c->10000000000000000000000000000000</c->  <k->-0.0</k->
                                            <c->01111111100000000000000000000000</c->  <k->+inf</k->
                                            <c->11111111100000000000000000000000</c->  <k->-inf</k->
                                            <c->011111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->
                                            <c->111111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->

            <c-> 1      11                           52</c->
            <c->sign  exponent                    mantissa</c->
            <c->│┌────┴────┐┌─────────────────────────┴────────────────────────┐</c->  <t->double</t->
            <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->0000000000000000000000000000000000000000000000000000000000000000</c->  <k->+0.0</k->
            <c->1000000000000000000000000000000000000000000000000000000000000000</c->  <k->-0.0</k->
            <c->0111111110000000000000000000000000000000000000000000000000000000</c->  <k->+inf</k->
            <c->1111111110000000000000000000000000000000000000000000000000000000</c->  <k->-inf</k->
            <c->011111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
            <c->111111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
        </div>
</example2->
<p>
    <code><k->inf</k-></code> values are generated as required by the standard.<br>
    <code><k->nan</k-></code> values are not generated for consistency and performance reasons.
</p>


<!--------------------------------------------------------------------->
<!-- Boolean type                                                    -->
<!--------------------------------------------------------------------->
<h1 id="boolean-type"></h1>
<p>
    <code><t->bool</t-></code>.<br>
    The <b>Boolean type</b> is used to <b>represend conditions</b>.<br>
    Its value can be <code><k->true</k-></code> or <code><k->false</k-></code>.
</p>
<example2->
        <div style="border-top-left-radius: var(--code-decoration-r);">
                            <c->32</c->
                          <c->value</c->
            <c->┌───────────────┴──────────────┐</c->  <t->bool</t->
            <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            <c->00000000000000000000000000000001</c->  <k->true</k->
            <c->00000000000000000000000000000000</c->  <k->false</k->
        </div>
</example2->
<p>
    Booleans purposely waste 31 bits for performance reasons.<br>
    Smaller types require additional bitwise operations and expensive conversions between the CPU and GPU data.
</p>


<!--------------------------------------------------------------------->
<!-- Enums                                                           -->
<!--------------------------------------------------------------------->
<h1 id="enums"></h1>
<p>
    <b>Enums</b> are used to <b>group named <a href="#compile-time-values">compile time</a> <a href="#left-and-right-values">r-values</a></b> of the same <a href="#types">type</a>.<br>
    The base <a href="#types">type</a> of an enum can be specified after its name and it must be one of the <a href="#primitive-types">primitive types</a>, or an enum type.<br>
    Elements are declared in the same way as <a href="#variables">variables</a>, but the type is not specified explicitly.
</p>
<p>
    Elements of integral enums which are not initialized are given the value of the preceeding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if they are the first.<br>
    Elements of <a href="#boolean-type">boolean</a> and <a href="#floating-point-types">floating point</a> enums must always be initialized.<br>
    Multiple elements can have the same <a href="#values">value</a>, but each <a href="#identifiers">identifier</a> can only be declared once.<br>
    Empty enums are allowed.
</p>
<syntax2->
    <label2- id="copy.syntax--enum-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--enum-declaration-signature">Enum signature</label2->
    <label2- id="copy.syntax--enum-declaration-body">Enum body</label2->
    <label2- id="copy.syntax--enum-declaration-element">Element declaration syntax</label2->
</syntax2->

<p>
    By default, all enum elements behave exactly as if they were declared as const variables with type the base type of the enum.<br>
    When <a href="#implicit-conversions">implicit conversions</a> from other <a href="#types">types</a> are undesirable, enums can be declared as <code><w->strict</w-></code>.<br>
    Strict enums can only be assigned values of the same enum type, but can still be <a href="#implicit-conversions">implicitly converted</a> to other <a href="#types">types</a>.
</p>


<example2->
    <label2->Example 1</label2->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            a, b;              <c->// Ok, a = 0, b = 1</c->
            c = <k->-266250</k->;       <c->// Ok, c = -266250</c->
            d, e = <k->0</k->;          <c->// Ok, d = -266249, e = 0</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <w->enum</w-> <t->c</t-> : <t->double</t-> {
            pi = <k->3.14159</k->;      <c->// Ok</c->
            e  = <k->2.71828</k->;      <c->// Ok</c->
            <c->//phi;             </c-><ce->// Error, uninitialized non-integral enum value</ce->
        }

        <t->void</t-> <f->main</f->(){
            <t->c</t-> a = <k->c.pi</k->;        <c->// Ok</c->
            <t->c</t-> b = <k->3.14159</k->;     <c->// Ok</c->
            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 3</label2->
    <div>
        <w->strict enum</w-> <t->c</t-> : <t->double</t-> {
            pi  = <k->3.14159</k->;
            e   = <k->2.71828</k->;
            phi = <k->1.61803</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->c</t-> a = <k->c.phi</k->;       <c->// Ok</c->
            <c->//c b = 1.61803;   </c-><ce->// Error, cannot convert from double to strict enum</ce->
            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
        }
    </div>
</example2->


















<!--------------------------------------------------------------------->
<!-- Aggregate types                                                 -->
<!--------------------------------------------------------------------->
<h1 id="aggregate-types"></h1>


<!--------------------------------------------------------------------->
<!-- Structs                                                         -->
<!--------------------------------------------------------------------->
<h1 id="structs"></h1>
<p>
    <b>Structs</b> are used to <b>group named memory locations</b> of <b>different <a href="#types">types</a></b>.<br>
    The members are declared in the same way as <a href="#variables">variables</a> and can be of any <a href="#types">type</a>, including other structs.<br>
    They cannot be <a href="#const-qualifier"><sgr>const</sgr></a> and cannot have initializer values.<br>
</p>
<p>
    Empty structs and <a href="#unnamed-types">unnamed structs</a> are allowed.
</p>
<syntax2->
    <label2- id="copy.syntax--struct-declaration">Declaration syntax</label2->
    <label2- id="copy.syntax--struct-declaration-signature">Struct signature</label2->
    <label2- id="copy.syntax--struct-declaration-body">Struct body</label2->
    <label2- id="copy.syntax--struct-declaration-member">Member declaration syntax</label2->
</syntax2->

<example2->
    <label2->Example</label2->
    <div>
        <w->struct</w-> <t->idk</t-> {
            <t->uint</t-> a, b;        <c->// Ok</c->
            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
            <c->//double const d; </c-><ce->// Error, struct members cannot be const</ce->
        }

        <t->void</t-> <f->main</f->(){
            <t->idk</t-> var;
            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
        }
    </div>
</example2->





















<!--------------------------------------------------------------------->
<!-- Special types                                                   -->
<!--------------------------------------------------------------------->
<h1 id="special-types"></h1>


<!--------------------------------------------------------------------->
<!-- Void                                                            -->
<!--------------------------------------------------------------------->
<h1 id="void"></h1>
<p>
    The <code><t->void</t-></code> <a href="#types">type</a> is a special <a href="#types">type</a>. It is exclusively used to define <a href="#functions">functions</a> that don't <a href="#return-statement">return</a> any <a href="#values">value</a>.<br>
    It cannot store <a href="#values">values</a> like other <a href="#types">types</a>, but it can be used as value of <a href="#typename">typename</a> <a href="#semantic-elements">symbols</a>.
</p>
<p>
    Passing <code><t->viod</t-></code> to a <a href="#templates">template</a> parameter is allowed.
</p>




<!--------------------------------------------------------------------->
<!-- Implicit conversions                                            -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions"></h1>
<p>
    <b>Implicit conversions</b> are performed when an <b><a href="#expressions">expression</a></b> of the <b>incorrect <a href="#types">type</a></b> is used in place of the expected one.<br>
    This includes anything whose syntax requires an <a href="#expressions">expression</a>.<br>
    Conversions are not allowed in <a href="#function-templates">function template</a> calls and inizializer values of <a href="auto-specifier">auto</a> <a href="#semantic-elements">symbols</a>.
</p>
<p>
    <a href="#primitive-types">Primitive types</a> are all implicitly convertible between them.<br>
    In Lux, some conversions have <a href="#undefined-values">undefined result</a>.<br>
    In Umbra, the same conversions cause <a href="#undefined-behaviour">undefined behaviour</a>.<br>
    The result of the conversions follow these rules:
    //TODO use fedisableexcept(FE_ALL_EXCEPT);
    //TODO it only works on  floating points. integers throw exceptions anyway
</p>
<div class="table-container"><table>
    <!-- integer -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
            <th><range-val->== <k->-9223372036854775808</k-><br><range-var->limits.long.min</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (limits.uint.<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (limits.ulong.<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
            <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->limits.double.min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648</k-><br><range-var->limits.int.min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-16777216</k-><br><range-var->limits.float.min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+16777216</k-><br><range-var->limits.float.max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647</k-><br><range-var->limits.int.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967295</k-><br><range-var->limits.uint.max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % (limits.uint.<k->max</k-> + <k->1</k->)</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->limits.double.max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->limits.long.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+18446744073709551615</k-><br><range-var->limits.ulong.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>


    <!-- floating point -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
            <th><range-val->== <k->-inf</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->limits.double.min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->limits.float.min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->limits.long.min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->limits.int.min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->limits.int.max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->limits.uint.max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->limits.long.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->limits.ulong.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->limits.float.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->limits.double.max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+inf</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val-><f->isnan</f->(n)<br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
        </tr>

    <!-- bool -->
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr>
            <th rowspan="2"><t->bool</t-></th>
            <th class="nowrap small"><k->false</k-></th>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr>
            <fake-td></fake-td>
            <th class="nowrap small"><k->true</k-></th>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->true</k-></td>
        </tr>
</table></div>





<!--------------------------------------------------------------------->
<!-- Auto specifier                                                  -->
<!--------------------------------------------------------------------->
<h1 id="auto-specifier"></h1>
<p>
    The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b><a href="#types">type</a></b> when declaring a <a href="#semantic-elements">symbol</a>.<br>
    The actual <a href="#types">type</a> of the <a href="#semantic-elements">symbol</a> is determined by the initializer value, if its is a <a href="#variables">variable</a>, or by the <a href="#return-statement">return value</a> if it is a <a href="#functions">function</a>.<br>
</p>
<p>
    <code><t->auto</t-></code> is not allowed in <a href="#structs">struct</a> members declarations or <a href="#function-definitions">function parameters</a>.<br>
    <code><t->auto</t-></code> <a href="#constructors">constructors</a> are equivalent to <a href="#constructors">unnamed constructors</a>.
</p>
<syntax->
    <fill->
        <label- class="nobefore">Referencing syntax</label->
        <div>
            <table>
                <tr->
                    <td><b-lr-></b-lr-></td>
                    <td><code>auto</code></td>
                    <td><b-lr-></b-lr-></td>
                </tr->
            </table>
        </div>
    </fill->
</syntax->
<example2->
    <label2->Example 1</label2->
    <div>
        <t->auto</t-> <f->func</f->(){
            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
        }

        <t->auto</t-> <f->main</f->(){
            <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
            <c->// No return statement, main has type void</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <t->auto</t-> a <f->=</f-> <t->int</t->[<k->4</k->](<k->1</k->, <k->1</k->, <k->0</k->, <k->1</k->);     <c->// Ok, a has type int[4] and value (1, 1, 0, 1)</c->
        <t->auto</t-> <t->const</t-> b <f->=</f-> <f->!</f-><k->a</k->;               <c->// Ok, b has type bool[4] and value (false, false, true, false)</c->
    </div>
</example2->


<!--------------------------------------------------------------------->
<!-- Typeof specifier                                                -->
<!--------------------------------------------------------------------->
<h1 id="typeof-specifier"></h1>
<p>
    The <b><code><t->typeof</t-></code></b> specifier is used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b><a href="#expressions">expression</a></b> that is passed to it.<br>
    Passing a <a href="#types">type</a> to <code><t->typeof</t-></code> returns <code><t->typename</t-></code>.
</p>
<p>
    The <a href="#values">value</a> passed to <code><t->typeof</t-></code> can be <a href="#compile-time-expressions">runtime</a>.
    <code><t->typeof</t-></code> <a href="#constructors">constructors</a> are allowed.<br>
    Circular dependencies are a semantic error. //TODO LINK
</p>

<syntax->
    <fill->
        <label- class="nobefore">Referencing syntax</label->
        <div>
            <table>
                <tr>
                    <td><b-lr-></b-lr-></td>
                    <td><code><t->typeof</t-></code></td>
                    <td><b-lr-></b-lr-></td>
                    <td><code>(</code></td>
                    <td><b-lr-></b-lr-></td>
                    <td><elm-><t->T</t-><sup>r</sup></elm-></td>
                    <td><b-lr-></b-lr-></td>
                    <td><code>)</code></td>
                    <td><b-lr-></b-lr-></td>
                </tr>
            </table>
        </div>
    </fill->
</syntax->
<example2->
    <label2->Example 1</label2->
    <div>
        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
            <t->int</t-> a[<k->2</k->] = (<k->1</k->, <k->2</k->);      <c->// a has type int[2]</c->
            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int[2]</c->
        }
    </div>
</example2->
<example2->
    <label2->Example 2</label2->
    <div>
        <c->//typeof(b) a(){};</c->  <ce->//Error, circular dependency with b</ce->
        <c->//typeof(a) b(){};</c->  <ce->//Error, circular dependency with a</ce->
    </div>
</example2->


