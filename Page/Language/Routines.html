

<!--------------------------------------------------------------------->
<!-- Routines                                                        -->
<!--------------------------------------------------------------------->
<h1 id="routines"></h1>
<p>
    <b>Routines</b> are the <b>main component</b> of the <b>language</b>. They contain the <a href="#statements"><b>statements</b></a> that will be executed during runtime.<br>
    They are used to organize the module, provide features and prevent code duplication.<br>
    The routine execution starts from its first <a href="#statements">statement</a> and ends after the first encountered <a href="#return-statements">return statement</a>.
</p>
<p>
    There are 2 types of routines: <a href="#declarations.functions">Functions</a> and <a href="#declarations.operators">Operators</a>.<br>
    They use different signatures and <a href="#routine-calls">calling</a> syntaxes but share the same <a href="#declarations.routine-parameters">parameter</a> and body declarations.
</p>
<p>
    Each routine can <a href="#return-statement">return</a> a single value when <a href="#routine-calls">called</a>.<br>
    The <a href="#types">type</a> of the <a href="#return-statement">returned</a> value is defined by the <a href="#types">type</a> of the routine.<br>
    Routines that don't return a value have to be declared using the <code><w->void</w-></code> keyword.
</p>
<p>
    The <a href="#const-qualifier"><code><w->const</w-></code> qualifier</a> cannot be applied to routines.
</p>





<!--------------------------------------------------------------------->
<!-- Functions                                                       -->
<!--------------------------------------------------------------------->
<h1 id="functions"></h1>




<!--------------------------------------------------------------------->
<!-- Function declarations                                           -->
<!--------------------------------------------------------------------->
<h1 id="function-declarations"></h1>
<p>
    <b>Functions</b> are a type of <b><a href="declarations.routines">routine</a></b> that requires parentheses to be called.<br>
    They always use the infix notation and can take any number of <a href="#declarations.routine-parameters">parameters</a>.
</p>
<p>
    Function <a href="#identifiers">identifiers</a> must be alphanumeric.
</p>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-function">Declaration syntax</label2->
    <label2- id="copy.syntax--routine-declaration-function-signature">Function signature</label2->
    <label2- id="copy.syntax--routine-declaration-body">Routine body</label2->
</syntax2->
<example2->
    <label2->Example - Add function</label2->
    <div>
        <t->int</t-> <f->add</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->){
            <w->return</w-> a + b;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = </t-><f->add</f->(<k->4</k->, <k->6</k->)
        }
    </div>
</example2->





<!--------------------------------------------------------------------->
<!-- The main function                                               -->
<!--------------------------------------------------------------------->
<h1 id="the-main-function"></h1>
<p>
    The <b><code><f->main</f-></code> function</b> is where the <b>code execution starts and ends</b>.<br>
    Every shader <b>must define</b> the <b><code><f->main</f-></code></b> function.<br>
</p>
<p>
    The parameters of the <code><f->main</f-></code> are passed from the <a href="./Umbra.html">Umbra Language</a> and contain all the inputs and outputs the shader needs to run and interact with other shaders.<br>
    The <code><f->main</f-></code> function can return any type and take const or reference parameters.<br>
    It can also be called by other functions or itself, but it cannot be a template.<br>
</p>









<!--------------------------------------------------------------------->
<!-- Operators                                                       -->
<!--------------------------------------------------------------------->
<h1 id="operators"></h1>



<!--------------------------------------------------------------------->
<!-- Operator declarations                                           -->
<!--------------------------------------------------------------------->
<h1 id="operator-declarations"></h1>
<p>
    <b>Operators</b> are a type of <b><a href="#declarations.routines">routine</a></b> that doesn't require parentheses to be <a href="#routine-calls">called</a> and can use <b>multiple <a href="#identifiers">identifiers</a></b>.<br>
    Each <a href="#identifiers">identifier</a> can be prefix, infix or postfix, depending on where it is declared in the operator signature.<br>
    Operators can take any number of <a href="#declarations.routine-parameters">parameters</a>, but they cannot be 0 and must be separated by exactly 1 <a href="#identifiers">identifier</a>.
</p>
<p>
    Operator <a href="#identifiers">identifiers</a> can be alphanumeric or symbolic.<br>
    Declaring consecutive <a href="#idnetifiers">identifiers</a> is not allowed.<br>
    Operator precedence is explained in <a href="#declarations.operator-precedence">Operator precedence</a>.
</p>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-operator">Declaration syntax</label2->
    <label2- id="copy.syntax--routine-declaration-operator-signature">Operator signature</label2->
    <label2- id="copy.syntax--routine-declaration-body">Routine body</label2->
</syntax2->
<example2->
    <label2->Example 1 - Promotion operator</label2->
    <div>
        <t->int</t-> <f->+</f-> (<t->int</t-> <a->n</a->) <w->priority</w->(<k->3</k->) {
            <w->return</w-> n;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> r = <f->+</f->2;
        }
    </div>
</example2->
<example2->
    <label2->Example 2 - Python-like ternary operator</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->if_</f-> (<t->bool</t-> <a->condition</a->) <f->else_</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->15</k->) {
            <w->if</w->(condition) <w->return</w-> a;
            <w->else</w-> <w->return</w-> b;
        }

        <t->void</t-> <f->main</f->(<t->bool</t-> <a->c</a->){
            <t->int</t-> r = 5 <f->if_</f-> c <f->else_</f-> 6;
        }
    </div>
</example2->









<!--------------------------------------------------------------------->
<!-- Operator precedence                                             -->
<!--------------------------------------------------------------------->
<h1 id="operator-precedence"></h1>
<p>
    In <b>absence</b> of <b>parentheses</b>, the order in which <b><a href="#declarations.operators">operators</a></b> in the <b>same <a href="#expressions">expression</a></b> are <b><a href="#operator-calls">called</a></b> depends on their <b>priority</b> and <b>associativity</b>.<br>
    Priority and associativity are specified in the <a href="#declarations.operators">operator signature</a> as a <a href="#compile-time-expressions">compile time</a> <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#expressions">expression</a>
    ranging from <code><k->0</k-></code> to <code><k->15</k-></code>, followed by the <code><w->r</w-></code> or <code><w->l</w-></code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    The value indicates the priority.<br>
    Operators declared with lower values have higher priority and are evaluated first.<br>
    Left-associative operators are always evaluated before right-associative operators with the same priority.
</p>
<p>
    The <code><w->r</w-></code> and <code><w->l</w-></code> <a href="#meta-keywords">meta keywords</a> indicate right and left associativity.<br>
    Associativity defines the order in which operators with the same priority and associativity are evaluated.<br>
    Right-associative operators are evaluated starting from the right, whilst left-associative operators are evaluated starting from the left.<br>
</p>
<example2->
    <label2->Example 1 - Priority</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->o</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->p</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->r</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->q</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->5</k-> <w->r</w->) {
            <w->return</w-> b <f->-</f-> a;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->, <t->int</t-> <a->c</a->){
            <c->// Evaluated as ((a o (b p c)) q a)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c <f->q</f-> a;
        }
    </div>
</example2->
<example2->
    <label2->Example 2 - Associativity</label2->
    <div>
        <t->int</t-> (<t->int</t-> <a->a</a->) <f->o</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <a->a</a->) <f->p</f-> (<t->int</t-> <a->b</a->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <a->a</a->, <t->int</t-> <a->b</a->, <t->int</t-> <a->c</a->){
            <c->// Evaluated as ((a o b) p c)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c
        }
    </div>
</example2->






<!--------------------------------------------------------------------->
<!-- Routine parameters                                              -->
<!--------------------------------------------------------------------->
<h1 id="routine-parameters"></h1>
<syntax2->
    <label2- id="copy.syntax--routine-declaration-parameter">Declaration syntax</label2->
</syntax2->
<p>
    By <b>default</b>, the arguments are passed <b>by value</b>, which means that when the function is called, the value of each argument is <b>copied</b> in the corresponding parameter and the function <b>cannot access</b> the original variable.<br>
    If a parameter name is preceeded by a <b><code>&</code></b> <a href="#syntactic-elements">token</a>, instead, the argument is passed <b>by reference</b>, allowing the function to <b>access and modify</b> its value
</p>
<p>
    Declaring a reference parameter as const is a syntax error and passing an <a href="#left-and-right-values">r-value</a> as argument of a reference parameter is a semantic error.<br>
    Notice that in this case, the <code>&</code> <a href="#syntactic-elements">token</a> is not part of the type nor part of the name, but a language feature that is used exclusively within parameter declarations.
</p>

<example2->
    <label2->Example</label2->
    <div>
        <t->void</t-> <f->fun1</f->(<t->uint</t-> <a->arg1</a->, <t->uint</t-> &<a->arg2</a->) {
            arg1 = <k->0</k->;     <c->// c_doesn't modify main.a, but the local argument in which its value was copied</c->
            arg2 = <k->0</k->;     <c->// c_modifies main.b</c->
        }

        <t->void</t-> <f->main</f->(){
            <t->uint</t-> a, b;
            <f->fun1</f->(a, b);   <c->// a keeps an undefined value, b is set to 0</c->
            <c->//fun1(a, 5); </c-><ce->// Error, cannot pass literals to reference parameters</ce->
        }

        <c->//void fun2(const int &arg1){} </c-><ce->// Error, references cannot be const</ce->
    </div>
</example2->

<p>
    See
    <a href="#const-qualifier">Const qualifier</a>,
    <a href="#literals">Literals</a>
</p>






