<!DOCTYPE html>
<html>
<head>
    <title>Lux language</title>
    <meta charset="UTF-8">
    <meta name="author" content="" /> <!-- TODO -->
    <meta name="description" content="" /> <!-- TODO -->

    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />

    <link rel="stylesheet" type="text/css" href="Style.css" media="screen">

    <style>
        .table-1-container {
            white-space: nowrap;
            padding: 0;
            margin: 0;
            min-width: 100%;
            border-radius: 10px 0 0 0;
            overflow: hidden;
            word-spacing: -9999ch;
            text-align: center;
        }.table-1-right-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: calc(100% - 24ch);
        }.table-1-right {
            border-radius: 0 10px 10px 0;
            word-spacing: var(--word-spacing);
        }.table-1-left-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: 24ch;
            border-bottom-left-radius: 10px;
        }.table-1-left {
            border-radius: 10px 0 0 10px;
            word-spacing: var(--word-spacing);
        }.table-1-y {
            background-color: #0a7a003a;
        }.table-1-n {
            background-color: #7a00003a;
        }
    </style>
</head>
<body>
<script>
    function decodeHTML(html) {
        var txt = document.createElement("textarea");
        txt.innerHTML = html;
        return txt.value;
    }
    function dedent(s){
        // find shortest indentation
        var min;
        s = s.split('\n');
        for(var i = 0; i < s.length; i++){
            var line = s[i];
            var spaces = line.search(/\S/);
            if((min > spaces || min == undefined) && spaces >= 0){
                min = spaces;
            }
        }
        // remove indentation
        for(var i = 0; i < s.length; i++){
            var line = s[i];
            s[i] = line.substring(min, line.length);
        }

        // join and return all lines
        return s.join("\n");
    }

    function copy_code(button_tag) {
        var children = Array.from(button_tag.parentNode.childNodes);
        for(var i = 0; i < children.length; i++){
            if(children[i].tagName == "CODE_") {
                navigator.clipboard.writeText(decodeHTML(dedent(children[i].innerHTML.replace(/<\/?(!--|([a-zA-Z0-9_\-]+))[^>]+>/g, ""))));
                return 0;
            }
        }
    }
</script>




<div class="main-container hide-scrollbar">

    <!--------------------------------------------------------------------->
    <!-- Index                                                           -->
    <!--------------------------------------------------------------------->
    <div class="main-left-container hide-scrollbar">
        <ul style="padding-left:0;" class="index">
            <li class="index-section" style="margin-top: 0px;"><a href="#overview-no-header">Overview</a></li>
            <li class="index-section" style="margin-top: 0px;"><a href="#preprocessor">Preprocessor</a>
                <ul>
                    <li><a href="#comments">Comments</a></li>
                    <li><a href="#include-statement">Include statement</a></li>
                    <li><a href="#macros">Macros //TODO</a></li>
                    <li><a href="#conditionals">Conditionals //TODO</a></li>
                    <li><a href="#line-continuation-token">Line continuation token</a></li>
                </ul>
            </li>
            <li class="index-section"><a href="#language-components">Language components</a>
                <ul>
                    <li><a href="#tokens-and-identifiers">Tokens and identifiers</a></li>
                    <li><a href="#scopes-and-symbols">Scopes and symbols</a></li>
                    <li><a href="#namespaces">Namespaces</a></li>
                    <li><a href="#types">Types</a>
                        <ul>
                            <li><a href="#primitive-types">Primitive types</a></li>
                            <li><a href="#enums">Enums</a></li>
                            <li><a href="#structs">Structs</a></li>
                            <li><a href="#arrays">Arrays</a></li>
                            <li><a href="#implicit-conversions">Implicit conversions</a></li>
                            <li><a href="#auto-specifier">Auto specifier</a></li>
                            <li><a href="#typeof-and-baseof-specifiers">Typeof and baseof specifiers</a></li>
                            <li><a href="#unnamed-types">Unnamed types</a></li>
                        </ul>
                    </li>
                    <li><a href="#variables">Variables</a>
                        <ul>
                            <li><a href="#temporary-variables">Temporary variables</a></li>
                        </ul>
                    </li>
                    <li><a href="#functions">functions</a>
                        <ul>
                            <li><a href="#parameters-and-references">Parameters and references</a></li>
                            <li><a href="#return-statement">Return statement</a></li>
                            <li><a href="#function-calls">Function calls</a></li>
                            <li><a href="#template-functions">Template functions</a></li>
                            <li><a href="#type-groups">Type groups</a></li>
                        </ul>
                    </li>
                    <li><a href="#const-qualifier">Const qualifier</a></li>
                    <li><a href="#symbol-aliases">Symbol aliases</a></li>
                </ul>
            </li>
            <li class="index-section"><a href="#runtime-statements">Runtime statements</a>
                <ul>
                    <li><a href="#left-and-right-values">Left and right values</a></li>
                    <li><a href="#expressions">Expressions</a>
                        <ul>
                            <li><a href="#literals">Literals</li></a> //TODO compile time known values have the same color ofrals lite
                            <li><a href="#constructors">Constructors</a></li>
                            <li><a href="#operators">Operators</a></li>
                            <li><a href="#special-operators">Special operators</a></li>
                            <li><a href="#array-operations">Array operations</a></li>
                        </ul>
                    </li>
                    <li><a href="#assignments">Assignments</a>
                        <ul>
                            <li><a href="#composite-assignments">Composite assignments</a></li>
                            <li><a href="#multiple-assignments">Multiple assignments</a></li>
                        </ul>
                    </li>
                    <li><a href="#selection">Selection</a>
                        <ul>
                            <li><a href="#if-statement">If statement</a></li>
                            <li><a href="#select-statement">Select statement</a></li>
                        </ul>
                    </li>
                    <li><a href="#iteration">Iteration</a>
                        <ul>
                            <li><a href="#for-loops">For loops</a></li>
                            <li><a href="#while-loops">While loops</a></li>
                            <li><a href="#continue-and-break-statements">Continue and break statements</a></li>
                            <li><a href="#once-statement">Once statement</a></li>
                            <li><a href="#then-statement">Then statement</a></li>
                        </ul>
                        <li><a href="#else-statement">Else statement</a></li>
                    </li>
                </ul>
            </li>
            <li class="index-section"><a href="#compilation">Compilation</a>
                <ul>
                    <li><a href="#modules">Modules</a></li>
                    <li><a href="#compilation-phases-and-error-types">Compilation phases and error types</a></li>
                    <li><a href="#global-initialization-order">Global initialization order</a></li>
                    <li><a href="#branching-performance">Branching performance</a></li>
                    <li><a href="#compiler-optimizations">Compiler optimizations</a></li>
                </ul>
            </li>
            <li class="index-section"><a href="#standard-modules">Standard modules</a>
                <ul>
                    <li><a href=#"">idk</a></li>
                </ul>
            </li>
            <li class="index-section"><a href="#quick-reference-tabs">Quick reference tabs</a></li>
            <li class="index-section"><a href="#complete-examples">Complete examples</a></li>
        </ul>
    </div>

    <div class="main-right-container hide-scrollbar">
        <!--------------------------------------------------------------------->
        <!-- Logo                                                            -->
        <!--------------------------------------------------------------------->
        <div class="logo-right-top"></div>
        <div class="logo logo-right" style="background-image: url('Lux-logo.png');"></div>

        <div style="background-color: var(--bg-color);">
            <!--------------------------------------------------------------------->
            <!-- Overview                                                        -->
            <!--------------------------------------------------------------------->
            <div style="margin-top: var(--main-padding);"></div>
            <h1 id="overview-no-header">Lux - Lynx shading language</h1>
            <sep-3_></sep-3_>
            <p>
                Lux is a <b>high level compiled shading language</b> with the aim of helping developers to efficiently write shaders without going through the tedious work of manually managing buffers and shaders.<br>
                It compiles to <b>GLSL 4.6</b>.
            </p>
            <p>The language is meant to be used alongside <b>Umbra</b>, the main programming language of the Lynx Engine, as it is highly compatible and interfacing shaders requires little to no effort.</p>
            <p>Lux is part of the <b>Lynx SDK</b>.</p>
            <p><a href="#quick-reference-tabs">Quick reference tabs</a></p>








            <!--------------------------------------------------------------------->
            <!-- Preprocessor                                                    -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id=preprocessor>Preprocessor</h1>
            <p>
                The <b>preprocessing</b> phase is done <b>before compiling</b> the code.<br>
                It removes comments and evaluates preprocessor directives and line continuation tokens.
            </p>
            <p>
                <b>Preprocessor directives</b> are special instructions that allow the <b>code</b> to be <b>programmatically modified</b>.<br>
                All the preprocessor directives are identified by the <code>#</code> character followed by their name and definition.<br>
                Each directive spans over a single, complete line of code.<br>
                Preprocessor directives are always case sensitive.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Comments                                                        -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id=comments>Comments</h2>
            <p>
                <b>Comments</b> are <b>portions of code</b> that are <b>purposely ignored</b>.<br>
                They can be used to provide informations or temporarily exclude lines of code.<br>
                Comments are allowed to contain any sequence of unicode characters of any length.<br>
            </p>
            <p>
                Single line comments start with <code>//</code> and end at the first newline character.<br>
                Multiline comments start with <code>/*</code> and end with <code>*/</code>
            </p>
            <p>Comments cannot be nested.</p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        //<elm_>Comment string</elm_><nl_></nl_>
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>2</label_>
                    <code_>
                        /*<elm_>Comment string</elm_>*/
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <c_>// Single line comment</c_>

                        <c_>/* Multi
                        line
                        comment */</c_>
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <c_>/* Multi line /* Anorhter comment */ comment */
                        // Ok                             // ^ Error, unexpected token "comment"</c_>
                    </code_>
                </fill_>
            </example_>




            <!--------------------------------------------------------------------->
            <!-- Include statement                                               -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id=include-statement>Include statement</h2>
            <p>
                <b>Include statements</b> are used to <b>paste code</b> from other files.<br>
                Any existent file can be included, regardless of its contents or extension.<br>
                The path to the included file must be enclosed in <code>"</code><code>"</code> and can only contain alphanumeric characters, dots and slashes. //TODO <br>
                Both absolute and relative paths are supported.
            </p>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        #include<space_></space_>"<elm_>absolute/path/to/file</elm_>"<nl_></nl_>
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        #include<space_></space_>"./<elm_>relative/path/to/file</elm_>"<nl_></nl_>
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        #include<space_></space_>"<elm_>relative/path/to/file</elm_>"<nl_></nl_>
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <c_>// Ok</c_>
                        <k_>#include</k_> <s_>"/home/Lynx/Lux/file.ilsh"</s_>
                        <k_>#include</k_> <s_>"./file.ilsh"</s_>
                        <k_>#include</k_> <s_>"file.ilsh"</s_>

                        <c_>// Error</c_>
                        <c_>//#include ./file.ilsh</c_>
                        <c_>//#include "./non_existent_file"</c_>
                        <c_>//#include ""</c_>
                    </code_>
                </fill_>
            </example_>




            <!--------------------------------------------------------------------->
            <!-- Macros                                                          -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="macros">Macros</h2>




            <!--------------------------------------------------------------------->
            <!-- Conditionals                                                    -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="conditionals">Conditionals</h2>




            <!--------------------------------------------------------------------->
            <!-- Line continuation token                                         -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="line-continuation-token">Line continuation token</h2>
            <p>
                The <b>line continuation token</b> can be used to <b>merge multiple lines</b> and allow single line comments, preprocessor directives and multi character tokens to be written across multiple lines.<br>
                It consists of a <code>\</code> immediatly followed by a newline character.
            </p>
            <p>
                Line continuation tokens can be used inside comments or other preprocessor directives, but cannot be nested.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        \<nl_></nl_>
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <c_>// single line comment</c_>\
                        <c_>on two lines</c_>

                        <c_>// #include "path/to/file"</c_>
                        <k_>#include</k_> <s_>"pat</s_>\
                        <s_>h/to/file</s_>\
                        <s_>"</s_>

                        <c_>// void function() {
                        //   uint var = 0, b = 0;
                        //   var += b;
                        // }</c_>
                        <t_>vo</t_>\
                        <t_>id</t_> <f_>fun</f_>\
                        <f_>ction</f_>() {
                        <t_>uint</t_> va\
                        r = <k_>0</k_>, b = <k_>0</k_>;
                        v\
                        ar +\
                        = <k_>b</k_>;
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <c_>// Error, unexpected token "\"
                            //void ma\\

                            //in(){}
                            // Error,  unexpected token "in"</c_>
                        </code_>
                </fill_>
            </example_>








            <!--------------------------------------------------------------------->
            <!-- Language components                                             -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="language-components">Language components</h1>




            <!--------------------------------------------------------------------->
            <!-- Tokens and identifiers                                          -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="tokens-and-identifiers">Tokens and identifiers</h2>
            <p>
                Any sequence of one or more characters that is left after the preprocessing phase is called a token.<br>
                Comments and whitespace characters can be freely written between two tokens without altering the GLSL output.<br>
                Tokens are always case sensitive.<br>
                Comments, newline characters, whitespace characters and preprocessor directives are <b>not tokens</b>.
            </p>

            <p>Each token can be classified as one of the following:</p>
            <div class="table-container"><table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th style="text-align: center;" colspan=4>Pattern</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Identifier</td>
                        <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code>, <code>$</code> and <code>_</code> that doesn't start with a decimal digit</td>
                    </tr>
                    <tr>
                        <td>Literal</td>
                        <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code> and <code>.</code> that starts with a decimal digit</td>
                    </tr>
                    <tr>
                        <td>Keyword</td>
                        <td class="center" colspan=2>
                            <a href="#namespaces">                  <code><w_>namespace</w_></code></a>
                            <a href="#enums">                       <code><w_>enum</w_></code></a>
                            <a href="#structs">                     <code><w_>struct</w_></code></a>
                            <a href="#auto-specifier">              <code><w_>auto</w_></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t_>typeof</t_></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t_>baseof</t_></code></a>
                            <a href="#type-groups">                 <code><w_>typegroup</w_></code></a>
                            <a href="#const-qualifier">             <code><t_>const</t_></code></a>
                            <a href="#symbol-aliases">              <code><w_>alias</w_></code></a>
                        </td>
                        <td class="center" colspan=2>
                            <a href="#if-statement">                 <code><w_>if</w_></code></a>
                            <a href="#select-statement">             <code><w_>select</w_></code></a>
                            <a href="#for-loops">                    <code><w_>for</w_></code></a>
                            <a href="#while-loops">                  <code><w_>while</w_></code></a>
                            <a href="#while-loops">                  <code><w_>do</w_></code></a>
                            <a href="#continue-and-break-statements"><code><w_>continue</w_></code></a>
                            <a href="#continue-and-break-statements"><code><w_>break</w_></code></a>
                            <a href="#once-statement">               <code><w_>once</w_></code></a>
                            <a href="#then-statement">               <code><w_>then</w_></code></a>
                            <a href="#else-statement">               <code><w_>else</w_></code></a>
                            <a href="#return-statement">             <code><w_>return</w_></code></a>
                        </td>
                    </tr>
                    <tr>
                        <td>Operator</td>
                        <td class="center">
                            <a href="#operators"><code>!</code></a>
                            <a href="#operators"><code>==</code></a>
                            <a href="#operators"><code>!=</code></a>
                            <a href="#operators"><code>=:</code></a>
                            <a href="#operators"><code>!:</code></a>
                            <a href="#operators"><code>&&</code></a>
                            <a href="#operators"><code>^^</code></a>
                            <a href="#operators"><code>||</code></a>
                            <a href="#operators"><code>&lt;</code></a>
                            <a href="#operators"><code>&lt;=</code></a>
                            <a href="#operators"><code>&gt;</code></a>
                            <a href="#operators"><code>&gt;=</code></a>
                        </td>
                        <td class="center">
                            <a href="#operators"><code>+</code></a>
                            <a href="#operators"><code>-</code></a>
                            <a href="#operators"><code>++</code></a>
                            <a href="#operators"><code>--</code></a>
                            <a href="#operators"><code>*</code></a>
                            <a href="#operators"><code>/</code></a>
                            <a href="#operators"><code>%</code></a>
                        </td>
                        <td class="center">
                            <a href="#operators"><code>&</code></a>
                            <a href="#operators"><code>|</code></a>
                            <a href="#operators"><code>^</code></a>
                            <a href="#operators"><code>&lt;&lt;</code></a>
                            <a href="#operators"><code>&gt;&gt;</code></a>
                            <a href="#operators"><code>~</code></a>
                        </td>
                        <td class="center wide-lines">
                            <a href="#special-operators"><elm_><code>(</code><code>)</code></elm_></a>
                            <a href="#special-operators"><elm_><code>[</code><code>]</code></elm_></a>
                            <a href="#special-operators"><code>.</code></a>
                            <a href="#special-operators"><elm_><code>?</code><code>:</code></elm_></a>
                        </td>
                    </tr>
                    <tr>
                        <td>Punctuation token</td>
                        <td class="center wide-lines" width="20%">
                            <elm_><code>(</code><code>)</code></elm_>
                            <a href="#scopes-and-symbols"><elm_><code>{</code><code>}</code></elm_></a>
                            <a href="#arrays">            <elm_><code>[</code><code>]</code></elm_></a>
                        </td>
                        <td class="center" width="20%">
                            <code>,</code>
                            <code>;</code>
                            <code>|</code>
                            <a href="#scopes-and-symbols"><code>::</code></a>
                        </td>
                        <td class="center" width="20%"><a href="#parameters-and-references"><code>&</code></a></td>
                        <td class="center" width="20%"><a href="#for-loops"><code>:</code></a></td>
                    </tr>
                    <tr>
                        <td>Assignment token</td>
                        <td class="center">
                            <a href="#assignments"><code>=</code></a>
                        </td>
                        <td class="center">
                            <a href="#assignments"><code>+=</code></a>
                            <a href="#assignments"><code>*=</code></a>
                            <a href="#assignments"><code>-=</code></a>
                            <a href="#assignments"><code>/=</code></a>
                            <a href="#assignments"><code>%=</code></a>
                        </td>
                        <td class="center" colspan=2><div style="width: 50%;">
                            <a href="#assignments"><code>&=</code></a>
                            <a href="#assignments"><code>|=</code></a>
                            <a href="#assignments"><code>^=</code></a>
                            <a href="#assignments"><code>&lt;&lt;=</code></a>
                            <a href="#assignments"><code>&gt;&gt;=</code></a>
                        </div></td>
                    </tr>
                </tbody>
            </table></div>
            <p>
                Identifiers are used to name symbols.<br>
                They must be unique to the current scope and not overlap with keywords.<br>
                Temporary variables are the only identifiers that are allowed to start with a <code>$</code>.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Scopes and symbols                                              -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="scopes-and-symbols">Scopes and symbols</h2>
            <p>A <b>symbol</b> is any <b>language component</b> that can be declared.</p>
            <p>
                <b>Scopes</b> define which <b>symbols</b> the code can <b>reference</b> and their absolute and relative names.<br>
                Any portion of code enclosed in <code>{</code><code>}</code> defines a new scope. the only exception is the <b>module scope</b>. It is always defined and contains all the symbols and scopes declared in the module. It can be referenced using the <code>this</code> identifier.<br>
                Like normal scopes, <code>this</code> can also be shadowed.
            </p>
            <p>
                Each scope can only contain certain types of symbols:
            </p>

            <div class="table-1-container">
                <div class="table-container table-1-left-container"><table class="table-1-left">
                    <tr style="height: 80px;"><th>Container scope</th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#modules">Module           </a></th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#scopes-and-symbols">Namespace        </a></th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#enums">             Enum             </a></th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#structs">           Struct           </a></th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#functions">         Function         </a></th></tr>
                    <tr style="height: 80px;"><th><a style="color: var(--text-color)" href="#runtime-statements">Runtime statement</a></th></tr>
                </table></div>
                <div class="table-container table-1-right-container"><table class="table-1-right">
                    <tr style="height: 80px;">
                        <td><a style="color: var(--text-color)" href="#variables">                 Variable          </a></td>
                        <td><a style="color: var(--text-color)" href="#type-groups">               Type group        </a></td>
                        <td><a style="color: var(--text-color)" href="#runtime-statements">        Runtime statement </a></td>
                        <td><a style="color: var(--text-color)" href="#parametersa-and-references">Function parameter</a></td>
                        <td><a style="color: var(--text-color)" href="#enums">                     Enum element      </a></td>
                        <td><a style="color: var(--text-color)" href="#structs">                   Struct element    </a></td>
                        <td><a style="color: var(--text-color)" href="#structs">                   Struct            </a></td>
                        <td><a style="color: var(--text-color)" href="#enums">                     Enum              </a></td>
                        <td><a style="color: var(--text-color)" href="#namespaces">                Namespace         </a></td>
                        <td><a style="color: var(--text-color)" href="#symbol-aliases">            Symbol alias      </a></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                </table></div>
            </div>
            <p>
                <b>Local names</b> are used to reference symbols declared in the <b>current scope</b> or in one of the <b>enclosing scopes</b>.<br>
                <b>Relative names</b>, instead, can reference <b>any symbol</b> declared in the module. They consist of the local names of an enclosing scope, the symbol and all the enclosing scopes in between, separated by <code>::</code> tokens, in the same order as they were declared in the code.<br>
                A relative name that starts from the module scope is called an absolute name.
            </p>
            <p>
                Declaring a symbol with the same identifier as one declared in an enclosing scope will shadow the old symbol, and any use of the local identifier in the current and sub scopes will refer to the new symbol.<br>
                Declaring the same identifier more than once in the same scope is only allowed for function overloading. Anything else is a semantic error.<br>
            </p>
            <p>Symbols declared in unnamed scopes cannot be referenced from outside, and unnamed symbols cannot be referenced at all</p>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <c_>// Module scope</c_>
                        <c_>// Local name: this</c_>


                        <c_>// Local name: s</c_>
                        <c_>// Relative names: this::s</c_>
                        <w_>struct</w_> <t_>s</t_> { <t_>uint</t_> n; }

                        <w_>namespace</w_> {
                            <c_>// Local name: fun</c_>
                            <c_>// Unnamed enclosing scope, cannot be referenced from outside</c_>
                            <t_>void</t_> <f_>fun</f_>(<t_>uint</t_> <a_>n</a_>) {}
                        }


                        <c_>// Local name: fun</c_>
                        <c_>// Relative names: this::fun</c_>
                        <t_>void</t_> <f_>fun</f_>(<t_>uint</t_> <a_>n</a_>) {
                            <w_>if</w_>(n){
                                <c_>// Local name: s2</c_>
                                <c_>// Unnamed enclosing scope, cannot be referenced from outside</c_>
                                <w_>struct</w_> <t_>s2</t_> { <t_>uint</t_> n; };
                            }

                            <c_>// Local name: s, shadows this::s</c_>
                            <c_>// Relative names: this::fun::s, fun::s</c_>
                            <w_>struct</w_> <t_>s</t_> { <t_>uint</t_> a, b; }
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <p>Symbols can be declared anywhere in the scope, except for variables, which have to be declared before they are used in expressions.</p>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>void</t_> <f_>main</f_>(){
                            <c_>//var.n = 8;     // Error</c_>
                            <t_>s</t_> var = (<k_>16</k_>); <c_>   // Ok</c_>
                        }
                        <w_>struct</w_> s { <t_>int</t_> n; }
                    </code_>
                </fill_>
            </example_>




            <!--------------------------------------------------------------------->
            <!-- Namespaces                                                      -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="namespaces">Namespaces</h2>
            <p>
                <b>Namespaces</b> are used to create <b>named scopes</b> which can contain
                <a href="#variables">variables</a>, <a href="#functions">functions</a>, <a href="#structs">structs</a>, <a href="#enums">enums</a>, <a href="#symbol-aliases">symbol aliases</a>.<br>
                They don't affect the runtime behaviour and can be declared in any scope.<br>
                Unnamed namespaces are allowed.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        namespace<space_></space_><elm_>name<sup>id</sup></elm_> {<elm_>...</elm_>}
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        namespace {<elm_>...</elm_>}
                    </code_>
                </fill_>
            </syntax_>




            <!--------------------------------------------------------------------->
            <!-- Types                                                           -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="types">Types</h2>
            <p>
                <b>Data types</b> define how <b>values</b> are <b>interpreted</b> during runtime and how they can be used within expressions.<br>
                Every value has an associated type, regardless of it being a right or a left value.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Primitive types                                                 -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="primitive-types">Primitive types</h3>
            <p>Lux features <b>five primitive types</b>, which can be used to define more complex types such as structs, arrays and enums.</p>
            <p>
                Those types are always present and they act as if they were declared in the module scope.<br>
                Primitive types are <b>not keywords</b> and can be shadowed like any other symbol.
            </p>
            <p>The primitive types are:</p>
            <div class="table-container"><table>
                <tr>
                    <th>Type name   </th>
                    <th>Size (bytes)</th>
                    <th>Value type  </th>
                </tr>
                <tr>
                    <td><code><t_>uint</t_></code></td>
                    <td class="center">4</td>
                    <td>Unsigned integral number</td>
                </tr>
                <tr>
                    <td><code><t_>int</t_></code></td>
                    <td class="center">4</td>
                    <td>Signed integral number</td>
                </tr>
                <tr>
                    <td><code><t_>float</t_></code></td>
                    <td class="center">4</td>
                    <td>Floating point number</td>
                </tr>
                <tr>
                    <td><code><t_>double</t_></code></td>
                    <td class="center">8</td>
                    <td>Floating point number</td>
                </tr>
                <tr>
                    <td><code><t_>bool</t_></code></td>
                    <td class="center">4</td>
                    <td>Boolean value. <code><k_>true</k_></code> or <code><k_>false</k_></code></td>
                </tr>
            </table></div>
            <p>
                As in most programming languages, the boolean <code><k_>true</k_></code> and <code><k_>false</k_></code> values correspond to the integral literals <code><k_>1</k_></code> and <code><k_>0</k_></code>. They can be used interchangeably.<br>
                Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
            </p>
            <p>
                All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
                There are no 64 bit integers, characters or strings.
            </p>
            <p>
                See
                <a href="#values">Values</a>,
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Enums                                                           -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="enums">Enums</h3>
            <p>
                <b>Enums</b> are used to <b>name</b> and <b>group</b> literal <b>constants</b> of the same type.<br>
                The base type of the enum can be specified after its name and it must be one of the primitive types.<br>
                Elements are declared in the same way as variables, but neither the type nor the const qualifier are specified explicitly.<br>
                The initializer values are implicitly converted to the base type of the enum.
            </p>
            <p>
                Elements of integral enums which are not initizlied will have the value of the preceeding element + 1, or 0 if they are the first.<br>
                Elements of boolean and floating point enums must always be initialized.<br>
                Multiple elements can have the same value, but each element can only be declared once.<br>
                Enums with no elements are not allowed.
            </p>

            <sep_></sep_>
            <syntax_>
                <left_>
                    <label_></label_>
                    <code_>
                        enum<space_></space_><elm_>name<sup>id</sup></elm_> : <elm_><t_>T<sup>type</sup></t_> </elm_>{
                            <elm_>elements<sup>...</sup></elm_>
                        }
                    </code_>
                </left_>
                <right_>
                    <label_>Element syntax</label_>
                    <code_>
                        <elm_>name<sup>id</sup></elm_> = <elm_><t_>T<sup>r</sup></t_></elm_>;


                    </code_>
                </right_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <w_>enum</w_> <t_>e</t_> : <t_>int</t_> {
                            a, b;              <c_>// Ok, a = 0, b = 1</c_>
                            c = <k_>-266250</k_>;       <c_>// Ok, c = -266250</c_>
                            d, e = 0;          <c_>// Ok, d = -266249, e = 0</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <w_>enum</w_> <t_>c</t_> : <t_>double</t_> {
                            pi = <k_>3.14159</k_>;      <c_>// Ok</c_>
                            e  = <k_>2.71828</k_>;      <c_>// Ok</c_>
                            <c_>//phi;             // Error, uninitialized non-integral enum value</c_>
                        }

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>c</t_> a = <k_>c::pi</k_>;       <c_>// Ok</c_>
                            <t_>c</t_> b = <k_>3.14159</k_>;     <c_>// Ok</c_>
                            <t_>int</t_> c = <k_>a</k_>;         <c_>// Ok, implicit conversion from c (double) to int</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>

            <p>
                By default, all enums behave exactly as their base types, much like a <a href="#symbol-aliases">symbol alias</a>.<br>
                When implicit conversions from other types are undesirable, enums can be declared as <code><w_>strict</w_></code>.<br>
                Strict enums only allow values of the same enum, but can still be implicitly converted to other types.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        strict<space_></space_>enum<space_></space_><elm_>name<sup>id</sup></elm_> : <elm_><t_>T<sup>type</sup></t_></elm_> {
                            <elm_>elements<sup>...</sup></elm_>
                        }
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <w_>strict enum</w_> <t_>c</t_> : <t_>double</t_> {
                            pi  = <k_>3.14159</k_>;
                            e   = <k_>2.71828</k_>;
                            phi = <k_>1.61803</k_>;
                        }

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>c</t_> a = <k_>c::phi</k_>;      <c_>// Ok</c_>
                            <c_>//c b = 1.61803;   // Error, cannot convert from double to strict enum</c_>
                            <t_>int</t_> c = <k_>a</k_>;         <c_>// Ok, implicit conversion from c (double) to int</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#implicit-conversions">Implicit conversions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Structs                                                         -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="structs">Structs</h3>
            <p>
                <b>Structs</b> are used to <b>group</b> multiple <b>variables</b> of different types.<br>
                The members are declared in the same way as variables, and they can be of any type, including enums, arrays and other structures.<br>
                They cannot be <a href="#const-qualifier"><code><t_>const</t_></code></a> and cannot have initializer values.<br>
                Like variables, uninitialized members cannot be used within expressions. Struct values must also be fully initialized before they can be used in expressions.
            </p>
            <p>
                Empty structs are allowed.<br>
                Member access is explained in <a href="#special-operators">Special operators</a>.<br>
                Struct initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>
            <sep_></sep_>
            <syntax_>
                <left_>
                    <label_></label_>
                    <code_>
                        struct<space_></space_><elm_>name<sup>id</sup></elm_> {
                            <elm_>members<sup>...</sup></elm_>
                        }
                    </code_>
                </left_>
                <right_>
                    <label_>Member syntax</label_>
                    <code_>
                        <elm_><t_>U<sup>type</sup></t_></elm_><space_></space_><elm_>name<sup>id</sup></elm_>;


                    </code_>
                </right_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <w_>struct</w_> <t_>idk</t_> {
                            <t_>uint</t_> a, b;        <c_>// Ok</c_>
                            <t_>double</t_>[<k_>4</k_>] c;      <c_>// Ok</c_>
                            <c_>//double const d; // Error, struct members cannot be const</c_>
                        }
                        <t_>void</t_> <f_>main</f_>(){
                            <t_>idk</t_> var;

                            var.a = <k_>4</k_>;              <c_>// Ok, var = (4, ?, ?)</c_>
                            var.b = <k_>var.a</k_> * <k_>4</k_>;      <c_>// Ok, var = (4, 8, ?)</c_>
                            <c_>//var.b = var.c[0];     // Error, var.c is uninitialized</span>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#arrays">Arrays</a>,
                <a href="#enums">Enums</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Arrays                                                          -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="arrays">Arrays</h3>
            <p>
                <b>Arrays</b> can <b>aggregate values</b> of the same type.<br>
                Functions, parameters, right values, variables and struct member can all have array type.<br>
                Arrays can use any base type, including structs, enums and other arrays.<br>
                An array of arrays is called a multidimensional array. There is no limit to the number of dimensions an array can have.<br>
            </p>
            <p>
                Array declarations are identical to normal types, but <code>[</code><code>]</code> tokens follow the type, optionally enclosing an expression to specify the number of elements.<br>
                Arrays can be initialized using any expression of a type that can be implicitly converted.<br>
                If the <code>[</code><code>]</code> are left empty, the number of elements is determined by the inizializer value, which becomes required and must be an implicitly convertible list.
            </p>
            <p>
                There are no dynamic arrays.<br>
                Member access is explained in <a href="#special-operators">Special operators</a>.<br>
                Array initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>

            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        <elm_><t_>T</t_><sup>type</sup></elm_>[<elm_><t_>uint<sup>r</sup></t_></elm_>]<space_></space_><elm_>name<sup>id</sup></elm_>;
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>2</label_>
                    <code_>
                        <elm_><t_>T</t_><sup>type</sup></elm_>[] <elm_>name<sup>id</sup></elm_> = <elm_><t_>T[]<sup>r</sup></t_></elm_>;
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>uint</t_>[<k_>4</k_>] <f_>func</f_>(<t_>float</t_>[<k_>4</k_>] n){
                            <w_>if</w_>(n[<k_>3</k_>]) <w_>return</w_> n * <k_>4</k_>;
                            <w_>else</w_> <w_>return</w_> n[<k_>0</k_>];
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#enums">Enums</a>,
                <a href="#implicit-conversions">Implicit conversions</a>,
                <a href="#constructors">Constructors</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Implicit conversions                                            -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="implicit-conversions">Implicit conversions</h3>
            <p>
                <b>Implicit conversions</b> are performed when an <b>expression</b> of the <b>incorrect type</b> is used in place of the expected one.<br>
                This includes anything whose syntax requires an expression.<br>
                In function overloads and templates, the actual type of the value always takes precedence over conversions.
            </p>
            <p>
                Primitive types are all implicitly convertible between them.<br>
                The conversions follow these rules:
            </p>
            <div class="table-container"><table>
                <thead><tr>
                    <th>Expression type</th>
                    <th>Expected type</th>
                    <th>Behaviour</th>
                </tr></thead>
                <tbody>
                    <tr>
                        <td rowspan="3"><code><t_>uint</t_></code></td>
                        <td><code><t_>int</t_></code></td>
                        <td>Values over <code>limits::int::<k_>max</k_></code> overflow to <code>limits::int::<k_>min</k_> + <k_>n</k_> - <k_>1</k_></code></td>
                    </tr>
                    <tr>
                        <td><code><t_>float</t_></code><code><t_>double</t_></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t_>bool</t_></code></td>
                        <td><code><k_>1</k_></code> is evaluated as <code><k_>true</k_></code>, any other value as <code><k_>false</k_></code></td>
                    </tr>
                    <tr>
                        <td rowspan="3"><code><t_>int</t_></code></td>
                        <td><code><t_>uint</t_></code></td>
                        <td>Negative values underflow to <code>limits::uint::<k_>max</k_> + <k_>n</k_> + <k_>1</k_></code></td>
                    </tr>
                    <tr>
                        <td><code><t_>float</t_></code><code><t_>double</t_></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t_>bool</t_></code></td>
                        <td><code><k_></k_>1</code> is evaluated as <code><k_>true</k_></code>, any other value as <code><k_>false</k_></code></td>
                    </tr>
                    <tr>
                        <td rowspan="4"><code><t_>float</t_></code></td>
                        <td><code><t_>uint</t_></code></td>
                        <td>The decimal part is truncated. Negative values underflow to <code>limits::uint::<k_>max</k_> + <k_>n</k_> + <k_>1</k_></code>.<br>
                        If the value is not between <code>limits::uint::<k_>min</k_></code> and <code>limits::uint::<k_>max</k_></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t_>int</t_></code></td>
                        <td>The decimal part is truncated.<br>
                        If the value is not between <code>limits::int::<k_>min</k_></code> and <code>limits::int::<k_>max</k_></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t_>double</t_></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t_>bool</t_></code></td>
                        <td><code><k_>1.0</k_></code> is evaluated as <code><k_>true</k_></code>, any other value as <code><k_>false</k_></code></td>
                    </tr>
                    <tr>
                        <td rowspan="4"><code><t_>double</t_></code></td>
                        <td><code><t_>uint</t_></code></td>
                        <td>The decimal part is truncated. Negative values underflow to <code>limits::uint::<k_>max</k_> + <k_>n</k_> + <k_>1</k_></code>.<br>
                        If the value is not between <code>limits::uint::<k_>min</k_></code> and <code>limits::uint::<k_>max</k_></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t_>int</t_></code></td>
                        <td>The decimal part is truncated.<br>
                        If the value is not between <code>limits::int::<k_>min</k_></code> and <code>limits::int::<k_>max</k_></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t_>float</t_></code></td>
                        <td>The result is approximated using the maximum precision available</td>
                    </tr>
                    <tr>
                        <td><code><t_>bool</t_></code></td>
                        <td><code><k_>1.0</k_></code> is evaluated as <code><k_>true</k_></code>, any other value as <code><k_>false</k_></code></td>
                    </tr>
                    <tr>
                        <td rowspan="3"><code><t_>bool</t_></code></td>
                        <td><code><t_>uint</t_></code><code><t_>int</t_></code></td>
                        <td><code><k_>true</k_></code> is evaluated as <code><k_>1</k_></code>, <code><k_>false</k_></code> as <code><k_>0</k_></code></td>
                    </tr>
                    <tr>
                        <td><code><t_>float</t_></code><code><t_>double</t_></code></td>
                        <td><code><k_>true</k_></code> is evaluated as <code><k_>1.0</k_></code>, <code><k_>false</k_></code> as <code><k_>0.0</k_></code></td>
                    </tr>
                </tbody>
            </table></div>
            <p>
                Additional conversions between arrays and primitive types are described in the following table:
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Expression type  </th>
                    <th>Expected type    </th>
                    <th>Behaviour        </th>
                </tr>
                <td><code><t_>T</t_></code>   </td>
                <td><code><t_>U[n]</t_></code></td>
                <td>Each element of the result is initialized with the value of the starting expression, converted from <code><t_>T</t_></code> to <code><t_>U</t_></code></td>
                <tr>
                    <td><code><t_>T[n]</t_></code></td>
                    <td><code><t_>U[n]</t_></code></td>
                    <td>Each element of the result is initialized with the corresponding value of the starting array, converted from <code><t_>T</t_></code> to <code><t_>U</t_></code></td>
                </tr>
                <tr>
                    <td><code><t_>T[n]</t_></code></td>
                    <td><code><t_>bool</t_></code></td>
                    <td>Evaluated as <code><k_>true</k_></code> if all the elements of the initial array converted from <code><t_>T</t_></code> to <code><t_>bool</t_></code> evaluate as <code><k_>true</k_></code>, <code><k_>false</k_></code> otherwise</td>
                </tr>
            </table></div>
            <p>
                Values cannot be explicitly casted as in C. To convert a value, <a href="constructors">constructors</a> are used.<br>
                Attempting to convert incompatible types will result in a semantic error.<br>
                Structs are never convertible.
            </p>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>void</t_> <f_>fun</f_>(<t_>uint</t_> <a_>a</a_>[<k_>5</k_>]) {}
                        <t_>void</t_> <f_>fun2</f_>(<t_>bool</t_> <a_>a</a_>) {}

                        <t_>void</t_> <f_>main</f_>(){
                            <w_>struct</w_> { <t_>uint</t_> n; } var = (<k_>0</k_>);
                            <c_>//fun(var);                               // Error, structs cannot be converted</c_>
                            <c_>//fun(float[2](1.0, 4.4));                // Error, arrays have different lengths</c_>
                            <f_>fun</f_>(<k_>2</k_>);                                   <c_>// Ok, a = (2, 2, 2, 2, 2)</c_>
                            <f_>fun</f_>(<t_>float</t_>[<k_>5</k_>](<k_>1.0</k_>, <k_>4.4</k_>, <k_>5.5</k_>, <k_>-33</k_>, <k_>2.11</k_>));  <c_>// Ok, a = (1, 4, 5, 4294967263, 2)</c_>

                            <f_>fun2</f_>(<k_>2</k_>);                                  <c_>// Ok, a = true</c_>
                            <f_>fun2</f_>(<t_>float</t_>[<k_>5</k_>](<k_>1.0</k_>, <k_>4.4</k_>, <k_>5.5</k_>, <k_>-33</k_>, <k_>2.11</k_>)); <c_>// Ok, a = true</c_>
                            <f_>fun2</f_>(<t_>float</t_>[<k_>5</k_>](<k_>1.0</k_>, <k_>4.4</k_>, <k_>5.5</k_>, <k_>-33</k_>, <k_>0</k_>   )); <c_>// Ok, a = false</c_>

                            <t_>uint</t_> arr[<k_>1.2</k_>];                            <c_>// Ok, arr has 1 element</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#arrays">Arrays</a>,
                <a href="#constructors">Constructors</a>,
                <a href="#standard-modules">Standard modules</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Auto specifier                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="auto-specifier">Auto specifier</h3>
            <p>
                The <b><code><t_>auto</t_></code></b> specifier can be <b>used as</b> a <b>type</b> when declaring a variable or function.<br>
                The actual type of the symbol will be the same as the expression used to initialize it.<br>
            </p>
            <p>
                <code><t_>auto</t_></code> is not allowed in struct members declarations and function parameters.<br>
                The type of <code><t_>auto</t_></code> functions is determined by their return value.<br>
                There is no <code><t_>auto</t_></code> constructor.
            </p>
            <p>
                <code><t_>auto</t_></code> arrays and <code><t_>const</t_></code> <code><t_>auto</t_></code> symbols are allowed.
                //TODO auto functions that depend on an argument value
            </p>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <t_>auto</t_> <f_>func</f_>(){
                            <w_>return</w_> <k_>true</k_>;        <c_>// func has type bool</c_>
                        }

                        <t_>auto</t_> <f_>main</f_>(){
                            <t_>auto</t_> a = <k_>2</k_>;         <c_>// a has type uint</c_>
                            <t_>auto</t_> b = <k_>5.4</k_> * <k_>a</k_>;   <c_>// b has type float</c_>
                            <t_>auto</t_> c = <f_>func</f_>();    <c_>// c has type bool</c_>
                            <c_>// No return statement, main has type void</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <t_>auto</t_>[<k_>4</k_>] a = <k_>1</k_>;          <c_>// a has type int[4] and value (1, 1, 1, 1)</c_>
                        <t_>auto</t_>[<k_>2</k_>] <t_>const</t_> b = !<k_>a</k_>;   <c_>// b has type bool[4][2] and value ((0, 0, 0, 0), (0, 0, 0, 0))</c_>
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Typeof and baseof specifiers                                    -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="typeof-and-baseof-specifiers">Typeof and baseof specifiers</h3>
            <p>
                The <b><code><t_>typeof</t_></code></b> and <b><code><t_>baseof</t_></code></b> specifiers are used in the same way as <code><t_>auto</t_></code>, but the <b>type</b> is defined by the <b>expression</b> that is passed to them.<br>
                <code><t_>typeof</t_></code> returns the type of the expression, <code><t_>baseof</t_></code> returns it's base type.
            </p>
            <p>
                <code><t_>baseof</t_></code> can only be used on arrays, enums and primitive types.<br>
                The base type of primitive types is the type itself.<br>
                The expressions passed to those specifiers are always evaluated at compile time.
            </p>
            <p>
                The <code><t_>typeof</t_></code> and <code><t_>baseof</t_></code> specifiers can be used as constructors.<br>
                Circular dependencies are a semantic error.
                //TODO
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        typeof(<elm_><t_>T</t_><sup>r</sup></elm_>)
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        baseof(<elm_><t_>T</t_><sup>r</sup></elm_>)
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        //TODO
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Unnamed types                                                   -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h2 id="unnamed-types">Unnamed types</h2>
            <p>
                When a type doesn't have to be explicitly referenced more than once, <b>unnamed types</b> can be used to define both the type and the symbol in the same construct.<br>
                Similarly to the C syntax, the type name is not specified and the definition is used as type of the symbol.
            </p>
            <p>
                Any symbol defined inside those types can still be referenced through the <code><t_>typeof</t_></code> and <code><t_>auto</t_></code> specifiers.<br>
                Members of unnamed structs can be accessed using the member access operator, like normal structs.<br>
                Defining an unnamed type without also declaring the symbol is allowed, but it generates a warning as the type and anything declared in it would be unaccessible.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_> - Struct</label_>
                    <code_>
                        struct {
                            <elm_>members<sup>...</sup></elm_>
                        } <elm_>symbol name<sup>id</sup></elm_>;
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1 - Enum</label_>
                    <code_>
                        enum : <elm_><t_>T<sup>type</sup></t_></elm_> {
                            <elm_>elements<sup>...</sup></elm_>
                        } <elm_>symbol name<sup>id</sup></elm_>;
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>2 - Enum</label_>
                    <code_>
                        strict enum : <elm_><t_>T<sup>type</sup></t_></elm_> {
                            <elm_>elements<sup>...</sup></elm_>
                        } <elm_>symbol name<sup>id</sup></elm_>;
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <w_>strict enum</w_> : <t_>bool</t_> {
                            on = <k_>true</k_>;
                            off = <k_>false</k_>;
                        } grasses;

                        <t_>void</t_> <f_>main</f_>(){
                            this.grasses = <t_>typeof</t_>(grasses)::<k_>on</k_>;
                        }
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <w_>struct</w_> {
                            <t_>uint</t_> a, b;
                            <w_>enum</w_> : int {
                                idk1;
                                idk2;
                            } c;
                        } <f_>fun</f_>(){
                            <w_>return</w_> { <k_>1</k_>, <k_>1</k_>, <k_>0</k_> }; <c_>// Ok, unnamed struct constructor</c_>
                        }

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>auto</t_> var = fun();

                            <c_>// Both are allowed</c_>
                            var.c = <t_>typeof</t_>(var.c)::<k_>idk1</k_></span>;
                            var.c = <t_>typeof</t_>(<t_>typeof</t_>(<f_>fun</f_>)::c)::<k_>idk2</k_></span>;

                            <t_>typeof</t_>(var.a) a = <k_>0</k_>;
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#typeof-and-baseof-specifiers">Typeof and baseof specifiers</a>,
                <a href="#auto-specifier">Auto specifier</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Variables                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="variables">Variables</h2>
            <p>
                <b>Variables</b> are <b>named memory locations</b> that can contain values of the specified type.<br>
                Each variable <b>must be declared</b> before it is used. Variables <b>cannot be redeclared</b> and their <b>type cannot be changed</b> after the declaration.
            </p>
            <p>
                A variable declaration consists of the type, the name and an optional <code>=</code> followed by an expression of a compatible type that is used to inizialize it.<br>
                If an initializer expression is not specified, the value of the variable is undefined.<br>
                Evaluating an expression that can result in an undefined value is considered a logical error and will stop the compilation process.<br>
                Variables with undefined value can still be passed to reference arguments of functions or be assigned a value.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>1</label_>
                    <code_>
                        <elm_><t_>T<sup>type</sup></t_></elm_><space_></space_><elm_>name<sup>id</sup></elm_>;
                    </code_>
                </fill_>
            </syntax_>
            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_>2</label_>
                    <code_>
                        <elm_><t_>T<sup>type</sup></t_></elm_><space_></space_><elm_>name<sup>id</sup></elm_> = <elm_><t_>T<sup>r</sup></t_></elm_>;
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>uint</t_> variable = <k_>0</k_>;         <c_>// Ok, variable has value 0</c_>
                        <t_>float</t_> nya = <k_>5</k_> + <k_>variable</k_>;  <c_>// Ok, nya ha value 5.0</c_>
                        <t_>bool</t_> var$;                 <c_>// Ok, var$ has undefined value</c_>
                        <c_>//b var_2 = var$;          // Error. The syntax is correct, but undefined values (var$) cannot be used inside expressions</c_>

                        <c_>//double variable;         // Error, the identifier "variable" is already declared</c_>
                        <c_>//double foo               // Error, ';' is not optional</c_>
                        <c_>//b $var;                  // Error, invalid identifier</c_>
                        <c_>//b 2var;                  // Error, invalid identifier</c_>
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#expressions">Expressions</a>,
                <a href="#functions">Functions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Temporary variables                                             -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="temporary-variables">Temporary variables</h3>
            <p>
                <b>Temporary variables</b> are a special set of identifiers that have <b>dynamic type</b> and don't need to be declared.<br>
                These identifiers are meant to replace local variables whose only purpose is holding values that don't need to be used more than a few times.<br>
                A temporary variable is identified by the <code>$</code> character followed by an arbitrary number of decimal digits, which denote its name.<br>
            </p>
            <p>
                They are always <b>function-level scoped</b> and cannot be used outside of function definitions.<br>
                There is no limit to the number of temporary variables a function can use.<br>
            </p>
            <p>
                The type of a temporary variable can only be changed through direct assignments (<code>=</code>) and it must be unambiguously determinable in order for the variable to be evaulated.
                This means that reading the value of a temporary variable after one or more branches that may have assigned it different types is not allowed and will result in a semantic error.<br>
                Using temporary variables whose type is undefined will also result in a semantic error.
            </p>
            <p>They act as normal variables for anything else.</p>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">1</label_>
                    <code_>
                        <t_>uint3</t_> <f_>fun1</f_>(<t_>bool</t_> <a_>arg</a_>) {
                            $0 = <k_>1</k_>;             <c_>// Ok, $0 has type uint and value 1</c_>
                            <c_>//$2 = $1;          // Error, $1 has undefined type</c_>

                            <t_>uint3</t_> vec = { <k_>0</k_>, <k_>1</k_>, <k_>2</k_> };
                            $2 = <k_>true</k_>;          <c_>// Ok, $2 has type b and value true</c_>
                            $2 = <k_>vec</k_>;           <c_>// Ok, $2 has type uint3 and value { 0, 1, 2 }</c_>
                        }

                        <t_>void</t_> <f_>fun2</f_>(<t_>uint3</t_> <a_>vec</a_>) {
                            <c_>//uint var = $2;    // Error, $2 has undefined type. fun2::$2 has nothing to do with fun1::$2</c_>
                        }

                        <c_>//uint var = $9;        // Error, temporary variables cannot be used outside of functions</c_>
                    </code_>
                </fill_>
            </example_>
            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)">2</label_>
                    <code_>
                        <t_>void</t_> <f_>fun3</f_>(<t_>bool</t_> <a_>arg</a_>, <t_>uint2</t_> &<a_>ref</a_>) {
                            <w_>if</w_>(arg) $0 = <k_>1</k_>;             <c_>// $0 has type uint</c_>
                            <w_>else</w_>    $0 = { <k_>0</k_>, <k_>1</k_> };      <c_>// $0 has type uint2</c_>
                            <c_>//ref = $0;                 // Error, cannot determine the type of $0</c_>
                            $0 = ref;                   <c_>// Ok, $0 has type uint2 and the same value as ref</c_>

                            <w_>if</w_>(arg) $0 = { <k_>0</k_>, <k_>1</k_> };      <c_>// $0 has type uint2</c_>
                            <w_>else</w_>    $0 = { <k_>2</k_>, <k_>3</k_> };      <c_>// $0 has type uint2</c_>
                            ref = <k_>$0</k_>;                   <c_>// Ok, $0 has type uint2</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#selection">Selection</a>,
                <a href="#functions">Functions</a>,
                <a href="#expressions">Expressions</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Functions                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="functions">Functions</h2>
            <p>
                <b>Functions</b> are the <b>main component</b> of the language. They contain the statements that will be executed during run time and manage inputs and outputs of the shader.<br>
                A function definition consists of its type and name followed by a list of arguments and its statements enclosed in <code>{</code><code>}</code> delimiters.
            </p>
            <p>
                A function can take an arbitrary number of parameters of any type. Paramters are declared like variables and behave in the same exact way.<br>
                The expressions used to call the function are called arguments.<br>
                Each argument must be implicitly convertible to the type of the parameter.<br>
                Functions are allowed to take no arguments.
            </p>
            <p>
                The <b><code><f_>main</f_></code> function</b> is where the <b>code execution starts and ends</b>.<br>
                Every shader <b>must define</b> the <b>main</b> as a void function. As such, it cannot return values.<br>
            </p>

            <sep_></sep_>
            <syntax_>
                <left_>
                    <label_></label_>
                    <code_>
                        <elm_><t_>T<sup>type</sup></t_></elm_><space_></space_><elm_>name<sup>id</sup></elm_>(<elm_>arguments<sup>...</sup></elm_>) {<elm_>...</elm_>}
                    </code_>
                </left_>
                <right_>
                    <label_>Parameter syntax</label_>
                    <code_>
                        <elm_><t_>U<sup>type</sup></t_></elm_><space_></space_><elm_>name<sup>id</sup></elm_>
                    </code_>
                </right_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>void</t_> <f_>func1</f_>() {}

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>int</t_> n = <k_>0</k_>;
                            <c_>// ...</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#runtime-statements">Runtime statements</a>,
                <a href="#types">Types</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Parameters and references                                       -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="parameters-and-references">Parameters and references</h3>
            <p>
                By <b>default</b>, the arguments are passed <b>by value</b>, which means that when the function is called, the value of each argument is <b>copied</b> in the corresponding parameter and the function <b>cannot access</b> the original variable.<br>
                If a parameter name is preceeded by a <b><code>&</code></b> token, instead, the argument is passed <b>by reference</b>, allowing the function to <b>access and modify</b> its value
            </p>
            <p>
                Declaring a reference parameter as const is a syntax error and passing an r-value as argument of a reference parameter is a semantic error.<br>
                Notice that in this case, the <code>&</code> token is not part of the type nor part of the name, but a language feature that is used exclusively within parameter declarations.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_ class="nobefore">Parameter syntax</label_>
                    <code_>
                        <elm_><t_>U<sup>type</sup></t_></elm_><space_></space_>&<elm_>name<sup>id</sup></elm_>
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>void</t_> <f_>fun1</f_>(<t_>uint</t_> <a_>arg1</a_>, <t_>uint</t_> &<a_>arg2</a_>) {
                            arg1 = <k_>0</k_>;     <c_>// c_doesn't modify main::a, but the local argument in which its value was copied</span>
                            arg2 = <k_>0</k_>;     <c_>// c_modifies main::b</span>
                        }

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>uint</t_> a, b;
                            <f_>fun1</f_>(a, b);   <c_>// a keeps an undefined value, b is set to 0</c_>
                            <c_>//fun1(a, 5); // Error, cannot pass literals to reference parameters</c_>
                        }

                        <c_>//void fun2(const int &arg1){} // Error, references cannot be const</c_>
                    </code_>
                </fill_>
            </example_>

            <p>
                See
                <a href="#const-qualifier">Const qualifier</a>,
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Return statement                                                -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="return-statement">Return statement</h3>
            <p>
                The type of the function defines the type of the value that is returned by the function when called.<br>
                <b>Values</b> are <b>returned</b> using the <b><code><k_>return</k_></code></b> statement. When this happens, all the remaining statements in the function are skipped and the code execution returns to the caller function.<br>
                Functions that <b>don't return</b> a value must be defined using the <b><code><t_>void</t_></code> type</b>.<br>
                Void functions are allowed to contain no statements. Non-void functions must always return a value.
            </p>

            <sep_></sep_>
            <syntax_>
                <fill_>
                    <label_></label_>
                    <code_>
                        return<space_></space_><elm_><t_>T<sup>r</sup></t_></elm_>;
                    </code_>
                </fill_>
            </syntax_>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <t_>void</t_> <f_>empty_function_1</f_>() { <w_>return</w_>; }    <c_>// Ok</c_>
                        <t_>void</t_> <f_>empty_function_2</f_>() {}             <c_>// Ok</c_>

                        <t_>uint</t_> <f_>empty_function_3</f_>() { <w_>return</w_> <k_>0</k_>; }  <c_>// Ok</c_>
                        <c_>//uint empty_function_4() {}           // Error, non-void functions must return a value</c_>

                        <t_>uint</t_> <f_>f</f_>(<t_>uint</t_> <a_>n</a_>) { <w_>return</w_> n * <k_>2</k_>; }       <c_>// Ok</c_>
                        <c_>//void f() { }                         // Error, f is already defined</c_>

                        <t_>void</t_> <f_>main</f_>(){
                            <t_>uint</t_> n = <f_>empty_function_3</f_>();       <c_>// Ok</c_>
                            n = <f_>f</f_>(<f_>f</f_>(<k_>n</k_>));                       <c_>// Ok</c_>
                        }
                    </code_>
                </fill_>
            </example_>


            <!--------------------------------------------------------------------->
            <!-- Function calls                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="function-calls">Function calls</h3>


            <!--------------------------------------------------------------------->
            <!-- Template functions                                              -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="template-functions">Template functions</h3>


            <!--------------------------------------------------------------------->
            <!-- Type groups                                                     -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="type-groups">Type groups</h3>




            <!--------------------------------------------------------------------->
            <!-- Const qualifier                                                 -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="const-qualifier">Const qualifier</h2>
            <p>
                The <code><t_>const</t_></code> qualifier can be used to <b>prevent</b> named values to be <b>modified</b> after their declaration.<br>
                Reference const parameters are not allowed, as well as const functions and const struct members.<br>
            </p>
            <p>
                As opposed to C and GLSL, const identifiers can be initialized using non-const expressions.<br>
                The qualifier doesn't affect compiler optimizations or the GLSL output in any way.
            </p>
            <p>
                Passing a const identifier as argument of reference parameters is not allowed and will result in a semantic error.<br>
                Const variables cannot have undefined value.
            </p>

            <sep_></sep_>
            <example_>
                <fill_>
                    <label_ onclick="copy_code(this)"></label_>
                    <code_>
                        <w_>struct</w_> <t_>s</t_> {
                            <t_>uint</t_> a;            <c_>// Ok, non-const member</c_>
                            <c_>//uint const b;    // Error, struct members cannot be const</c_>
                        }
                        <t_>s const</t_> var;           <c_>// Ok, const global variable</c_>

                        <c_>//double const fun(){}              // Error, functions cannot be const</c_>
                        <c_>//double fun(double const &arg){}   // Error, references cannot be const</c_>

                        <t_>double</t_> <f_>fun</f_>(<t_>double </t_> arg) {           <c_>// Ok, const parameter</c_>
                            <c_>//uint a;                       // Error, uninitialized const</c_>
                            <t_>u64</t_> a = 4;                      <c_>// Ok</c_>
                            <t_>u64</t_> b = arg, c;                 <c_>// Ok</c_>
                            <c_>//a = 2;                        // Error, cannot assign values to const variables</c_>
                            c = <k_>a</k_> + b;                      <c_>// Ok</c_>
                        }
                    </code_>
                </fill_>
            </example_>
            <p>
                See
                <a href="#compiler-optimizations">Compiler optimizations</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Symbol aliases                                                  -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="symbol-aliases">Symbol aliases</h2>








            <!--------------------------------------------------------------------->
            <!-- Runtime statements                                              -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="runtime-statements">Runtime statements</h1>



            <!--------------------------------------------------------------------->
            <!-- Left and right values                                           -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="left-and-right-values">Left and right values</h2>



            <!--------------------------------------------------------------------->
            <!-- Expressions                                                     -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="expressions">Expressions</h2>

            <!--------------------------------------------------------------------->
            <!-- Literals                                                        -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="literals">Literals</h3>

            <!--------------------------------------------------------------------->
            <!-- Constructors                                                    -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="constructors">Constructors</h3>
            <p>CONSTRUCTORS ARE SPECIAL FUNCTIONS //TODO</p>

            <!--------------------------------------------------------------------->
            <!-- Operators                                                       -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="operators">Operators</h3>

            <!--------------------------------------------------------------------->
            <!-- Special operators                                               -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="special-operators">Special operators</h3>

            <!--------------------------------------------------------------------->
            <!-- Array operations                                                -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="array-operations">Array operations</h3>



            <!--------------------------------------------------------------------->
            <!-- Assignments                                                     -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="assignments">Assignments</h2>

            <!--------------------------------------------------------------------->
            <!-- Composite assignments                                           -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="composite-assignments">Composite assignments</h3>

            <!--------------------------------------------------------------------->
            <!-- Multiple assignments                                            -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="multiple-assignments">Multiple assignments</h3>



            <!--------------------------------------------------------------------->
            <!-- Selection                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="selection">Selection</h2>

            <!--------------------------------------------------------------------->
            <!-- If statement                                                    -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="if-statement">If statement</h3>

            <!--------------------------------------------------------------------->
            <!-- Select statement                                                -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="select-statement">Select statement</h3>



            <!--------------------------------------------------------------------->
            <!-- Iteration                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="iteration">Iteration</h2>

            <!--------------------------------------------------------------------->
            <!-- For loops                                                       -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="for-loops">For loops</h3>

            <!--------------------------------------------------------------------->
            <!-- While loops                                                     -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="while-loops">While loops</h3>

            <!--------------------------------------------------------------------->
            <!-- Continue and break statements                                   -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="continue-and-break-statements">Continue and break statements</h3>

            <!--------------------------------------------------------------------->
            <!-- Once statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="once-statement">Once statement</h3>

            <!--------------------------------------------------------------------->
            <!-- Then statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3_></sep-3_>
            <h3 id="then-statement">Then statement</h3>



            <!--------------------------------------------------------------------->
            <!-- Else statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="else-statement">Else statement</h2>







            <!--------------------------------------------------------------------->
            <!-- Compilation                                                     -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="compilation">Compilation</h1>



            <!--------------------------------------------------------------------->
            <!-- Modules                                                         -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="modules">Modules</h2>



            <!--------------------------------------------------------------------->
            <!-- Compilation phases and error types                              -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="compilation-phases-and-error-types">Compilation phases and error types</h2>



            <!--------------------------------------------------------------------->
            <!-- Global initialization order                                     -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="global-initialization-order">Global initialization order</h2>



            <!--------------------------------------------------------------------->
            <!-- Branching performance                                           -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="branching-performance">Branching performance</h2>



            <!--------------------------------------------------------------------->
            <!-- Compiler optimizations                                          -->
            <!--------------------------------------------------------------------->
            <sep-2_></sep-2_>
            <h2 id="compiler-optimizations">Compiler optimizations</h2>







            <!--------------------------------------------------------------------->
            <!-- Standard modules                                                -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="standard-modules">Standard modules</h1>







            <!--------------------------------------------------------------------->
            <!-- Quick reference tabs                                            -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="quick-reference-tabs">Quick reference tabs</h1>

            //TODO
            //this.x this.y this.z
            this::pos.x
            this::pos.y
            this::pos.z
            ^ coordinates in current workspace




            sequence function //TODO
            sequence(start, end, step)







            <div class="table-container"><table>
                <thead><tr>
                    <th class="center">Precedence</th>
                    <th class="center">Operator</th>
                    <th class="center">Syntax</th>
                    <th class="center">Result</th>
                    <th class="left">Name</th>
                    <th class="left">Category</th>
                </tr></thead>
                <tbody>
                    <tr>
                        <td class="center" >1</td>
                        <td class="center">
                            <elm_><code>(</code><code>)</code></elm_>
                        </td>
                        <td class="center">(<elm_><t_>T<sup>r</sup></t_></elm_>)</td>
                        <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                        <td class="left">Grouping</td>
                        <td class="left" rowspan=5>Other</td>
                    </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=6>2</td>
                            <td class="center" rowspan=2>
                                <span class="op_template">-</span><br>
                                <elm_><code>[</code><code>]</code></elm_><br>
                                <span class="op_template">with(T == struct_t)</span><br>
                            </td>
                            <td class="center"><elm_><t_>T[]</t_><sup>r</sup></elm_>[<elm_><t_>uint</t_><sup>r</sup></elm_>]</td>
                            <td class="center"><code><t_>T<sup>l</sup></t_></code></td>
                            <td class="left" rowspan=2>Subscription</td>
                        </tr>
                        <tr>
                            <td class="center"><elm_><t_>T</t_><sup>r</sup></elm_>[<elm_><t_>uint</t_><sup>r</sup></elm_>]</td>
                            <td class="center"><code><t_>member type<sup>l</sup></t_></code></td>
                        </tr>
                        <tr>
                            <td class="center" rowspan=2>
                                <span class="op_template">-</span><br>
                                <code>.</code><br>
                                <span class="op_template">with(T == struct_t)</span><br>
                            </td>
                            <td class="center"><elm_><t_>T[]<sup>r</sup></t_></elm_>.<elm_>member<sup>id</sup></elm_></td>
                            <td class="center"><code><t_>T<sup>l</sup></t_></code></td>
                            <td class="left" rowspan=2>Member access</td>
                        </tr>
                        <tr>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_>.<elm_>member<sup>id</sup></elm_></td>
                            <td class="center"><code><t_>member type<sup>l</sup></t_></code></td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>++</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_>++</td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Postfix increment</td>
                            <td class="left" rowspan=6>Arithmetic</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>--</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_>--</td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Postfix decrement</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=6>3</td>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>++</code>
                            </td>
                            <td class="center">++<elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Prefix increment</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>--</code>
                            </td>
                            <td class="center">--<elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Prefix decrement</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>+</code>
                            </td>
                            <td class="center">+<elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Promotion</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>-</code>
                            </td>
                            <td class="center">-<elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Inversion</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T == int_t)</span><br>
                                <code>~</code>
                            </td>
                            <td class="center">~<elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Bitwise NOT</td>
                            <td class="left">Binary</td>
                        </tr>
                        <tr>
                            <td class="center"><code>!</code></td>
                            <td class="center">!<elm_><t_>bool<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Logical NOT</td>
                            <td class="left">Logical</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=3>4</td>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>*</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &#42; <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Multiplication</td>
                            <td class="left" rowspan=5>Arithmetic</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>/</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> / <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Division</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>%</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> % <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Modulo</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=2>5</td>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>+</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> + <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Addition</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>-</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> - <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Subtraction</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=2>6</td>
                            <td class="center">
                                <span class="op_template">with(T == int_t)</span><br>
                                <code>&lt;&lt;</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &lt;&lt; <elm_><t_>uint<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><codet_>T<sup>r</sup></codet_></code></td>
                            <td class="left">Left bit shift</td>
                            <td class="left" rowspan=2>Binary</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T == int_t)</span><br>
                                <code>&gt;&gt;</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &gt;&gt; <elm_><t_>uint<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                            <td class="left">Right bit shift</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=4>7</td>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>&lt;</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &lt; <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Less than</td>
                            <td class="left" rowspan=8>Comparison</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>&lt;=</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &lt;= <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Less or equal than</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>&gt;</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &gt; <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Greater than</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>&gt;=</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> &gt;= <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Greater or equal than</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=4>8</td>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>==</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> == <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Equality</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <span class="op_template">with(T != struct_t)</span><br>
                                <code>!=</code>
                            </td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> != <elm_><t_>T<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Inequality</td>
                        </tr>
                        <tr>
                            <td class="center"><code>=:</code></td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> =: <elm_><t_>T[]<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Existence</td>
                        </tr>
                        <tr>
                            <td class="center"><code>!:</code></td>
                            <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> !: <elm_><t_>T[]<sup>r</sup></t_></elm_></td>
                            <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                            <td class="left">Inexistence</td>
                        </tr>
                    <tr>
                        <td class="center">9</td>
                        <td class="center">
                            <span class="op_template">with(T != int_t)</span><br>
                            <code>&</code>
                        </td>
                        <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> & <elm_><t_>T<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                        <td class="left">Bitwise AND</td>
                        <td class="left" rowspan=3>Binary</td>
                    </tr>
                    <tr>
                        <td class="center">10</td>
                        <td class="center">
                            <span class="op_template">with(T != int_t)</span><br>
                            <code>^</code>
                        </td>
                        <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> ^ <elm_><t_>T<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                        <td class="left">Bitwise XOR</td>
                    </tr>
                    <tr>
                        <td class="center">11</td>
                        <td class="center">
                            <span class="op_template">with(T != int_t)</span><br>
                            <code>|</code>
                        </td>
                        <td class="center"><elm_><t_>T<sup>r</sup></t_></elm_> | <elm_><t_>T<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                        <td class="left">Bitwise OR</td>
                    </tr>
                    <tr>
                        <td class="center">12</td>
                        <td class="center"><code>&&</code></td>
                        <td class="center"><elm_><t_>bool<sup>r</sup></t_></elm_> && <elm_><t_>bool<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                        <td class="left">Logical AND</td>
                        <td class="left" rowspan=3>Logical</td>
                    </tr>
                    <tr>
                        <td class="center">13</td>
                        <td class="center"><code>^^</code></td>
                        <td class="center"><elm_><t_>bool<sup>r</sup></t_></elm_> ^^ <elm_><t_>bool<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                        <td class="left">Logical XOR</td>
                    </tr>
                    <tr>
                        <td class="center">14</td>
                        <td class="center"><code>||</code></td>
                        <td class="center"><elm_><t_>bool<sup>r</sup></t_></elm_> || <elm_><t_>bool<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>bool<sup>r</sup></t_></code></td>
                        <td class="left">Logical OR</td>
                    </tr>
                    <tr>
                        <td class="center">15</td>
                        <td class="center"><elm_><code>?</code><code>:</code></elm_></td>
                        <td class="center"><elm_><t_>bool<sup>r</sup></t_></elm_> ? <elm_><t_>T<sup>r</sup></t_></elm_> : <elm_><t_>T<sup>r</sup></t_></elm_></td>
                        <td class="center"><code><t_>T<sup>r</sup></t_></code></td>
                        <td class="left">Selection operator</td>
                        <td class="left">Other</td>
                    </tr>
                </tbody>
            </table></div>

            Operators cannot be used as value. Only their members can

            //TODO add with keyword

            //TODO add typographical conventions
            //TODO <sup>r</sup> = rvalue
            //TODO <sup>l</sup> = lvalue
            //TODO <sup>id</sup> = identifier






            <!--------------------------------------------------------------------->
            <!-- Complete examples                                               -->
            <!--------------------------------------------------------------------->
            <sep-1_></sep-1_>
            <h1 id="complete-examples">Complete examples</h1>

        </div>
    </div>
</div>
</body>
</html>



<!--
<p>
    Array <b>elements</b> are referenced through their <b>index</b>.<br>
    Negative values are not supported.
</p>
<p>
    One-dimensional arrays with a <b>maximum of 4 elements</b> can use special <b>named identifiers</b> to refer to them.<br>
    Referencing elements of multidimensional arrays require two or more indices.<br>
    Referencing elements that are <b>not</b> in the <b>array range</b> has <b>undefined behaviour</b>.
</p>
| Element | Named identifier 1 | Named identifier 2 |
|:-------:|:------------------:|:------------------:|
| <code>[0]</code>   | <code>x</code>                | <code>r</code>                |
| <code>[1]</code>   | <code>y</code>                | <code>g</code>                |
| <code>[2]</code>   | <code>z</code>                | <code>b</code>                |
| <code>[3]</code>   | <code>w</code>                | <code>a</code>                |
<p>
    //TODO MOVE VALUE LISTS TO #multiple-assignments
    Both named identifiers and indices can be listed to reference multiple elements at once.<br>
    Referencing the same element more than once in a left value is a semantic error. If it happens during runtime, it has undefined behaviour.
</p>

<h5>Syntax</h5>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]</pre>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]<span class="syntax-elm">...</span></pre>
<pre><span class="syntax-elm">symbol identifier</span>.<span class="syntax-elm">named identifier</span><span class="syntax-elm">...</span></pre>

<h5>Example</h5>
```c
void main() { //TODO multidimensional arrays
    uint arr1[5];
    arr1[3] = 0;                // Ok, arr1 = (?, ?, ?, 0, ?)
    //arr1[5] = 0;              // Undefined behaviour, index 5 is out of range
    //arr1.a = 0;               // Error, arrays with more than 5 elements don't have named identifiers

    //uint arr2[] = arr1[0, 1, 2, 3];    // Error, some of these elements are not initialized
    arr1[0, 1, 4] = 2;                  // Ok, arr1 =(2, 2, ?, 0, 2)
    uint arr2[] = arr1[0, 1, 4, 3];      // Ok, arr2 = (2, 2, 2, 0)

    uint arr2.b = 9;                     // Ok, arr2 = (2, 2, 9, 0)
    arr2.xyz = arr2.zrz;                // Ok, arr1 = (0, 2, 0, 0)
    arr2.wyrb *= 3;                     // Ok, arr1 = (0, 6, 0, 0)
    //arr2.xyz = arr2.zrga;             // Error, the arrays have different length
    //arr2.yy = arr2.xx;                // Error, element [0] referenced twice in left value
    //arr2.yy = arr2.xa;                // Error, element [0] referenced twice in left value
}
```




<p>Althought the file extension is only a convention and can be changed or omitted, it is still recommended to use the correct one, as some softwares may use it to determine the language of the source file.</p>


//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE