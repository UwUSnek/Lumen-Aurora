<!DOCTYPE html>
<html>
<head>
    <title>The Lux shading language</title>
    <meta charset="UTF-8">
    <meta name="author" content="Snek" />
    <meta name="description" content="Lux language specification" />
    <link rel="icon" href="Lux-logo.png" type="image/icon type">

    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />
    <link rel="stylesheet" type="text/css" href="Style.css" media="screen">
    <script src="CopyCode.js"></script>

    <style>
        .table-1-container {
            white-space: nowrap;
            padding: 0;
            margin: 0;
            min-width: 100%;
            border-radius: 10px 0 0 0;
            overflow: hidden;
            word-spacing: -100vw;
            text-align: center;
        }.table-1-right-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: calc(100% - 24ch);
        }.table-1-right {
            border-radius: 0 10px 10px 0;
            word-spacing: var(--word-spacing);
        }.table-1-left-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: 24ch;
            border-bottom-left-radius: 10px;
        }.table-1-left {
            border-radius: 10px 0 0 10px;
            word-spacing: var(--word-spacing);
        }.table-1-y {
            background-color: #0a7a003a;
        }.table-1-n {
            background-color: #7a00003a;
        }
    </style>
</head>
<body onresize="_onresize()">

    <!----------------------------------------------------------------------------------------------------------->
    <!-- Cursed hack to use an invisible slider to resize the main containers and have it float between them   -->
    <!-- so that it looks like the user is resizing the containers through an actual full height resize handle -->
    <!----------------------------------------------------------------------------------------------------------->

    <!-- Calculate the minimum value of the slider -->
    <div style="
        position: fixed; max-width: none;
        min-width: calc(var(--main-left-padding) * 2 - var(--slider-size));
        width: calc(var(--main-left-padding) * 2 - var(--slider-size));
        ", id="slider-start----">
    </div>

    <!-- Calculate the maximum value of the slider -->
    <div style="
        position: fixed; max-width: none;
        min-width: calc(var(--main-padding) * 2 + var(--slider-size) * 2);
        width: calc(var(--main-padding) * 2 + var(--slider-size) * 2);
        ", id="slider-end----">
    </div>

    <!-- Calculate the workspace width in pixels -->
    <div style="width: 100vw", id="slider-max----"></div>

    <!-- Slider object -->
    <input type="range" min="0" max="99999999" value="0" step="0.00001" class="slider" id="main-slider">


    <script>
        // Save slider element
        var slider = document.getElementById("main-slider");


        // Updates the maximum and minimum values of the slider. Used in browser zoom and window resize
        function update_range(){
            var min = document.getElementById("slider-start----").clientWidth;
            var max = document.getElementById("slider-max----"  ).clientWidth - document.getElementById("slider-end----").clientWidth;
            slider.min = min;
            slider.max = max;
        }




        function getBackgroundSize(elem) {
    // This:
    //       * Gets elem computed styles:
    //             - CSS background-size
    //             - element's width and height
    //       * Extracts background URL
    var computedStyle = getComputedStyle(elem),
        image = new Image(),
        src = computedStyle.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2'),
        cssSize = computedStyle.backgroundSize,
        elemW = parseInt(computedStyle.width.replace('px', ''), 10),
        elemH = parseInt(computedStyle.height.replace('px', ''), 10),
        elemDim = [elemW, elemH],
        computedDim = [],
        ratio;
    // Load the image with the extracted URL.
    // Should be in cache already.
    image.src = src;
    // Determine the 'ratio'
    ratio = image.width > image.height ? image.width / image.height : image.height / image.width;
    // Split background-size properties into array
    cssSize = cssSize.split(' ');
    // First property is width. It is always set to something.
    computedDim[0] = cssSize[0];
    // If height not set, set it to auto
    computedDim[1] = cssSize.length > 1 ? cssSize[1] : 'auto';
    if(cssSize[0] === 'cover') {
        // Width is greater than height
        if(elemDim[0] > elemDim[1]) {
            // Elem's ratio greater than or equal to img ratio
            if(elemDim[0] / elemDim[1] >= ratio) {
                computedDim[0] = elemDim[0];
                computedDim[1] = 'auto';
            } else {
                computedDim[0] = 'auto';
                computedDim[1] = elemDim[1];
            }
        } else {
            computedDim[0] = 'auto';
            computedDim[1] = elemDim[1];
        }
    } else if(cssSize[0] === 'contain') {
        // Width is less than height
        if(elemDim[0] < elemDim[1]) {
            computedDim[0] = elemDim[0];
            computedDim[1] = 'auto';
        } else {
            // elem's ratio is greater than or equal to img ratio
            if(elemDim[0] / elemDim[1] >= ratio) {
                computedDim[0] = 'auto';
                computedDim[1] = elemDim[1];
            } else {
                computedDim[1] = 'auto';
                computedDim[0] = elemDim[0];
            }
        }
    } else {
        // If not 'cover' or 'contain', loop through the values
        for(var i = cssSize.length; i--;) {
            // Check if values are in pixels or in percentage
            if (cssSize[i].indexOf('px') > -1) {
                // If in pixels, just remove the 'px' to get the value
                computedDim[i] = cssSize[i].replace('px', '');
            } else if (cssSize[i].indexOf('%') > -1) {
                // If percentage, get percentage of elem's dimension
                // and assign it to the computed dimension
                computedDim[i] = elemDim[i] * (cssSize[i].replace('%', '') / 100);
            }
        }
    }
    // If both values are set to auto, return image's
    // original width and height
    if(computedDim[0] === 'auto' && computedDim[1] === 'auto') {
        computedDim[0] = image.width;
        computedDim[1] = image.height;
    } else {
        // Depending on whether width or height is auto,
        // calculate the value in pixels of auto.
        // ratio in here is just getting proportions.
        ratio = computedDim[0] === 'auto' ? image.height / computedDim[1] : image.width / computedDim[0];
        computedDim[0] = computedDim[0] === 'auto' ? image.width / ratio : computedDim[0];
        computedDim[1] = computedDim[1] === 'auto' ? image.height / ratio : computedDim[1];
    }
    // Finally, return an object with the width and height of the
    // background image.
    return {
        width: computedDim[0],
        height: computedDim[1]
    };
}




        // Updates the logo- and logo-top- width
        function update_logo_width(value){
            document.getElementsByTagName("LOGO-TOP-")[0].style.maxWidth = "calc(" +
                "100% - " + value + "px - var(--slider-size) - " + window.getComputedStyle(document.documentElement).getPropertyValue("--slider-size") +
            ")";
            var logo = document.getElementsByTagName("LOGO-")[0];
            logo.style.backgroundPositionX = "calc(" +
                "calc(" +
                    "calc(100vw - var(--main-padding)) / 2 + " +
                    "calc(" + value + "px + var(--main-padding) + var(--main-left-padding)) / 2" +
                ") - " +
                "calc(" +
                    getBackgroundSize(logo).width + "px / " +
                    "2" +
                ")" +
            ")";
        }

        // Updates the width of the left and right main containers
        function update_main_width(){
            document.getElementById("main-left").style.maxWidth  = "calc(" +
                slider.value +  "px - " +
                "var(--main-left-padding) + " +
                "var(--slider-size)" +
            ")";
            document.getElementById("main-right").style.maxWidth = "calc(" +
                "100% - " + slider.value + "px - " +
                "var(--main-left-padding) - " +
                "var(--main-padding) * 2" +
            ")";
            update_logo_width(slider.value);
            window.localStorage.setItem("slider-value", slider.value);
        }

        // Update on browser zoom and window resize
        function _onresize() {
            update_range();
            update_main_width();
        }


        function init_slider_first_time(){
            window.localStorage.setItem("slider-set", "set");
            var min = document.getElementById("slider-start----").clientWidth;
            var max = document.getElementById("slider-max----"  ).clientWidth - document.getElementById("slider-end----").clientWidth;
            window.localStorage.setItem("slider-value", (min + max) / 2);
        }
        // Set slider value after page refresh and initialize it if needed
        function init_slider(){
            if(window.localStorage.getItem("slider-set") != "set") {
                init_slider_first_time();
            }
            slider.oninput = function() { update_main_width(); }
            slider.value = window.localStorage.getItem("slider-value");
            console.log("initialized");
        }
    </script>




    <!--------------------------------------------------------------------->
    <!-- Index                                                           -->
    <!--------------------------------------------------------------------->
    <left- class="hide-scrollbar" id="main-left">
        <index- class="hide-scrollbar"><indexh-></indexh->
            <indexd->Overview</indexd->
            <index-><indexh->Preprocessor</indexh->
                <indexd->Comments</indexd->
                <indexd->Include statement</indexd->
                <indexd->Macros</indexd->
                <indexd->Conditionals</indexd->
                <indexd->Line continuation token</indexd->
            </index->

            <index-><indexh->Language components</indexh->
                <indexd->Tokens and identifiers</indexd->
                <indexd->Scopes and symbols</indexd->
                <indexd->Namespaces</indexd->
                <index-><indexh->Types</indexh->
                    <indexd->Primitive types</indexd->
                    <indexd->Enums</indexd->
                    <indexd->Structs</indexd->
                    <indexd->Arrays</indexd->
                    <indexd->Tuples</indexd->
                    <indexd->Implicit conversions</indexd->
                    <indexd->Auto specifier</indexd->
                    <indexd->Typeof and baseof specifiers</indexd->
                    <indexd->Unnamed types</indexd->
                </index->
                <index-><indexh->Variables</indexh->
                    <indexd->Temporary variables</indexd->
                </index->
                <index-><indexh->Functions</indexh->
                    <indexd->Reference parameters</indexd->
                    <indexd->Return statement and function calls</indexd->
                    <indexd->Template functions</indexd->
                    <indexd->The main function</indexd->
                </index->
                <indexd->Const qualifier</indexd->
                <indexd->Symbol aliases</indexd->
            </index->
            <index-><indexh->Runtime statements</indexh->
                <indexd->Left and right values</indexd->
                <index-><indexh->Expressions</indexh->
                    <indexd->Literals</indexd->
                    <indexd->Constructors</indexd->
                    <indexd->Operators</indexd->
                    <indexd->Special operators</indexd->
                    <indexd->Array operations</indexd->
                    <indexd->Type comparison</indexd->
                </index->
                <index-><indexd->Selection</indexd->
                        <indexd->If statement</indexd->
                        <indexd->Select statement</indexd->
                </index->
                <index-><indexh->Iteration</indexh->
                    <indexd->For loops</indexd->
                    <indexd->While loops</indexd->
                    <indexd->Continue and break statements</indexd->
                    <indexd->Once statement</indexd->
                    <indexd->Then statement</indexd->
                </index->
                <indexd->Else statement</indexd->
            </index->
            <index-><indexh->Compilation</indexh->
                <indexd->Modules</indexd->
                <indexd->Compilation phases and error types</indexd->
                <indexd->Global initialization order</indexd->
                <indexd->Branching performance</indexd->
                <indexd->Compiler optimizations</indexd->
            </index->
            <index-><indexh->Standard modules</indexh->
                <indexd->idk</indexd->
            </index->
            <indexd->Quick reference tabs</indexd->
            <indexd->Complete examples</indexd->
        <indexh-></indexh-></index->
    </left->

    <right- class="hide-scrollbar" id="main-right">
        <!--------------------------------------------------------------------->
        <!-- Logo                                                            -->
        <!--------------------------------------------------------------------->
        <logo-top-></logo-top->
        <logo- style="background-image: url('Lux-logo.png');"></logo->

        <main-scroll->
            <!--------------------------------------------------------------------->
            <!-- Overview                                                        -->
            <!--------------------------------------------------------------------->
            <div style="margin-top: var(--main-padding);"></div>
            <h1 id="overview">Lux - Lynx shading language</h1>
            <sep-3-></sep-3->
            <p>
                Lux is a <b>high level compiled shading language</b> with the aim of helping developers to efficiently write shaders without going through the tedious work of manually managing buffers and shaders.<br>
                It compiles to <b>GLSL 4.6</b>.
            </p>
            <p>The language is meant to be used alongside <b>Umbra</b>, the main programming language of the Lynx Engine, as it is highly compatible and interfacing shaders requires little to no effort.</p>
            <p>Lux is part of the <b>Lynx SDK</b>.</p>
            <p><a href="#quick-reference-tabs">Quick reference tabs</a></p>








            <!--------------------------------------------------------------------->
            <!-- Preprocessor                                                    -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id=preprocessor>Preprocessor</h1>
            <p>
                The <b>preprocessing</b> phase is done <b>before compiling</b> the code.<br>
                It removes comments and evaluates preprocessor directives and line continuation tokens.
            </p>
            <p>
                <b>Preprocessor directives</b> are special instructions that allow the <b>code</b> to be <b>programmatically modified</b>.<br>
                All the preprocessor directives are identified by the <code>#</code> character followed by their name and definition.<br>
                Each directive spans over a single, complete line of code.<br>
                Preprocessor directives are always case sensitive.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Comments                                                        -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id=comments>Comments</h2>
            <p>
                <b>Comments</b> are <b>portions of code</b> that are <b>purposely ignored</b>.<br>
                They can be used to provide informations or temporarily exclude lines of code.<br>
                Comments are allowed to contain any sequence of unicode characters of any length.<br>
            </p>
            <p>
                Single line comments start with <code>//</code> and end at the first newline character.<br>
                Multiline comments start with <code>/*</code> and end with <code>*/</code>
            </p>
            <p>Comments cannot be nested.</p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        //<elm->Comment string</elm-><nl-></nl->
                        /*<elm->Comment string</elm->*/
                    </scroll-></code->
                </fill->
            </syntax->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <c->// Single line comment</c->

                        <c->/* Multi
                        line
                        comment */</c->
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <c->/* Multi line /* Anorhter comment */ comment */
                        // Ok                             // ^ Error, unexpected token "comment"</c->
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Include statement                                               -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id=include-statement>Include statement</h2>
            <p>
                <b>Include statements</b> are used to <b>paste code</b> from other files.<br>
                Any existent file can be included, regardless of its contents or extension.<br>
                The path to the included file must be enclosed in <code>"</code><code>"</code> and can only contain alphanumeric characters, dots and slashes. //TODO <br>
                Both absolute and relative paths are supported.
            </p>
            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        #include<space-></space->"<elm->absolute/path/to/file</elm->"<nl-></nl->
                        #include<space-></space->"./<elm->relative/path/to/file</elm->"<nl-></nl->
                        #include<space-></space->"<elm->relative/path/to/file</elm->"<nl-></nl->
                    </scroll-></code->
                </fill->
            </syntax->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <c->// Ok</c->
                        <k->#include</k-> <s->"/home/Lynx/Lux/file.ilsh"</s->
                        <k->#include</k-> <s->"./file.ilsh"</s->
                        <k->#include</k-> <s->"file.ilsh"</s->

                        <c->// Error</c->
                        <c->//#include ./file.ilsh</c->
                        <c->//#include "./non_existent_file"</c->
                        <c->//#include ""</c->
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Macros                                                          -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="macros">Macros</h2>
            //TODO




            <!--------------------------------------------------------------------->
            <!-- Conditionals                                                    -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="conditionals">Conditionals</h2>
            //TODO




            <!--------------------------------------------------------------------->
            <!-- Line continuation token                                         -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="line-continuation-token">Line continuation token</h2>
            <p>
                The <b>line continuation token</b> can be used to <b>merge multiple lines</b> and allow single line comments, preprocessor directives and multi character tokens to be written across multiple lines.<br>
                It consists of a <code>\</code> immediatly followed by a newline character.
            </p>
            <p>
                Line continuation tokens can be used inside comments or other preprocessor directives, but cannot be nested.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        \<nl-></nl->
                    </scroll-></code->
                </fill->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <c->// single line comment</c->\
                        <c->on two lines</c->

                        <c->// #include "path/to/file"</c->
                        <k->#include</k-> <s->"pat</s->\
                        <s->h/to/file</s->\
                        <s->"</s->

                        <c->// void function() {
                        //   uint var = 0, b = 0;
                        //   var += b;
                        // }</c->
                        <t->vo</t->\
                        <t->id</t-> <f->fun</f->\
                        <f->ction</f->() {
                        <t->uint</t-> va\
                        r = <k->0</k->, b = <k->0</k->;
                        v\
                        ar +\
                        = <k->b</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <c->// Error, unexpected token "\"
                            //void ma\\

                            //in(){}
                            // Error,  unexpected token "in"</c->
                        </scroll-></code->
                </fill->
            </example->








            <!--------------------------------------------------------------------->
            <!-- Language components                                             -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="language-components">Language components</h1>




            <!--------------------------------------------------------------------->
            <!-- Tokens and identifiers                                          -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="tokens-and-identifiers">Tokens and identifiers</h2>
            <p>
                Any sequence of one or more characters that is left after the preprocessing phase is called a token.<br>
                Comments and whitespace characters can be freely written between two tokens without altering the GLSL output.<br>
                Tokens are always case sensitive.<br>
                Comments, newline characters, whitespace characters and preprocessor directives are <b>not tokens</b>.
            </p>

            <p>Each token can be classified as one of the following:</p>
            <div class="table-container"><table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th style="text-align: center;" colspan=4>Pattern</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Identifier</td>
                        <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code>, <code>$</code> and <code>_</code> that doesn't start with a decimal digit</td>
                    </tr>
                    <tr>
                        <td>Literal</td>
                        <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code> and <code>.</code> that starts with a decimal digit</td>
                    </tr>
                    <tr>
                        <td>Keyword</td>
                        <td class="center" colspan=2>
                            <a href="#namespaces">                  <code><w->namespace</w-></code></a>
                            <a href="#enums">                       <code><w->enum</w-></code></a>
                            <a href="#structs">                     <code><w->struct</w-></code></a>
                            <a href="#auto-specifier">              <code><w->auto</w-></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t->typeof</t-></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t->baseof</t-></code></a>
                            <a href="#type-groups">                 <code><w->typegroup</w-></code></a>
                            <a href="#const-qualifier">             <code><t->const</t-></code></a>
                            <a href="#symbol-aliases">              <code><w->alias</w-></code></a>
                        </td>
                        <td class="center" colspan=2>
                            <a href="#if-statement">                 <code><w->if</w-></code></a>
                            <a href="#select-statement">             <code><w->select</w-></code></a>
                            <a href="#for-loops">                    <code><w->for</w-></code></a>
                            <a href="#while-loops">                  <code><w->while</w-></code></a>
                            <a href="#while-loops">                  <code><w->do</w-></code></a>
                            <a href="#continue-and-break-statements"><code><w->continue</w-></code></a>
                            <a href="#continue-and-break-statements"><code><w->break</w-></code></a>
                            <a href="#once-statement">               <code><w->once</w-></code></a>
                            <a href="#then-statement">               <code><w->then</w-></code></a>
                            <a href="#else-statement">               <code><w->else</w-></code></a>
                            <a href="#return-statement">             <code><w->return</w-></code></a>
                        </td>
                    </tr>
                    <tr>
                        <td>Operator</td>
                        <td class="center">
                            <a href="#operators"><code>!</code></a>
                            <a href="#operators"><code>==</code></a>
                            <a href="#operators"><code>!=</code></a>
                            <a href="#operators"><code>=:</code></a>
                            <a href="#operators"><code>!:</code></a>
                            <a href="#operators"><code>&&</code></a>
                            <a href="#operators"><code>^^</code></a>
                            <a href="#operators"><code>||</code></a>
                            <a href="#operators"><code>&lt;</code></a>
                            <a href="#operators"><code>&lt;=</code></a>
                            <a href="#operators"><code>&gt;</code></a>
                            <a href="#operators"><code>&gt;=</code></a>
                        </td>
                        <td class="center">
                            <a href="#operators"><code>+</code></a>
                            <a href="#operators"><code>-</code></a>
                            <a href="#operators"><code>++</code></a>
                            <a href="#operators"><code>--</code></a>
                            <a href="#operators"><code>*</code></a>
                            <a href="#operators"><code>/</code></a>
                            <a href="#operators"><code>%</code></a>
                        </td>
                        <td class="center">
                            <a href="#operators"><code>&</code></a>
                            <a href="#operators"><code>|</code></a>
                            <a href="#operators"><code>^</code></a>
                            <a href="#operators"><code>&lt;&lt;</code></a>
                            <a href="#operators"><code>&gt;&gt;</code></a>
                            <a href="#operators"><code>~</code></a>
                        </td>
                        <td class="center wide-lines">
                            <a href="#special-operators"><elm-><code>(</code><code>)</code></elm-></a>
                            <a href="#special-operators"><elm-><code>[</code><code>]</code></elm-></a>
                            <a href="#special-operators"><code>.</code></a>
                            <a href="#special-operators"><elm-><code>?</code><code>:</code></elm-></a>
                        </td>
                    </tr>
                    <tr>
                        <td>Punctuation token</td>
                        <td class="center wide-lines" width="20%">
                            <elm-><code>(</code><code>)</code></elm->
                            <a href="#scopes-and-symbols"><elm-><code>{</code><code>}</code></elm-></a>
                            <a href="#arrays">            <elm-><code>[</code><code>]</code></elm-></a>
                        </td>
                        <td class="center" width="20%">
                            <code>,</code>
                            <code>;</code>
                            <code>|</code>
                            <a href="#scopes-and-symbols"><code>::</code></a>
                        </td>
                        <td class="center" width="20%"><a href="#reference-parameters"><code>&</code></a></td>
                        <td class="center" width="20%"><a href="#for-loops"><code>:</code></a></td>
                    </tr>
                    <tr>
                        <td>Assignment token</td>
                        <td class="center">
                            <a href="#assignments"><code>=</code></a>
                        </td>
                        <td class="center">
                            <a href="#assignments"><code>+=</code></a>
                            <a href="#assignments"><code>*=</code></a>
                            <a href="#assignments"><code>-=</code></a>
                            <a href="#assignments"><code>/=</code></a>
                            <a href="#assignments"><code>%=</code></a>
                        </td>
                        <td class="center" colspan=2><div style="width: 50%;">
                            <a href="#assignments"><code>&=</code></a>
                            <a href="#assignments"><code>|=</code></a>
                            <a href="#assignments"><code>^=</code></a>
                            <a href="#assignments"><code>&lt;&lt;=</code></a>
                            <a href="#assignments"><code>&gt;&gt;=</code></a>
                        </div></td>
                    </tr>
                </tbody>
            </table></div>
            <p>
                Identifiers are used to name symbols.<br>
                They must be unique to the current scope and not overlap with keywords.<br>
                Temporary variables are the only identifiers that are allowed to start with a <code>$</code>.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Scopes and symbols                                              -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="scopes-and-symbols">Scopes and symbols</h2>
            <p>A <b>symbol</b> is any <b>language component</b> that can be declared.</p>
            <p>
                <b>Scopes</b> define which <b>symbols</b> the code can <b>reference</b> and their absolute and relative names.<br>
                Any portion of code enclosed in <code>{</code><code>}</code> defines a new scope. the only exception is the <b>module scope</b>. It is always defined and contains all the symbols and scopes declared in the module. It can be referenced using the <code>this</code> identifier.<br>
                Like normal scopes, <code>this</code> can also be shadowed.
            </p>
            <p>
                Each scope can only contain certain types of symbols:
            </p>

            <div class="table-1-container">
                <div class="table-container table-1-left-container"><table class="table-1-left">
                    <tr style="height: 80px;"><th class="medium">Container scope</th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#modules">Module           </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#scopes-and-symbols">Namespace        </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#enums">             Enum             </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#structs">           Struct           </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#functions">         Function         </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--text-color)" href="#runtime-statements">Runtime statement</a></th></tr>
                </table></div>
                <div class="table-container table-1-right-container"><table class="table-1-right">
                    <tr style="height: 80px;">
                        <td><a style="color: var(--text-color)" href="#variables">                 Variable          </a></td>
                        <td><a style="color: var(--text-color)" href="#type-groups">               Type group        </a></td>
                        <td><a style="color: var(--text-color)" href="#runtime-statements">        Runtime statement </a></td>
                        <td><a style="color: var(--text-color)" href="#parametersa-and-references">Function parameter</a></td>
                        <td><a style="color: var(--text-color)" href="#enums">                     Enum element      </a></td>
                        <td><a style="color: var(--text-color)" href="#structs">                   Struct element    </a></td>
                        <td><a style="color: var(--text-color)" href="#structs">                   Struct            </a></td>
                        <td><a style="color: var(--text-color)" href="#enums">                     Enum              </a></td>
                        <td><a style="color: var(--text-color)" href="#namespaces">                Namespace         </a></td>
                        <td><a style="color: var(--text-color)" href="#symbol-aliases">            Symbol alias      </a></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-n">No</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                        <td class="table-1-y">Yes</td>
                    </tr>
                </table></div>
            </div>
            <p>
                <b>Local names</b> are used to reference symbols declared in the <b>current scope</b> or in one of the <b>enclosing scopes</b>.<br>
                <b>Relative names</b>, instead, can reference <b>any symbol</b> declared in the module. They consist of the local names of an enclosing scope, the symbol and all the enclosing scopes in between, separated by <code>::</code> tokens, in the same order as they were declared in the code.<br>
                A relative name that starts from the module scope is called an absolute name.
            </p>
            <p>
                Declaring a symbol with the same identifier as one declared in an enclosing scope will shadow the old symbol, and any use of the local identifier in the current and sub scopes will refer to the new symbol.<br>
                Declaring the same identifier more than once in the same scope is only allowed for function overloading. Anything else is a semantic error.<br>
            </p>
            <p>Symbols declared in unnamed scopes cannot be referenced from outside, and unnamed symbols cannot be referenced at all</p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <c->// Module scope</c->
                        <c->// Local name: this</c->


                        <c->// Local name: s</c->
                        <c->// Relative names: this::s</c->
                        <w->struct</w-> <t->s</t-> { <t->uint</t-> n; }

                        <w->namespace</w-> {
                            <c->// Local name: fun</c->
                            <c->// Unnamed enclosing scope, cannot be referenced from outside</c->
                            <t->void</t-> <f->fun</f->(<t->uint</t-> <a->n</a->) {}
                        }


                        <c->// Local name: fun</c->
                        <c->// Relative names: this::fun</c->
                        <t->void</t-> <f->fun</f->(<t->uint</t-> <a->n</a->) {
                            <w->if</w->(n){
                                <c->// Local name: s2</c->
                                <c->// Unnamed enclosing scope, cannot be referenced from outside</c->
                                <w->struct</w-> <t->s2</t-> { <t->uint</t-> n; };
                            }

                            <c->// Local name: s, shadows this::s</c->
                            <c->// Relative names: this::fun::s, fun::s</c->
                            <w->struct</w-> <t->s</t-> { <t->uint</t-> a, b; }
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <p>Symbols can be declared anywhere in the scope, except for variables, which have to be declared before they are used in expressions.</p>
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->void</t-> <f->main</f->(){
                            <c->//var.n = 8;     // Error</c->
                            <t->s</t-> var = (<k->16</k->); <c->   // Ok</c->
                        }
                        <w->struct</w-> s { <t->int</t-> n; }
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Namespaces                                                      -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="namespaces">Namespaces</h2>
            <p>
                <b>Namespaces</b> are used to create <b>named scopes</b> which can contain
                <a href="#variables">variables</a>, <a href="#functions">functions</a>, <a href="#structs">structs</a>, <a href="#enums">enums</a>, <a href="#symbol-aliases">symbol aliases</a>.<br>
                They don't affect the runtime behaviour and can be declared in any scope.<br>
                Unnamed namespaces are allowed.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        namespace<space-></space-><elm->name<sup>id</sup></elm-> { <elm->...</elm-> }
                        namespace { <elm->...</elm-> }
                    </scroll-></code->
                </fill->
            </syntax->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <w->namespace</w-> a {
                            <t->int</t-> n = <k->4</k->;
                        }

                        <t->int</t-> n2 = a::<k->n</k->;
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Types                                                           -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="types">Types</h2>
            <p>
                <b>Data types</b> define how <b>values</b> are <b>interpreted</b> during runtime and how they can be used within expressions.<br>
                Every value has an associated type, regardless of it being a right or a left value.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Primitive types                                                 -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="primitive-types">Primitive types</h3>
            <p>Lux features <b>five primitive types</b>, which can be used to define more complex types such as structs, arrays and enums.</p>
            <p>
                Those types are always present and they act as if they were declared in the module scope.<br>
                Primitive types are <b>not keywords</b> and can be shadowed like any other symbol.
            </p>
            <p>The primitive types are:</p>
            <div class="table-container"><table>
                <tr>
                    <th>Type name   </th>
                    <th>Size (bytes)</th>
                    <th>Value type  </th>
                </tr>
                <tr>
                    <td><code><t->uint</t-></code></td>
                    <td class="center">4</td>
                    <td>Unsigned integral number</td>
                </tr>
                <tr>
                    <td><code><t->int</t-></code></td>
                    <td class="center">4</td>
                    <td>Signed integral number</td>
                </tr>
                <tr>
                    <td><code><t->float</t-></code></td>
                    <td class="center">4</td>
                    <td>Floating point number</td>
                </tr>
                <tr>
                    <td><code><t->double</t-></code></td>
                    <td class="center">8</td>
                    <td>Floating point number</td>
                </tr>
                <tr>
                    <td><code><t->bool</t-></code></td>
                    <td class="center">4</td>
                    <td>Boolean value. <code><k->true</k-></code> or <code><k->false</k-></code></td>
                </tr>
            </table></div>
            <p>
                As in most programming languages, the boolean <code><k->true</k-></code> and <code><k->false</k-></code> values correspond to the integral literals <code><k->1</k-></code> and <code><k->0</k-></code>. They can be used interchangeably.<br>
                Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
            </p>
            <p>
                All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
                There are no 64 bit integers, characters or strings.
            </p>
            <p>
                The <code><t->void</t-></code> type is a special type. It can only be used to decleare functions that don't return any value.
            </p>
            <p>
                See
                <a href="#values">Values</a>,
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Enums                                                           -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="enums">Enums</h3>
            <sep-></sep->

            <p>
                <b>Enums</b> are used to <b>name</b> and <b>group</b> literal <b>constants</b> of the same type.<br>
                The base type of the enum can be specified after its name and it must be one of the primitive types.<br>
                Elements are declared in the same way as variables, but neither the type nor the const qualifier are specified explicitly.<br>
                The initializer values are implicitly converted to the base type of the enum.
            </p>
            <sep-></sep->
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        enum<space-></space-><elm->name<sup>id</sup></elm-> : <elm-><t->T<sup>type</sup></t-> </elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> }
                        strict enum<space-></space-><elm->name<sup>id</sup></elm-> : <elm-><t->T<sup>type</sup></t-> </elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Element syntax</label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                    </scroll-></code->
                </right->
            </syntax->
            <p>
                Elements of integral enums which are not initizlied will have the value of the preceeding element + 1, or 0 if they are the first.<br>
                Elements of boolean and floating point enums must always be initialized.<br>
                Multiple elements can have the same value, but each element can only be declared once.<br>
                Enums with no elements are not allowed.
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <w->enum</w-> <t->e</t-> : <t->int</t-> {
                            a, b;              <c->// Ok, a = 0, b = 1</c->
                            c = <k->-266250</k->;       <c->// Ok, c = -266250</c->
                            d, e = 0;          <c->// Ok, d = -266249, e = 0</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <w->enum</w-> <t->c</t-> : <t->double</t-> {
                            pi = <k->3.14159</k->;      <c->// Ok</c->
                            e  = <k->2.71828</k->;      <c->// Ok</c->
                            <c->//phi;             // Error, uninitialized non-integral enum value</c->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->c</t-> a = <k->c::pi</k->;       <c->// Ok</c->
                            <t->c</t-> b = <k->3.14159</k->;     <c->// Ok</c->
                            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->

            <p>
                By default, all enums behave exactly as their base types, much like a <a href="#symbol-aliases">symbol alias</a>.<br>
                When implicit conversions from other types are undesirable, enums can be declared as <code><w->strict</w-></code>.<br>
                Strict enums only allow values of the same enum, but can still be implicitly converted to other types.
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <w->strict enum</w-> <t->c</t-> : <t->double</t-> {
                            pi  = <k->3.14159</k->;
                            e   = <k->2.71828</k->;
                            phi = <k->1.61803</k->;
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->c</t-> a = <k->c::phi</k->;      <c->// Ok</c->
                            <c->//c b = 1.61803;   // Error, cannot convert from double to strict enum</c->
                            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#implicit-conversions">Implicit conversions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Structs                                                         -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="structs">Structs</h3>
            <p>
                <b>Structs</b> are used to <b>group values</b> of <b>different types</b>.<br>
                The members are declared in the same way as variables, and they can be of any type, including enums, arrays and other structures.<br>
                They cannot be <a href="#const-qualifier"><code><t->const</t-></code></a> and cannot have initializer values.<br>
                Like variables, uninitialized members cannot be used within expressions. Struct values must also be fully initialized before they can be used in expressions.
            </p>
            <p>
                Empty structs are allowed.<br>
                Member access is explained in <a href="#special-operators">Special operators</a>.<br>
                Struct initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>
            <sep-></sep->
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        struct<space-></space-><elm->name<sup>id</sup></elm-> { <elm2-><elm->member 0</elm->; <elm->...</elm->; <elm->member n</elm->;</elm2-> }
                        struct<space-></space-><elm->name<sup>id</sup></elm-> { }
                    </scroll-></code->
                </left->
                <right->
                    <label->Member syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </right->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <w->struct</w-> <t->idk</t-> {
                            <t->uint</t-> a, b;        <c->// Ok</c->
                            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
                            <c->//double const d; // Error, struct members cannot be const</c->
                        }
                        <t->void</t-> <f->main</f->(){
                            <t->idk</t-> var;

                            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
                            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
                            <c->//var.b = var.c[0];     // Error, var.c is uninitialized</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#arrays">Arrays</a>,
                <a href="#enums">Enums</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Arrays                                                          -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="arrays">Arrays</h3>
            <p>
                <b>Arrays</b> can <b>aggregate values</b> of the <b>same type</b>.<br>
                Functions, parameters, right values, variables and struct member can all have array type.<br>
                Arrays can use any base type, including structs, enums and other arrays.<br>
                An array of arrays is called a multidimensional array. There is no limit to the number of dimensions an array can have.<br>
            </p>
            <p>
                Array declarations are identical to normal types, but <code>[</code><code>]</code> tokens follow the type, optionally enclosing an expression to specify the number of elements.<br>
                Arrays can be initialized using any expression of a type that can be implicitly converted.<br>
                If the <code>[</code><code>]</code> are left empty, the number of elements is determined by the inizializer value, which becomes required and must be an implicitly convertible list.
            </p>
            <p>
                There are no dynamic arrays.<br>
                Element access is explained in <a href="#special-operators">Special operators</a>.<br>
                Array initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T</t-><sup>type</sup></elm->[<elm-><t->uint<sup>r</sup></t-></elm->]<space-></space-><elm->name<sup>id</sup></elm->;
                        <elm-><t->T</t-><sup>type</sup></elm->[] <elm->name<sup>id</sup></elm-> = <elm-><t->T[]<sup>r</sup></t-></elm->;
                    </scroll-></code->
                </fill->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->uint</t->[<k->4</k->] <f->func</f->(<t->float</t->[<k->4</k->] n){
                            <w->if</w->(n[<k->3</k->]) <w->return</w-> n * <k->4</k->;
                            <w->else</w-> <w->return</w-> n[<k->0</k->];
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#enums">Enums</a>,
                <a href="#implicit-conversions">Implicit conversions</a>,
                <a href="#constructors">Constructors</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Tuples                                                          -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="tuples">Tuples</h3>
            <p>
                <b>Tuples</b> are used to <b>group values</b> of <b>different types</b>.<br>
                The type of a tuple is the list of all the types of its elements. Any sequence of types enclosed in <code>(</code><code>)</code> is interpreted as a tuple type.<br>
                Differently from <a href="#structs">structs</a>, tuples don't need to be declared before being used and their elements aren't named.<br>
            </p>
            <p>
                The type of two tuples can only differ by the type and the order of their elements. If those are identical, the tuples have the same type.<br>
                Element access is explained in <a href="#special-operators">Special operators</a>.<br>
                Tuple initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>
            <p>
                Tuples cannot have 0 elements.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        (<elm-><elm-><t->T0<sup>type</sup></t-></elm->, <elm-><t->...<sup>type</sup></t-></elm->, <elm-><t->Tn<sup>type</sup></t-></elm-></elm->) <elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </fill->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        (<t->int</t->, <t->int</t->) <f->func</f->((<t->uint</t->, <t->bool</t->, <t->float</t->) <a->a</a->, <t->uint</t-> <a->b</a->){
                            <w->return</w-> (<k->0</k->, a[<k->1</k->] ? a[<k->0</k->] : b * a[<k->2</k->]);
                        };

                        <t->void</t-> <f->main</f->(){
                            (<t->int</t->) n = (<f->func</f->((<k->9</k->, <k->true</k->, <k->0.5</k->), <k->5</k->)[<k->1</k->]);
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                //TODO
            </p>


            <!--------------------------------------------------------------------->
            <!-- Implicit conversions                                            -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="implicit-conversions">Implicit conversions</h3>
            <p>
                <b>Implicit conversions</b> are performed when an <b>expression</b> of the <b>incorrect type</b> is used in place of the expected one.<br>
                This includes anything whose syntax requires an expression.<br>
                In function overloads and templates, the actual type of the value always takes precedence over conversions.
            </p>
            <p>
                Primitive types are all implicitly convertible between them.<br>
                The conversions follow these rules:
            </p>
            <div class="table-container"><table>
                <thead><tr>
                    <th>Expression type</th>
                    <th>Expected type</th>
                    <th>Behaviour</th>
                </tr></thead>
                <tbody>

                    <!-- uint ---------------------------------------------------------------------->
                    <tr>
                        <td rowspan="3"><code><t->uint</t-></code></td>
                        <td><code><t->int</t-></code></td>
                        <td class="wide-lines">Values over <code>limits::int::<k->max</k-></code> overflow to <code>limits::int::<k->min</k-> + <k->n</k-> - <k->1</k-></code></td>
                    </tr>
                    <tr>
                        <td><code><t->float</t-></code> <code><t->double</t-></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t->bool</t-></code></td>
                        <td class="wide-lines"><code><k->1</k-></code> is evaluated as <code><k->true</k-></code>, any other value as <code><k->false</k-></code></td>
                    </tr>

                    <!-- int ----------------------------------------------------------------------->
                    <tr>
                        <td rowspan="3"><code><t->int</t-></code></td>
                        <td><code><t->uint</t-></code></td>
                        <td class="wide-lines">Negative values underflow to <code>limits::uint::<k->max</k-> + <k->n</k-> + <k->1</k-></code></td>
                    </tr>
                    <tr>
                        <td><code><t->float</t-></code> <code><t->double</t-></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t->bool</t-></code></td>
                        <td class="wide-lines"><code><k->1</k-></code> is evaluated as <code><k->true</k-></code>, any other value as <code><k->false</k-></code></td>
                    </tr>

                    <!-- float --------------------------------------------------------------------->
                    <tr>
                        <td rowspan="4"><code><t->float</t-></code></td>
                        <td><code><t->uint</t-></code></td>
                        <td class="wide-lines">The decimal part is truncated. Negative values underflow to <code>limits::uint::<k->max</k-> + <k->n</k-> + <k->1</k-></code>.<br>
                        If the value is not between <code>limits::uint::<k->min</k-></code> and <code>limits::uint::<k->max</k-></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t->int</t-></code></td>
                        <td class="wide-lines">The decimal part is truncated.<br>
                        If the value is not between <code>limits::int::<k->min</k-></code> and <code>limits::int::<k->max</k-></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t->double</t-></code></td>
                        <td>No changes</td>
                    </tr>
                    <tr>
                        <td><code><t->bool</t-></code></td>
                        <td class="wide-lines"><code><k->1.0</k-></code> is evaluated as <code><k->true</k-></code>, any other value as <code><k->false</k-></code></td>
                    </tr>

                    <!-- double -------------------------------------------------------------------->
                    <tr>
                        <td rowspan="4"><code><t->double</t-></code></td>
                        <td><code><t->uint</t-></code></td>
                        <td class="wide-lines">The decimal part is truncated. Negative values underflow to <code>limits::uint::<k->max</k-> + <k->n</k-> + <k->1</k-></code>.<br>
                        If the value is not between <code>limits::uint::<k->min</k-></code> and <code>limits::uint::<k->max</k-></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t->int</t-></code></td>
                        <td class="wide-lines">The decimal part is truncated.<br>
                        If the value is not between <code>limits::int::<k->min</k-></code> and <code>limits::int::<k->max</k-></code>, the result is <b>undefined</b></td>
                    </tr>
                    <tr>
                        <td><code><t->float</t-></code></td>
                        <td>The result is approximated using the maximum precision available</td>
                    </tr>
                    <tr>
                        <td><code><t->bool</t-></code></td>
                        <td class="wide-lines"><code><k->1.0</k-></code> is evaluated as <code><k->true</k-></code>, any other value as <code><k->false</k-></code></td>
                    </tr>

                    <!-- bool ---------------------------------------------------------------------->
                    <tr>
                        <td rowspan="2"><code><t->bool</t-></code></td>
                        <td><code><t->uint</t-></code> <code><t->int</t-></code></td>
                        <td class="wide-lines"><code><k->true</k-></code> is evaluated as <code><k->1</k-></code>, <code><k->false</k-></code> as <code><k->0</k-></code></td>
                    </tr>
                    <tr>
                        <td><code><t->float</t-></code> <code><t->double</t-></code></td>
                        <td class="wide-lines"><code><k->true</k-></code> is evaluated as <code><k->1.0</k-></code>, <code><k->false</k-></code> as <code><k->0.0</k-></code></td>
                    </tr>
                </tbody>
            </table></div>
            <p>
                Additional conversions for non-primitive types are described as follows:
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Expression type  </th>
                    <th>Expected type    </th>
                    <th>Behaviour        </th>
                </tr>

                <!-- Element to array ---------------------------------------------------------->
                <tr>
                    <td class="center" rowspan="2"><code><t->T</t-></code></td>
                    <td class="center"><code><t->T[n]</t-></code></td>
                    <td rowspan="2">
                        Each element of the result is initialized with the value of the source expression.<br>
                        <code><t->T</t-></code> must be implicitly convertible to <code><t->U</t-></code>.
                    </td>
                </tr>
                <tr>
                    <td class="center"><code><t->U[n]</t-></code></td>
                </tr>

                <!-- Tuple to tuple, struct or array ------------------------------------------->
                <tr>
                    <td class="center" rowspan="3"><code><t->(T0, ..., Tn)</t-></code></td>
                    <td class="center"><code><t->(U0, ..., Un)</t-></code></td>
                    <td rowspan="3">
                        Each element of the result is initialized with the corresponding value of the source tuple.<br>
                        The type of each element of the source tuple must be implicitly convertible to the type of the destination element.
                    </td>
                </tr>
                <tr>
                    <td class="center">
                        <template->with(U == struct_t)</template-><br>
                        <code><t->U</t-></code>
                    </td>
                </tr>
                <tr>
                    <td class="center">
                        <code><t->U[n]</t-></code>
                    </td>
                </tr>

                <!-- Array to array and array to bool ------------------------------------------>
                <tr>
                    <td class="center" rowspan="2">
                        <template->with(T != struct_t && T != tuple_t)</template-><br>
                        <code><t->T[n]</t-></code>
                    </td>
                    <td class="center"><code><t->U[n]</t-></code></td>
                    <td>
                        Each element of the result is initialized with the corresponding value of the source array.<br>
                        <code><t->T</t-></code> must be implicitly convertible to <code><t->U</t-></code>.
                    </td>
                </tr>
                <tr>
                    <td class="center"><code><t->bool</t-></code></td>
                    <td>Evaluated as <code><k->true</k-></code> if all the elements of the source array converted to <code><t->bool</t-></code> evaluate as <code><k->true</k-></code>, <code><k->false</k-></code> otherwise</td>
                </tr>
            </table></div>
            <p>
                Values cannot be explicitly casted. To convert a value, <a href="#constructors">constructors</a> are used.<br>
                Attempting to convert incompatible types will result in a semantic error.<br>
                Structs are never convertible.
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->bool</t-> <f->fun</f->(<t->uint</t-> <a->a</a->) { <k->return</k-> !a; }

                        <t->void</t-> <f->main</f->(){
                            <w->struct</w-> { <t->uint</t-> n; } var = (<k->0</k->);
                            <c->//fun(var);                    // Error, structs cannot be converted</c->
                            <t->int</t->      a = <f->fun</f->(<k->0</k->);           <c->// Ok, fun::a = 2,          main::a = 1</c->
                            <t->float</t->[<k->2</k->] b = <f->fun</f->(<k->-1</k->);          <c->// Ok, fun::a = 4294967263, main::b = (0.0, 0.0)</c->
                            b = (<k->5</k->, <k->7</k->);                    <c->// Ok, main::b = (5.0, 7.0). Converted from tuple</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#arrays">Arrays</a>,
                <a href="#constructors">Constructors</a>,
                <a href="#standard-modules">Standard modules</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Auto specifier                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="auto-specifier">Auto specifier</h3>
            <p>
                The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b>type</b> when declaring a variable or function.<br>
                The actual type of the symbol will be the same as the expression used to initialize it.<br>
            </p>
            <p>
                <code><t->auto</t-></code> is not allowed in struct members declarations and function parameters.<br>
                The type of <code><t->auto</t-></code> functions is determined by their return value.<br>
                There is no <code><t->auto</t-></code> constructor.
            </p>
            <p>
                <code><t->auto</t-></code> arrays and <code><t->const</t-></code> <code><t->auto</t-></code> symbols are allowed.
                //TODO auto functions that depend on an argument value
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <t->auto</t-> <f->func</f->(){
                            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
                        }

                        <t->auto</t-> <f->main</f->(){
                            <t->auto</t-> a = <k->2</k->;         <c->// a has type uint</c->
                            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type float</c->
                            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
                            <c->// No return statement, main has type void</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <t->auto</t->[<k->4</k->] a = <k->1</k->;          <c->// a has type int[4] and value (1, 1, 1, 1)</c->
                        <t->auto</t->[<k->2</k->] <t->const</t-> b = !<k->a</k->;   <c->// b has type bool[4][2] and value ((0, 0, 0, 0), (0, 0, 0, 0))</c->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Typeof and baseof specifiers                                    -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="typeof-and-baseof-specifiers">Typeof and baseof specifiers</h3>
            <p>
                The <b><code><t->typeof</t-></code></b> and <b><code><t->baseof</t-></code></b> specifiers are used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b>expression</b> that is passed to them.<br>
                <code><t->typeof</t-></code> returns the type of the expression, <code><t->baseof</t-></code> returns its base type.<br>
                Using them on the <code><t->void</t-></code> type returns <code><t->void</t-></code>.
            </p>
            <p>
                <code><t->baseof</t-></code> can only be used on <a href="#arrays">arrays</a>, <a href="#enums">enums</a> and <a href="#primitive-types">primitive types</a>.<br>
                The base type of primitive types is the type itself.<br>
                The expressions passed to those specifiers are always evaluated at compile time.
            </p>
            <p>
                The <code><t->typeof</t-></code> and <code><t->baseof</t-></code> specifiers can be used as constructors.<br>
                Circular dependencies are a semantic error.
                //TODO
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        typeof(<elm-><t->T</t-><sup>r</sup></elm->)
                        baseof(<elm-><t->T</t-><sup>r</sup></elm->)
                    </scroll-></code->
                </fill->
            </syntax->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

                        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
                            <t->int</t-> a[<k->2</k->] = (<k->1</k->, <k->2</k->);      <c->// a has type int[2]</c->
                            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int[2]</c->
                            <t->baseof</t->(<k->a</k->) c = <k->a</k->[<k->0</k->];     <c->// c has type int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Unnamed types                                                   -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h2 id="unnamed-types">Unnamed types</h2>
            <p>
                When a type doesn't have to be explicitly referenced more than once, <b>unnamed types</b> can be used to define both the type and the symbol in the same construct.<br>
                Similarly to the C syntax, the type name is not specified and the definition is used as type of the symbol.
            </p>
            <p>
                Any symbol defined inside those types can still be referenced through the <code><t->typeof</t-></code> and <code><t->auto</t-></code> specifiers.<br>
                Members of unnamed structs can be accessed using the member access operator, like normal structs.<br>
                Defining an unnamed type without also declaring the symbol is allowed, but it generates a warning as the type and anything declared in it would be unaccessible.
            </p>

            <sep-></sep->
            <syntax->
                <left->
                    <label-> - Struct</label->
                    <code-><scroll->
                        struct { <elm2-><elm->member 0</elm->; <elm->...</elm->; <elm->member n</elm->;</elm2-> } <elm->symbol definition</elm->;
                        struct { } <elm->symbol definition</elm->;
                    </scroll-></code->
                </left->
                <right->
                    <label->Member syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </right->
            </syntax->
            <sep-></sep->
            <syntax->
                <left->
                    <label-> - Enum</label->
                    <code-><scroll->
                        enum : <elm-><t->T<sup>type</sup></t-></elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> } <elm->symbol definition</elm->;
                        strict enum : <elm-><t->T<sup>type</sup></t-></elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> } <elm->symbol definition</elm->;
                    </scroll-></code->
                </left->
                <right->
                    <label->Element syntax</label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                    </scroll-></code->
                </right->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <w->strict enum</w-> : <t->bool</t-> {
                            on = <k->true</k->;
                            off = <k->false</k->;
                        } grasses;

                        <t->void</t-> <f->main</f->(){
                            this.grasses = <t->typeof</t->(grasses)::<k->on</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <w->struct</w-> {
                            <t->uint</t-> a, b;
                            <w->enum</w-> : int {
                                idk1;
                                idk2;
                            } c;
                        } <f->fun</f->(){
                            <w->return</w-> (<k->1</k->, <k->1</k->, <k->0</k->); <c->// Ok, unnamed struct constructor</c->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->auto</t-> var = fun();

                            <c->// Both are allowed</c->
                            var.c = <t->typeof</t->(var.c)::<k->idk1</k->;
                            var.c = <t->typeof</t->(<t->typeof</t->(<f->fun</f->)::c)::<k->idk2</k->;

                            <t->typeof</t->(var.a) a = <k->0</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#typeof-and-baseof-specifiers">Typeof and baseof specifiers</a>,
                <a href="#auto-specifier">Auto specifier</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Variables                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="variables">Variables</h2>
            <p>
                <b>Variables</b> are <b>named memory locations</b> that can contain values of the specified type.<br>
                Each variable <b>must be declared</b> before it is used. Variables <b>cannot be redeclared</b> and their <b>type cannot be changed</b> after the declaration.
                //TODO multiple declarations;
            </p>
            <p>
                A variable declaration consists of the type, the name and an optional <code>=</code> followed by an expression of a compatible type that is used to inizialize it.<br>
                If an initializer expression is not specified, the value of the variable is undefined.<br>
                Evaluating an expression that can result in an undefined value is considered a logical error and will stop the compilation process.<br>
                Variables with undefined value can still be passed to reference arguments of functions or be assigned a value.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->;
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->;
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space->const<space-></space-><elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->;  <c->// See <a href="#const-qualifier"><c->Const qualifier</c-></a></c->
                    </scroll-></code->
                </fill->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->uint</t-> variable = <k->0</k->;         <c->// Ok, variable has value 0</c->
                        <t->float</t-> nya = <k->5</k-> + <k->variable</k->;  <c->// Ok, nya ha value 5.0</c->
                        <t->bool</t-> var$;                 <c->// Ok, var$ has undefined value</c->
                        <c->//b var_2 = var$;          // Error. The syntax is correct, but undefined values (var$) cannot be used inside expressions</c->

                        <c->//double variable;         // Error, the identifier "variable" is already declared</c->
                        <c->//double foo               // Error, ';' is not optional</c->
                        <c->//b $var;                  // Error, invalid identifier</c->
                        <c->//b 2var;                  // Error, invalid identifier</c->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#expressions">Expressions</a>,
                <a href="#functions">Functions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Temporary variables                                             -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="temporary-variables">Temporary variables</h3>
            <p>
                <b>Temporary variables</b> are a special set of identifiers that have <b>dynamic type</b> and don't need to be declared.<br>
                These identifiers are meant to replace local variables whose only purpose is holding values that don't need to be used more than a few times.<br>
                A temporary variable is identified by the <code>$</code> character followed by an arbitrary number of decimal digits, which denote its name.<br>
            </p>
            <p>
                They are always <b>function-level scoped</b> and cannot be used outside of function definitions.<br>
                There is no limit to the number of temporary variables a function can use.<br>
            </p>
            <p>
                The type of a temporary variable can only be changed through direct assignments (<a href="#assignments"><code>=</code></a>) and it must be unambiguously determinable in order for the variable to be evaulated.
                This means that reading the value of a temporary variable after one or more branches that may have assigned it different types is not allowed and will result in a semantic error.<br>
                Using temporary variables whose type is undefined will also result in a semantic error.
            </p>
            <p>They act as normal variables for anything else.</p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">1</label->
                    <code-><scroll->
                        <t->uint3</t-> <f->fun1</f->(<t->bool</t-> <a->arg</a->) {
                            $0 = <k->1</k->;             <c->// Ok, $0 has type uint and value 1</c->
                            <c->//$2 = $1;          // Error, $1 has undefined type</c->

                            <t->uint3</t-> vec = { <k->0</k->, <k->1</k->, <k->2</k-> };
                            $2 = <k->true</k->;          <c->// Ok, $2 has type b and value true</c->
                            $2 = <k->vec</k->;           <c->// Ok, $2 has type uint3 and value { 0, 1, 2 }</c->
                        }

                        <t->void</t-> <f->fun2</f->(<t->uint3</t-> <a->vec</a->) {
                            <c->//uint var = $2;    // Error, $2 has undefined type. fun2::$2 has nothing to do with fun1::$2</c->
                        }

                        <c->//uint var = $9;        // Error, temporary variables cannot be used outside of functions</c->
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)">2</label->
                    <code-><scroll->
                        <t->void</t-> <f->fun3</f->(<t->bool</t-> <a->arg</a->, <t->uint2</t-> &<a->ref</a->) {
                            <w->if</w->(arg) $0 = <k->1</k->;             <c->// $0 has type uint</c->
                            <w->else</w->    $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
                            <c->//ref = $0;                 // Error, cannot determine the type of $0</c->
                            $0 = ref;                   <c->// Ok, $0 has type uint2 and the same value as ref</c->

                            <w->if</w->(arg) $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
                            <w->else</w->    $0 = { <k->2</k->, <k->3</k-> };      <c->// $0 has type uint2</c->
                            ref = <k->$0</k->;                   <c->// Ok, $0 has type uint2</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#selection">Selection</a>,
                <a href="#functions">Functions</a>,
                <a href="#expressions">Expressions</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Functions                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="functions">Functions</h2>
            <p>
                <b>Functions</b> are the <b>main component</b> of the language. They contain the statements that will be executed during run time and manage inputs and outputs of the shader.<br>
                A function definition consists of its type and name followed by a list of arguments and its statements enclosed in <code>{</code><code>}</code> delimiters.
            </p>
            <p>
                A function can take an arbitrary number of parameters of any type. Paramters are declared like variables and behave in the same exact way.<br>
                The expressions used to call the function are called arguments.<br>
                Each argument must be implicitly convertible to the type of the parameter.<br>
                Functions are allowed to take no arguments.
            </p>

            <sep-></sep->
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->() { <elm->...</elm-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Parameter syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space->&<elm->name<sup>id</sup></elm->         <c->// See <a href="#reference-parameters"><c->Reference parameters</c-></a></c->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space->const<space-></space-><elm->name<sup>id</sup></elm->    <c->// See <a href="#const-qualifier"><c->Const qualifier</c-></a></c->
                    </scroll-></code->
                </right->
            </syntax->
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->void</t-> <f->fun</f->(<t->uint</t-> <a->n</a->) {}

                        <t->void</t-> <f->main</f->(){
                            <t->int</t-> var = <k->0</k->;
                            <f->fun</f->(<k->var</k->);
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#runtime-statements">Runtime statements</a>,
                <a href="#types">Types</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Parameters and references                                       -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="reference-parameters">Reference parameters</h3>
            <p>
                By <b>default</b>, the arguments are passed <b>by value</b>, which means that when the function is called, the value of each argument is <b>copied</b> in the corresponding parameter and the function <b>cannot access</b> the original variable.<br>
                If a parameter name is preceeded by a <b><code>&</code></b> token, instead, the argument is passed <b>by reference</b>, allowing the function to <b>access and modify</b> its value
            </p>
            <p>
                Declaring a reference parameter as const is a syntax error and passing an r-value as argument of a reference parameter is a semantic error.<br>
                Notice that in this case, the <code>&</code> token is not part of the type nor part of the name, but a language feature that is used exclusively within parameter declarations.
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->void</t-> <f->fun1</f->(<t->uint</t-> <a->arg1</a->, <t->uint</t-> &<a->arg2</a->) {
                            arg1 = <k->0</k->;     <c->// c_doesn't modify main::a, but the local argument in which its value was copied</c->
                            arg2 = <k->0</k->;     <c->// c_modifies main::b</c->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->uint</t-> a, b;
                            <f->fun1</f->(a, b);   <c->// a keeps an undefined value, b is set to 0</c->
                            <c->//fun1(a, 5); // Error, cannot pass literals to reference parameters</c->
                        }

                        <c->//void fun2(const int &arg1){} // Error, references cannot be const</c->
                    </scroll-></code->
                </fill->
            </example->

            <p>
                See
                <a href="#const-qualifier">Const qualifier</a>,
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Return statement and function calls                             -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="return-statement-and-function-calls">Return statement and function calls</h3>
            <p>
                The <b><code><k->return</k-></code></b> statement skips all remaining statements in the function and <b>returns</b> the <b>code execution</b> to the <b>caller function</b>.<br>
                Non-void functions can return a value of the same type as the function.<br>
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        return<space-></space-><elm-><t->T<sup>r</sup></t-></elm->;
                        return;
                    </scroll-></code->
                </fill->
            </syntax->

            <p>
                <b>Functions</b> are <b>called</b> using their <b>name</b> and a list of <b>arguments</b>.<br>
                A function call must provide an argument for each parameter of the function.<br>
                Reference parameters (<a href="#reference-parameters"><code>&</code></a>) only allow l-values as arguments, while <a href="#const-qualifier"><code><t->const</t-></code></a> parameters only allow r-values.
            </p>
            <p>
                All non-<code><t->void</t-></code> functions return an r-value.<br>
                The return value can be used in expressions or be ignored.<br>
                Calls to <code><t->void</t-></code> functions cannot be used in expressions.
            </p>

            <sep-></sep->
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm->(<elm-><elm-><t->T0<sup>r</sup></t-></elm->, <elm->...</elm->, <elm-><t->Tn<sup>r</sup></t-></elm-></elm->)
                        <elm->name<sup>id</sup></elm->()
                    </scroll-></code->
                </fill->
            </syntax->

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->void</t-> <f->empty_function_1</f->() { <w->return</w->; }    <c->// Ok</c->
                        <t->void</t-> <f->empty_function_2</f->() {}             <c->// Ok</c->

                        <t->uint</t-> <f->empty_function_3</f->() { <w->return</w-> <k->0</k->; }  <c->// Ok</c->
                        <c->//uint empty_function_4() {}           // Error, non-void functions must return a value</c->

                        <t->uint</t-> <f->f</f->(<t->uint</t-> <a->n</a->) { <w->return</w-> n * <k->2</k->; }       <c->// Ok</c->
                        <c->//void f() { }                         // Error, f is already defined</c->

                        <t->void</t-> <f->main</f->(){
                            <t->uint</t-> n = <f->empty_function_3</f->();       <c->// Ok</c->
                            n = <f->f</f->(<f->f</f->(<k->n</k->));                       <c->// Ok</c->
                        }
                    </scroll-></code->
                </fill->
            </example->


            // TODO                      FIX TEMPLATE EXAMPLE 1 > ADD2 RETURN VALUE
            <!--------------------------------------------------------------------->
            <!-- Template functions                                              -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="template-functions">Template functions</h3>
            <p>
                <b>Template functions</b> are the basis of generic programming.<br>
                They are used to <b>generate functions</b> based on the types passed to function calls.<br>
            </p>

            <sep-></sep->
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) when(<elm-><t->bool<sup>r</sup></t-></elm->) { <elm->...</elm-> }
                        ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) when(<elm-><t->bool<sup>r</sup></t-></elm->) { <elm->...</elm-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Parameter syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space->&<elm->name<sup>id</sup></elm->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space->const<space></space><elm->name<sup>id</sup></elm->
                        ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        ?<elm->type<sup>id</sup></elm-><space-></space->&<elm->name<sup>id</sup></elm->
                        ?<elm->type<sup>id</sup></elm-><space-></space->const<space></space><elm->name<sup>id</sup></elm->
                    </scroll-></code->
                </right->
            </syntax->
            <sep-></sep->

            <p>
                Any function with one or more generic type parameters is considered a template function.<br>
                Generic type parameters are declared in the same way as normal parameters, but the type is replaced by a new identifier preceded by a <code>?</code> token.<br>
                Parameters declared using the same type identifier will always have the same type in any generated function.
            </p>
            <p>
                Generic type parameters can be references or const.
            </p>
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <t->?t</t-> <f->add</f->(<t->?t</t-> <a->a</a->, <t->?t</t-> <a->b</a->){
                            return a + b;
                        }
                        <t->auto</t-> <f->add2</f->(<t->?t</t-> <a->a</a->, <t->?u</t-> <a->b</a->){
                            <w->return</w-> a + b;
                        }

                        <t->void</t-> <f->main</f->(){
                            <f->add</f->(<k->0</k->, <k->1</k->);      <c->// Generates uint add(uint a, uint b)</c->
                            <f->add</f->(<k->1.8</k->, <k->0.4</k->);  <c->// Generates float add(float a, float b)</c->

                            <f->add2</f->(<k->0</k->, <k->1</k->);     <c->// Generates uint add(2uint a, uint b)</c->
                            <f->add2</f->(<k->1</k->, <k->0.4</k->);   <c->// Generates float add2(uint a, float b)</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <sep-></sep->

            <p>
                Templates allow multiple definitions.<br>
                The <code><w->when</w-></code> and <code><w->default</w-></code> keywords are used to assign the correct one to the generated function, depending on the types used in it.
            </p>
            <p>
                The expression used in the <code><w->when</w-></code> specifier must be known in compile time and cannot depend on the value of variables declared inside one of the function definitions.<br>
                Calling the function with types that don't match any definition is a semantic error.<br>
                See <a href="#type-comparison">Type comparison</a>.
            </p>
            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <w->strict</w-> <w->enum</w-> type_id : <t->uint</t-> {
                            floating_point, integral, other;
                        }

                        <t->type_id</t-> <f->get_id</f->(<t->?t</t-> <a->n</a->)
                        <w->when</w->(<t->t</t-> == <t->int</t-> || <t->t</t-> == <t->uint</t->) {
                            <w->return</w-> type_id::<k->integral</k->;
                        }
                        <w->when</w->(<t->t</t-> == <t->float</t-> || <t->t</t-> == <t->double</t->) {
                            <w->return</w-> type_id::<k->floating_point</k->;
                        }
                        <w->default</w-> {
                            <w->return</w-> type_id::<k->other</k->;
                        }


                        <t->void</t-> <f->main</f->(){
                            <f->get_id</f->(<k->-1</k->);      <c->// Returns type_id::integral</c->
                            <f->get_id</f->(<k->0.4</k->);     <c->// Returns type_id::floating_point</c->
                            <f->get_id</f->(<k->1</k->);       <c->// Returns type_id::other</c->
                            <f->get_id</f->((<k->0.4</k->));   <c->// Returns type_id::other</c->
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- The main function                                               -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="the-main-function">The main function</h3>
            <p>
                The <b><code><f->main</f-></code> function</b> is where the <b>code execution starts and ends</b>.<br>
                Every shader <b>must define</b> the <b><code><f->main</f-></code></b> function.<br>
            </p>
            <p>
                The parameters of the <code><f->main</f-></code> are passed from the <a href="./Umbra.html">Umbra Language</a> and contain all the inputs and outputs the shader needs to run and interact with other shaders.<br>
                The <code><f->main</f-></code> function can return any type and take const or reference parameters.<br>
                It can also be called by other functions or itself, but it cannot be a template.<br>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Const qualifier                                                 -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="const-qualifier">Const qualifier</h2>
            <p>
                The <code><t->const</t-></code> qualifier can be used to <b>prevent</b> named values to be <b>modified</b> after their declaration.<br>
                Reference const parameters are not allowed, as well as const functions and const struct members.<br>
            </p>
            <p>
                As opposed to GLSL, const symbols can be initialized using non-const expressions.<br>
                The qualifier doesn't affect compiler optimizations or the GLSL output in any way.
            </p>
            <p>
                Passing a const identifier as argument of reference parameters is not allowed and will result in a semantic error.<br>
                Const variables cannot have undefined value.
            </p>

            <sep-></sep->
            <example->
                <fill->
                    <label- onclick="copy_code(this)"></label->
                    <code-><scroll->
                        <w->struct</w-> <t->s</t-> {
                            <t->uint</t-> a;            <c->// Ok, non-const member</c->
                            <c->//uint const b;    // Error, struct members cannot be const</c->
                        }
                        <t->s const</t-> var;           <c->// Ok, const global variable</c->

                        <c->//double const fun(){}              // Error, functions cannot be const</c->
                        <c->//double fun(double const &arg){}   // Error, references cannot be const</c->

                        <t->double</t-> <f->fun</f->(<t->double</t-> <a->arg</a->) {            <c->// Ok, const parameter</c->
                            <c->//uint const a;                 // Error, uninitialized const</c->
                            <t->uint const</t-> a = <k->4</k->;               <c->// Ok</c->
                            <t->uint const</t-> b = arg, c;          <c->// Ok</c->
                            <c->//a = 2;                        // Error, cannot assign values to const variables</c->
                            c = <k->a</k-> + b;                      <c->// Ok</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#compiler-optimizations">Compiler optimizations</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Symbol aliases                                                  -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="symbol-aliases">Symbol aliases</h2>








            <!--------------------------------------------------------------------->
            <!-- Runtime statements                                              -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="runtime-statements">Runtime statements</h1>




            <!--------------------------------------------------------------------->
            <!-- Left and right values                                           -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="left-and-right-values">Left and right values</h2>




            <!--------------------------------------------------------------------->
            <!-- Expressions                                                     -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="expressions">Expressions</h2>


            <!--------------------------------------------------------------------->
            <!-- Literals                                                        -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="literals">Literals</h3>
            //TODO compile time known values have the same color as literals


            <!--------------------------------------------------------------------->
            <!-- Constructors                                                    -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="constructors">Constructors</h3>
            //TODO CONSTRUCTORS ARE SPECIAL FUNCTIONS


            <!--------------------------------------------------------------------->
            <!-- Operators                                                       -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="operators">Operators</h3>


            <!--------------------------------------------------------------------->
            <!-- Special operators                                               -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="special-operators">Special operators</h3>


            <!--------------------------------------------------------------------->
            <!-- Array operations                                                -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="array-operations">Array operations</h3>


            <!--------------------------------------------------------------------->
            <!-- Type comparison                                                 -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="type-comparison">Type comparison</h3>




            <!--------------------------------------------------------------------->
            <!-- Selection                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="selection">Selection</h2>


            <!--------------------------------------------------------------------->
            <!-- If statement                                                    -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="if-statement">If statement</h3>


            <!--------------------------------------------------------------------->
            <!-- Select statement                                                -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="select-statement">Select statement</h3>




            <!--------------------------------------------------------------------->
            <!-- Iteration                                                       -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="iteration">Iteration</h2>


            <!--------------------------------------------------------------------->
            <!-- For loops                                                       -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="for-loops">For loops</h3>


            <!--------------------------------------------------------------------->
            <!-- While loops                                                     -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="while-loops">While loops</h3>


            <!--------------------------------------------------------------------->
            <!-- Continue and break statements                                   -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="continue-and-break-statements">Continue and break statements</h3>


            <!--------------------------------------------------------------------->
            <!-- Once statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="once-statement">Once statement</h3>


            <!--------------------------------------------------------------------->
            <!-- Then statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-3-></sep-3->
            <h3 id="then-statement">Then statement</h3>




            <!--------------------------------------------------------------------->
            <!-- Else statement                                                  -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="else-statement">Else statement</h2>








            <!--------------------------------------------------------------------->
            <!-- Compilation                                                     -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="compilation">Compilation</h1>




            <!--------------------------------------------------------------------->
            <!-- Modules                                                         -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="modules">Modules</h2>




            <!--------------------------------------------------------------------->
            <!-- Compilation phases and error types                              -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="compilation-phases-and-error-types">Compilation phases and error types</h2>




            <!--------------------------------------------------------------------->
            <!-- Global initialization order                                     -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="global-initialization-order">Global initialization order</h2>




            <!--------------------------------------------------------------------->
            <!-- Branching performance                                           -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="branching-performance">Branching performance</h2>




            <!--------------------------------------------------------------------->
            <!-- Compiler optimizations                                          -->
            <!--------------------------------------------------------------------->
            <sep-2-></sep-2->
            <h2 id="compiler-optimizations">Compiler optimizations</h2>








            <!--------------------------------------------------------------------->
            <!-- Standard modules                                                -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="standard-modules">Standard modules</h1>








            <!--------------------------------------------------------------------->
            <!-- Quick reference tabs                                            -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="quick-reference-tabs">Quick reference tabs</h1>

            //TODO
            //this.x this.y this.z
            this::pos.x
            this::pos.y
            this::pos.z
            ^ coordinates in current workspace




            sequence function //TODO
            sequence(start, end, step)







            <div class="table-container"><table>
                <thead><tr>
                    <th class="center">Precedence</th>
                    <th class="center">Operator</th>
                    <th class="center">Syntax</th>
                    <th class="center">Result</th>
                    <th class="left">Name</th>
                    <th class="left">Category</th>
                </tr></thead>
                <tbody>
                    <tr>
                        <td class="center" >1</td>
                        <td class="center">
                            <elm-><code>(</code><code>)</code></elm->
                        </td>
                        <td class="center nowrap">(<elm-><t->T<sup>r</sup></t-></elm->)</td>
                        <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                        <td class="left">Grouping</td>
                        <td class="left" rowspan=5>Other</td>
                    </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=6>2</td>
                            <td class="center" rowspan=2>
                                <template->-</template-><br>
                                <elm-><code>[</code><code>]</code></elm-><br>
                                <template->with(T == struct_t)</template-><br>
                            </td>
                            <td class="center nowrap"><elm-><t->T[]</t-><sup>r</sup></elm->[<elm-><t->uint</t-><sup>r</sup></elm->]</td>
                            <td class="center"><code><t->T<sup>l</sup></t-></code></td>
                            <td class="left" rowspan=2>Subscription</td>
                        </tr>
                        <tr>
                            <td class="center nowrap"><elm-><t->T</t-><sup>r</sup></elm->[<elm-><t->uint</t-><sup>r</sup></elm->]</td>
                            <td class="center"><code><t->member type<sup>l</sup></t-></code></td>
                        </tr>
                        <tr>
                            <td class="center" rowspan=2>
                                <template->-</template-><br>
                                <code>.</code><br>
                                <template->with(T == struct_t)</template-><br>
                            </td>
                            <td class="center nowrap"><elm-><t->T[]<sup>r</sup></t-></elm->.<elm->member<sup>id</sup></elm-></td>
                            <td class="center"><code><t->T<sup>l</sup></t-></code></td>
                            <td class="left" rowspan=2>Member access</td>
                        </tr>
                        <tr>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm->.<elm->member<sup>id</sup></elm-></td>
                            <td class="center"><code><t->member type<sup>l</sup></t-></code></td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>++</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm->++</td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Postfix increment</td>
                            <td class="left" rowspan=6>Arithmetic</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>--</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm->--</td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Postfix decrement</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=6>3</td>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>++</code>
                            </td>
                            <td class="center nowrap">++<elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Prefix increment</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>--</code>
                            </td>
                            <td class="center nowrap">--<elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Prefix decrement</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>+</code>
                            </td>
                            <td class="center nowrap">+<elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Promotion</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>-</code>
                            </td>
                            <td class="center nowrap">-<elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Inversion</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T == int_t)</template-><br>
                                <code>~</code>
                            </td>
                            <td class="center nowrap">~<elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Bitwise NOT</td>
                            <td class="left">Binary</td>
                        </tr>
                        <tr>
                            <td class="center nowrap"><code>!</code></td>
                            <td class="center">!<elm-><t->bool<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Logical NOT</td>
                            <td class="left">Logical</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=3>4</td>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>*</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &#42; <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Multiplication</td>
                            <td class="left" rowspan=5>Arithmetic</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>/</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> / <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Division</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>%</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> % <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Modulo</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=2>5</td>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>+</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> + <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Addition</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>-</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> - <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Subtraction</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=2>6</td>
                            <td class="center">
                                <template->with(T == int_t)</template-><br>
                                <code>&lt;&lt;</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &lt;&lt; <elm-><t->uint<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><codet->T<sup>r</sup></codet-></code></td>
                            <td class="left">Left bit shift</td>
                            <td class="left" rowspan=2>Binary</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T == int_t)</template-><br>
                                <code>&gt;&gt;</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &gt;&gt; <elm-><t->uint<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                            <td class="left">Right bit shift</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=4>7</td>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>&lt;</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &lt; <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Less than</td>
                            <td class="left" rowspan=8>Comparison</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>&lt;=</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &lt;= <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Less or equal than</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>&gt;</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &gt; <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Greater than</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>&gt;=</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> &gt;= <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Greater or equal than</td>
                        </tr>
                    <!-- -->
                        <tr>
                            <td class="center" rowspan=4>8</td>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>==</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> == <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Equality</td>
                        </tr>
                        <tr>
                            <td class="center">
                                <template->with(T != struct_t)</template-><br>
                                <code>!=</code>
                            </td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> != <elm-><t->T<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Inequality</td>
                        </tr>
                        <tr>
                            <td class="center"><code>=:</code></td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> =: <elm-><t->T[]<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Existence</td>
                        </tr>
                        <tr>
                            <td class="center"><code>!:</code></td>
                            <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> !: <elm-><t->T[]<sup>r</sup></t-></elm-></td>
                            <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                            <td class="left">Inexistence</td>
                        </tr>
                    <tr>
                        <td class="center">9</td>
                        <td class="center">
                            <template->with(T != int_t)</template-><br>
                            <code>&</code>
                        </td>
                        <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> & <elm-><t->T<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                        <td class="left">Bitwise AND</td>
                        <td class="left" rowspan=3>Binary</td>
                    </tr>
                    <tr>
                        <td class="center">10</td>
                        <td class="center">
                            <template->with(T != int_t)</template-><br>
                            <code>^</code>
                        </td>
                        <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> ^ <elm-><t->T<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                        <td class="left">Bitwise XOR</td>
                    </tr>
                    <tr>
                        <td class="center">11</td>
                        <td class="center">
                            <template->with(T != int_t)</template-><br>
                            <code>|</code>
                        </td>
                        <td class="center nowrap"><elm-><t->T<sup>r</sup></t-></elm-> | <elm-><t->T<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                        <td class="left">Bitwise OR</td>
                    </tr>
                    <tr>
                        <td class="center">12</td>
                        <td class="center"><code>&&</code></td>
                        <td class="center nowrap"><elm-><t->bool<sup>r</sup></t-></elm-> && <elm-><t->bool<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                        <td class="left">Logical AND</td>
                        <td class="left" rowspan=3>Logical</td>
                    </tr>
                    <tr>
                        <td class="center">13</td>
                        <td class="center"><code>^^</code></td>
                        <td class="center nowrap"><elm-><t->bool<sup>r</sup></t-></elm-> ^^ <elm-><t->bool<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                        <td class="left">Logical XOR</td>
                    </tr>
                    <tr>
                        <td class="center">14</td>
                        <td class="center"><code>||</code></td>
                        <td class="center nowrap"><elm-><t->bool<sup>r</sup></t-></elm-> || <elm-><t->bool<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->bool<sup>r</sup></t-></code></td>
                        <td class="left">Logical OR</td>
                    </tr>
                    <tr>
                        <td class="center">15</td>
                        <td class="center"><elm-><code>?</code><code>:</code></elm-></td>
                        <td class="center nowrap"><elm-><t->bool<sup>r</sup></t-></elm-> ? <elm-><t->T<sup>r</sup></t-></elm-> : <elm-><t->T<sup>r</sup></t-></elm-></td>
                        <td class="center"><code><t->T<sup>r</sup></t-></code></td>
                        <td class="left">Selection operator</td>
                        <td class="left">Other</td>
                    </tr>
                </tbody>
            </table></div>

            Operators cannot be used as value. Only their members can

            //TODO add with keyword

            //TODO add typographical conventions
            //TODO <sup>r</sup> = rvalue
            //TODO <sup>l</sup> = lvalue
            //TODO <sup>id</sup> = identifier






            <!--------------------------------------------------------------------->
            <!-- Complete examples                                               -->
            <!--------------------------------------------------------------------->
            <sep-1-></sep-1->
            <h1 id="complete-examples">Complete examples</h1>

        </main-scroll->
    </right->
<!-- </main-> -->




<script src="Fix.js" defer></script>
</body>
</html>






<!--
<p>
    Array <b>elements</b> are referenced through their <b>index</b>.<br>
    Negative values are not supported.
</p>
<p>
    One-dimensional arrays with a <b>maximum of 4 elements</b> can use special <b>named identifiers</b> to refer to them.<br>
    Referencing elements of multidimensional arrays require two or more indices.<br>
    Referencing elements that are <b>not</b> in the <b>array range</b> has <b>undefined behaviour</b>.
</p>
| Element | Named identifier 1 | Named identifier 2 |
|:-------:|:------------------:|:------------------:|
| <code>[0]</code>   | <code>x</code>                | <code>r</code>                |
| <code>[1]</code>   | <code>y</code>                | <code>g</code>                |
| <code>[2]</code>   | <code>z</code>                | <code>b</code>                |
| <code>[3]</code>   | <code>w</code>                | <code>a</code>                |
<p>
    //TODO MOVE VALUE LISTS TO #multiple-assignments
    Both named identifiers and indices can be listed to reference multiple elements at once.<br>
    Referencing the same element more than once in a left value is a semantic error. If it happens during runtime, it has undefined behaviour.
</p>

<h5>Syntax</h5>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]</pre>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]<span class="syntax-elm">...</span></pre>
<pre><span class="syntax-elm">symbol identifier</span>.<span class="syntax-elm">named identifier</span><span class="syntax-elm">...</span></pre>

<h5>Example</h5>
```c
void main() { //TODO multidimensional arrays
    uint arr1[5];
    arr1[3] = 0;                // Ok, arr1 = (?, ?, ?, 0, ?)
    //arr1[5] = 0;              // Undefined behaviour, index 5 is out of range
    //arr1.a = 0;               // Error, arrays with more than 5 elements don't have named identifiers

    //uint arr2[] = arr1[0, 1, 2, 3];    // Error, some of these elements are not initialized
    arr1[0, 1, 4] = 2;                  // Ok, arr1 =(2, 2, ?, 0, 2)
    uint arr2[] = arr1[0, 1, 4, 3];      // Ok, arr2 = (2, 2, 2, 0)

    uint arr2.b = 9;                     // Ok, arr2 = (2, 2, 9, 0)
    arr2.xyz = arr2.zrz;                // Ok, arr1 = (0, 2, 0, 0)
    arr2.wyrb *= 3;                     // Ok, arr1 = (0, 6, 0, 0)
    //arr2.xyz = arr2.zrga;             // Error, the arrays have different length
    //arr2.yy = arr2.xx;                // Error, element [0] referenced twice in left value
    //arr2.yy = arr2.xa;                // Error, element [0] referenced twice in left value
}
```




<p>Althought the file extension is only a convention and can be changed or omitted, it is still recommended to use the correct one, as some softwares may use it to determine the language of the source file.</p>


//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
//TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE