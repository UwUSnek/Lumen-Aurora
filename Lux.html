<!DOCTYPE html>
<html>
<head>
    <title>Lux language</title>
    <meta charset="UTF-8">
    <meta name="author" content="//TODO">
    <meta name="description" content="//TODO">

    <link rel="stylesheet" type="text/css" href="Style.css" media="screen">
    <style>
        .table-1-container {
            white-space: nowrap;
            padding: 0;
            margin: 0;
            min-width: 100%;
            border-radius: 10px 0 0 0;
            overflow: hidden;
            word-spacing: -9999ch;
            text-align: center;
        }.table-1-right-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: calc(100% - 24ch);
        }.table-1-right {
            border-radius: 0 10px 10px 0;
            word-spacing: var(--word-spacing);
        }.table-1-left-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: 24ch;
            border-bottom-left-radius: 10px;
        }.table-1-left {
            border-radius: 10px 0 0 10px;
            word-spacing: var(--word-spacing);
        }.table-1-y {
            background-color: hsla(115, 100%, 24%, 0.227);
        }.table-1-n {
            background-color: hsla(0, 100%, 24%, 0.227);
        }
    </style>
</head>
<body>
<div class="main-container hide-scrollbar">
    <div class="main-left-container hide-scrollbar">
        <ul style="padding-left:0;" class="index">
            <li class="index-section" style="margin-top: 0px;">Preprocessor
                <ul>
                    <a href="#include-statement"><li>Include statement</li></a>
                    <a href="#macros"><li>Macros //TODO</li></a>
                    <a href="#conditionals"><li>Conditionals //TODO</li></a>
                    <a href="#line-continuation-token"><li>Line continuation token</li></a>
                </ul>
            </li>
            <li class="index-section">Language components
                <ul>
                    <a href="#tokens-and-identifiers"><li>Tokens and identifiers</li></a>
                    <a href="#scopes-and-symbols"><li>Scopes and symbols</li></a>
                    <a href="#namespaces"><li>Namespaces</li></a>
                    <a href="#types"><li>Types
                        <ul>
                            <a href="#primitive-types"><li>Primitive types</li></a>
                            <a href="#enums"><li>Enums</li></a>
                            <a href="#structs"><li>Structs</li></a>
                            <a href="#arrays"><li>Arrays</li></a>
                            <a href="#implicit-conversions"><li>Implicit conversions</li></a>
                            <a href="#auto-specifier"><li>Auto specifier</li></a>
                            <a href="#typeof-and-baseof-specifiers"><li>Typeof and baseof specifiers</li></a>
                        </ul>
                    </li></a>
                    <a href="#variables"><li>Variables
                        <ul>
                            <a href="#temporary-variables"><li>Temporary variables</li></a>
                        </ul>
                    </li></a>
                    <a href="#functions"><li>functions
                        <ul>
                            <a href="#parameters-and-references"><li>Parameters and references</li></a>
                            <a href="#return-statement"><li>Return statement</li></a>
                            <a href="#function-calls"><li>Function calls</li></a>
                            <a href="#template-functions"><li>Template functions</li></a>
                            <a href="#type-groups"><li>Type groups</li></a>
                        </ul>
                    </li></a>
                    <a href="#const-qualifier"><li>Const qualifier</li></a>
                    <a href="#symbol-aliases"><li>Symbol aliases</li></a>
                </ul>
            </li>
            <li class="index-section">Runtime statements
                <ul>
                    <a href="#left-and-right-values"><li>Left and right values</li></a>
                    <a href="#expressions"><li>Expressions
                        <ul>
                            <a href="#literals"><li>Literals</li></a> //TODO compile time known values have the same color of literals
                            <a href="#constructors"><li>Constructors</li></a>
                            <a href="#operators"><li>Operators</li></a>
                            <a href="#special-operators"><li>Special operators</li></a>
                            <a href="#array-operations"><li>Array operations</li></a>
                        </ul>
                    </li></a>
                    <a href="#assignments"><li>Assignments
                        <ul>
                            <a href="#composite-assignments"><li>Composite assignments</li></a>
                            <a href="#multiple-assignments"><li>Multiple assignments</li></a>
                        </ul>
                    </li></a>
                    <a href="#selection"><li>Selection
                        <ul>
                            <a href="#if-statement"><li>If statement</li></a>
                            <a href="#select-statement"><li>Select statement</li></a>
                        </ul>
                    </li></a>
                    <a href="#iteration"><li>Iteration
                        <ul>
                            <a href="#for-loops"><li>For loops</li></a>
                            <a href="#while-loops"><li>While loops</li></a>
                            <a href="#continue-and-break-statements"><li>Continue and break statements</li></a>
                            <a href="#once-statement"><li>Once statement</li></a>
                            <a href="#then-statement"><li>Then statement</li></a>
                        </ul>
                    <a href="#else-statement"><li>Else statement</li></a>
                    </li></a>
                </ul>
            </li>
            <li class="index-section">Compilation
                <ul>
                    <a href="#modules"><li>Modules</li></a>
                    <a href="#compilation-phases-and-error-types"><li>Compilation phases and error types</li></a>
                    <a href="#global-initialization-order"><li>Global initialization order</li></a>
                    <a href="#branching-performance"><li>Branching performance</li></a>
                    <a href="#compiler-optimizations"><li>Compiler optimizations</li></a>
                </ul>
            </li>
            <li class="index-section">Standard modules
                <ul>
                    <a href=#""><li>idk</li></a>
                </ul>
            </li>
        </ul>
    </div>
    <div style="width: 1px; height: 100%; background-color: var(--separator-color);"></div>
    <div class="main-right-container">
        <div style="background-color: var(--bg-color); width: 100%; height: var(--main-padding); position: fixed; z-index: -1;"></div>
        <div class="parallax" style="background-image: url('Lux-logo.png'); position: relative; z-index: -2; margin-bottom: var(--main-padding);"></div>
        <h1>Lux - Lynx shading language</h1><br><br>
        <p>Lux is a <b>high level compiled shading language</b> based on <b>GLSL 4.6</b>, with the aim of helping developers to efficiently write shaders without going through the tedious work of manually managing arrays and interfaces.</p>
        <p>
            The language features <b>C-like syntax</b> and semantics.<br>
            Additional constructs and keywords allow for better abstraction on data types and a more direct approach to flow control and better control over multidimensional data.
        </p>
        <p>Lux is meant to be used alongside <b>Umbra</b>, the main programming language of the Lynx Engine, as it is highly compatible and interfacing shaders requires little to no effort.</p>
        <p>Lux is part of the <b>Lynx SDK</b>.</p>
        <p><a href="#quick-reference-tabs">Quick reference tabs</a></p>








        <!--------------------------------------------------------------------->
        <!-- Preprocessor                                                    -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1 id=preprocessor>Preprocessor</h1>
        <p>
            As in the C language, the preprocessing phase is performed <b>before</b> compiling the code.<br>
            It removes comments and evaluates preprocessor directives and line continuation tokens.
        </p>
        <p>
            Preprocessor directives are special instructions that allow the code to be programmatically modified.<br>
            All the preprocessor directives are identified by the <code>#</code> character followed by their name and definition.<br>
            Each directive spans over a single, complete line of code.<br>
            Preprocessor directives are always <b>case sensitive</b>.
        </p>




        <!--------------------------------------------------------------------->
        <!-- Comments                                                        -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id=comments>Comments</h2>
        <p>
            Comments are portions of code that are purposely ignored.<br>
            They can be used to provide informations or temporarily exclude lines of code.<br>
            Comments are allowed to contain any sequence of unicode characters of any length.<br>
        </p>
        <p>
            Single line comments start with <code>//</code> and end at the first newline character<br>
            Multiline comments start with <code>/*</code> and end with <code>*/</code>
        </p>

        <div class="fancy-code-label">Syntax 1</div>
        <pre class="fancy-code-single-line">//<span class="syntax-elm">Comment string</span><span class="hidden">↩</span></pre>
        <div class="fancy-code-label">Syntax 2</div>
        <pre class="fancy-code-single-line">/*<span class="syntax-elm">Comment string</span>*/</pre>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-comment">// Single line comment</span>

            <span class="lynx-comment">/* Multi
            line
            comment */</span>
        </pre></div>




        <!--------------------------------------------------------------------->
        <!-- Include statement                                               -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id=include-statement>Include statement</h2>
        <p>
            Include statements are used to <b>paste code</b> from other files.<br>
            Any existent file can be included, regardless of its contents or extension.<br>
            The path to the included file must be enclosed in <code>"</code><code>"</code> and can only contain alphanumeric characters, dots and slashes. //TODO <br>
            Both <b>absolute</b> and <b>relative</b> paths are supported.
        </p>
        <div class="fancy-code-label">Syntax 1</div>
        <pre class="fancy-code-single-line">#include<span class="hidden">·</span>"<span class="syntax-elm">absolute/path/to/file</span>"<span class="hidden">↩</span></pre>
        <div class="fancy-code-label">Syntax 2</div>
        <pre class="fancy-code-single-line">#include<span class="hidden">·</span>"./<span class="syntax-elm">relative/path/to/file</span>"<span class="hidden">↩</span></pre>
        <div class="fancy-code-label">Syntax 3</div>
        <pre class="fancy-code-single-line">#include<span class="hidden">·</span>"<span class="syntax-elm">relative/path/to/file</span>"<span class="hidden">↩</span></pre>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-comment">// Ok</span>
            <span class="lynx-keyword">#include</span> <span class="lynx-string">"/home/Lynx/Lux/file.ilsh"</span>
            <span class="lynx-keyword">#include</span> <span class="lynx-string">"./file.ilsh"</span>
            <span class="lynx-keyword">#include</span> <span class="lynx-string">"file.ilsh"</span>

            <span class="lynx-comment">// Error</span>
            <span class="lynx-comment">//#include ./file.ilsh</span>
            <span class="lynx-comment">//#include "./non_existent_file"</span>
            <span class="lynx-comment">//#include ""</span>
        </pre></div>




        <!--------------------------------------------------------------------->
        <!-- Macros                                                          -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="macros">Macros</h2>




        <!--------------------------------------------------------------------->
        <!-- Conditionals                                                    -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="conditionals">Conditionals</h2>




        <!--------------------------------------------------------------------->
        <!-- Line continuation token                                         -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="line-continuation-token">Line continuation token</h2>
        <p>
            The line continuation token can be used to merge multiple lines and allow single line comments, preprocessor directives and multi character tokens to be written across multiple lines.<br>
            It consists of a <code>\</code> <b>immediatly</b> followed by a <b>newline character</b>.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line">\<span class="hidden">↩</span></pre>

        <div class="fancy-code-label">These are all allowed</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-comment">// single line comment</span>\
            <span class="lynx-comment">on two lines</span>

            <span class="lynx-comment">// #include "path/to/file"</span>
            <span class="lynx-keyword">#include</span> <span class="lynx-string">"pat</span>\
            <span class="lynx-string">h/to/file</span>\
            <span class="lynx-string">"</span>

            <span class="lynx-comment">// void function() {
            //   uint var = 0, b = 0;
            //   var += b;
            // }</span>
            <span class="lynx-type">vo</span>\
            <span class="lynx-type">id</span> <span class="lynx-func">fun</span>\
            <span class="lynx-func">ction</span>() {
            <span class="lynx-type">uint</span> va\
            r = <span class="lynx-literal">0</span>, b = <span class="lynx-literal">0</span>;
            v\
            ar +\
            = <span class="lynx-literal">b</span>;
            }
        </pre></div>







        <!--------------------------------------------------------------------->
        <!-- Language components                                             -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1>Language components</h1>




        <!--------------------------------------------------------------------->
        <!-- Tokens and identifiers                                          -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="tokens-and-identifiers">Tokens and identifiers</h2>
        <p>
            Any sequence of one or more characters that is left after the preprocessing phase and is recognizable according to the grammar of the language is called a token.<br>
            Comments and whitespace characters can be freely written between two tokens without altering the GLSL output.<br>
            Tokens are always <b>case sensitive</b>.<br>
            Comments, newline characters, whitespace characters and preprocessor directives are <b>not tokens</b>.
        </p>

        <p>Each token can be classified as one of the following:</p>
        <div class="table-container"><table>
            <thead>
                <tr>
                    <th>Type</th>
                    <th style="text-align: center;" colspan=4>Pattern</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Identifier</td>
                    <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code>, <code>$</code> and <code>_</code> that doesn't start with a decimal digit</td>
                </tr>
                <tr>
                    <td>Literal</td>
                    <td class="center" colspan=4>Any sequence of <code>alphanumeric characters</code> and <code>.</code> that starts with a decimal digit</td>
                </tr>
                <tr>
                    <td>Keyword</td>
                    <td class="center" colspan=2>
                        <code class="lynx-keyword">namespace</code>
                        <code class="lynx-keyword">enum</code>
                        <code class="lynx-keyword">struct</code>
                        <code class="lynx-keyword">auto</code>
                        <code class="lynx-type">typeof</code>
                        <code class="lynx-type">baseof</code>
                        <code class="lynx-keyword">typegroup</code>
                        <code class="lynx-type">const</code>
                        <code class="lynx-keyword">alias</code>
                    </td>
                    <td class="center" colspan=2>
                        <code class="lynx-keyword">if</code>
                        <code class="lynx-keyword">select</code>
                        <code class="lynx-keyword">for</code>
                        <code class="lynx-keyword">while</code>
                        <code class="lynx-keyword">do</code>
                        <code class="lynx-keyword">continue</code>
                        <code class="lynx-keyword">break</code>
                        <code class="lynx-keyword">once</code>
                        <code class="lynx-keyword">then</code>
                        <code class="lynx-keyword">else</code>
                        <code class="lynx-keyword">return</code>
                    </td>
                </tr>
                <tr>
                    <td>Operator</td>
                    <td class="center">
                        <code>!</code>
                        <code>==</code>
                        <code>!=</code>
                        <code>:=</code>
                        <code>&&</code>
                        <code>^^</code>
                        <code>||</code>
                        <code>&lt;</code>
                        <code>&lt;=</code>
                        <code>&gt;</code>
                        <code>&gt;=</code>
                    </td>
                    <td class="center">
                        <code>+</code>
                        <code>-</code>
                        <code>++</code>
                        <code>--</code>
                        <code>*</code>
                        <code>/</code>
                        <code>%</code>
                    </td>
                    <td class="center">
                        <code>&</code>
                        <code>|</code>
                        <code>^</code>
                        <code>&lt;&lt;</code>
                        <code>&gt;&gt;</code>
                        <code>~</code>
                    </td>
                    <td class="center wide-lines">
                        <span class="syntax-elm"><code>(</code><code>)</code></span>
                        <span class="syntax-elm"><code>[</code><code>]</code></span>
                        <code>.</code>
                        <span class="syntax-elm"><code>?</code><code>:</code></span>
                    </td>
                </tr>
                <tr>
                    <td>Punctuation tokens</td>
                    <td class="center wide-lines" width="20%">
                        <span class="syntax-elm"><code>(</code><code>)</code></span>
                        <span class="syntax-elm"><code>{</code><code>}</code></span>
                        <span class="syntax-elm"><code>[</code><code>]</code></span>
                    </td>
                    <td class="center" width="20%">
                        <code>,</code>
                        <code>;</code>
                        <code>|</code>
                        <code>::</code>
                    </td>
                    <td class="center" width="20%"><code>&</code></td>
                    <td class="center" width="20%"><code>:</code></td>
                </tr>
                <tr>
                    <td>Assignment token</td>
                    <td class="center"><code>=</code></td>
                    <td class="center">
                        <code>+=</code>
                        <code>*=</code>
                        <code>-=</code>
                        <code>/=</code>
                        <code>%=</code>
                    </td>
                    <td class="center" colspan=2><div style="width: 50%;">
                        <code>&=</code>
                        <code>|=</code>
                        <code>^=</code>
                        <code>&lt;&lt;=</code>
                        <code>&gt;&gt;=</code>
                    </div></td>
                </tr>
            </tbody>
        </table></div>
        <p>
            Identifiers are used to name functions, variables, structs, aliases, type groups and namespaces.<br>
            They must be unique to the current scope and not overlap with keywords.<br>
            Temporary variables are the only identifiers that are allowed to start with a <code>$</code>.
        </p>
        <p>
            See
            <a href="#literals">Literals</a>,
            <a href="#operators">Operators</a>,
            <a href="#scopes">Scopes</a>
        </p>




        <!--------------------------------------------------------------------->
        <!-- Scopes and symbols                                              -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="scopes-and-symbols">Scopes and symbols</h2>
        <p>A symbol is any identifier that can be referenced unambiguously through its absolute name.</p>
        <p>
            Scopes define which <b>symbols</b> the code can <b>reference</b> and their absolute and relative names.<br>
            Any portion of code enclosed in <code>{</code><code>}</code> defines a new scope. This includes <code>functions</code>, <code>structs</code>, <code>namespaces</code>, <code>unnamed scopes</code> and <code>runtime statements</code>.<br>
            The only exception is the <b>module scope</b>. It contains all the symbols and scopes declared in the module and can be referenced using the <code>this</code> keyword.
        </p>
        <p>
            Each scope can only contain certain types of symbols:
        </p>

        <div class="table-1-container">
            <div class="table-container table-1-left-container"><table class="table-1-left">
                <tr style="height: 80px;"><th>Container scope</th></tr>
                <tr style="height: 80px;"><th>Module</th></tr>
                <tr style="height: 80px;"><th>Namespace</th></tr>
                <tr style="height: 80px;"><th>Enum</th></tr>
                <tr style="height: 80px;"><th>Struct</th></tr>
                <tr style="height: 80px;"><th>Function</th></tr>
                <tr style="height: 80px;"><th>Runtime statement</th></tr>
            </table></div>
            <div class="table-container table-1-right-container"><table class="table-1-right">
                <tr style="height: 80px;">
                    <td>Variable</td>
                    <td>Type group</td>
                    <td>Runtime statement</td>
                    <td>Function parameter</td>
                    <td>Enum element</td>
                    <td>Struct element</td>
                    <td>Struct</td>
                    <td>Enum</td>
                    <td>Namespace</td>
                    <td>Symbol alias</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
                <tr style="height: 80px;">
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-n">No</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                    <td class="table-1-y">Yes</td>
                </tr>
            </table></div>
        </div>
        <p>
            Local names are used to reference identifiers declared in the current scope or one of the enclosing scopes.<br>
            Relative names, instead, can reference any symbol declared in the module. They consist of the names of the enclosing scopes and the identifier of the symbol separated by <code>::</code> tokens.<br>
            A relative name that starts from the module scope is called an absolute name.
        </p>
        <p>
            Identifiers declared in unnamed scopes cannot be referenced from outside.<br>
            Declaring a symbol with the same identifier as one in an enclosing scope will shadow the old identifier, and any use of the identifier in the current and sub scopes will refer to the new symbol.<br>
            Declaring the same identifier more than once in the same scope is only allowed for function overloading. Anything else is a semantic error.<br>
        </p>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-comment">// Module scope</span>
            <span class="lynx-comment">// Local name: this</span>


            <span class="lynx-comment">// Local name: s</span>
            <span class="lynx-comment">// Relative names: this::s</span>
            <span class="lynx-keyword">struct</span> <span class="lynx-type">s</span> { <span class="lynx-type">uint</span> n; }</span>

            <span class="lynx-comment">// Unnamed, cannot be referenced from outside</span>
            <span class="lynx-keyword">namespace</span> {
                <span class="lynx-comment">// Local name: fun</span>
                <span class="lynx-type">void</span> <span class="lynx-func">fun</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">n</span>) {}
            }


            <span class="lynx-comment">// Local name: fun</span>
            <span class="lynx-comment">// Relative names: this::fun</span>
            <span class="lynx-type">void</span> <span class="lynx-func">fun</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">n</span>) {
                <span class="lynx-comment">// Unnamed, cannot be referenced from outside</span>
                <span class="lynx-keyword">if</span>(n){
                    <span class="lynx-comment">// Local name: s2</span>
                    <span class="lynx-keyword">struct</span> <span class="lynx-type">s2</span></span> { <span class="lynx-type">uint</span> n; };
                }

                <span class="lynx-comment">// Local name: s, shadows this::s</span>
                <span class="lynx-comment">// Relative names: this::fun::s, fun::s</span>
                <span class="lynx-keyword">struct</span> <span class="lynx-type">s</span></span> { <span class="lynx-type">uint</span> a, b; }
            }
        </pre></div>
        <p>
            See
            <a href="#namespaces">Namespaces</a>,
            <a href="#variables">Variables</a>,
            <a href="#functions">Functions</a>,
            <a href="#structs">Structs</a>,
            <a href="#enums">Enums</a>,
            <a href="#selection">Selection</a>,
            <a href="#iteration">Iteration</a>,
            <a href="#else-statement">Else statement</a>,
            <a href="#symbol-aliases">Symbol aliases</a>
        </p>




        <!--------------------------------------------------------------------->
        <!-- Namespaces                                                      -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="namespaces">Namespaces</h2>
        <p>
            Namespaces are used to create named scopes which can contain variables, functions, enums, structs and symbol aliases.<br>
            They don't affect the runtime behaviour and can be declared in any scope.<br>
            Unnamed namespaces are allowed.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line">namespace<span class="hidden">·</span><span class="syntax-elm">symbol identifier</span> {<span class="syntax-elm">...</span>}</pre>
        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line">namespace {<span class="syntax-elm">...</span>}</pre>
        <p>
            See
            <a href="#variables">Variables</a>,
            <a href="#functions">Functions</a>,
            <a href="#structs">Structs</a>,
            <a href="#enums">Enums</a>,
            <a href="#symbol-aliases">Symbol aliases</a>
        </p>




        <!--------------------------------------------------------------------->
        <!-- Types                                                           -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="types">Types</h2>
        <p>
            Data types define the way runtime values are interpreted and how they can be used within expressions.<br>
            Lux features five primitives types, which can be used to define more complex types such as structs, arrays and enums.
        </p>
        <p>
            Every value has an associated type, regardless of it being a right or a left value.<br>
            Like any symbol, declearing a new type or other symbols will shadow the ones that were declared in the enclosing scopes using the same identifier.<br>
            Primitive types can also be shadowed and they behave as if they were declared in the module namespace.
        </p>


        <!--------------------------------------------------------------------->
        <!-- Primitive types                                                 -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="primitive-types">Primitive types</h3>

        <p>The primitive types are:</p>
        <div class="table-container"><table>
            <tr>
                <th>Lux type               </th>
                <th>Actual GLSL type       </th>
                <th>C equivalent           </th>
                <th>Description            </th>
            </tr>
            <tr>
                <td><code class="lynx-type">uint</code>  </td>
                <td>uint                   </td>
                <td>unsigned int           </td>
                <td>32 bit unsigned integer</td>
            </tr>
            <tr>
                <td><code class="lynx-type">int</code>   </td>
                <td>int                    </td>
                <td>int                    </td>
                <td>32 bit signed integer  </td>
            </tr>
            <tr>
                <td><code class="lynx-type">float</code> </td>
                <td>float                  </td>
                <td>float                  </td>
                <td>32 bit floating point  </td>
            </tr>
            <tr>
                <td><code class="lynx-type">double</code></td>
                <td>double                 </td>
                <td>double                 </td>
                <td>64 bit floating point  </td>
            </tr>
            <tr>
                <td><code class="lynx-type">bool</code>  </td>
                <td>bool                   </td>
                <td>-                      </td>
                <td>Boolean value. <code class="lynx-literal">true</code> or <code class="lynx-literal">false</code> </td>
            </tr>
        </table></div>
        <p>
            As in most programming languages, the boolean <code class="lynx-literal">true</code> and <code class="lynx-literal">false</code> values correspond to the integer literals <code class="lynx-literal">1</code> and <code class="lynx-literal">0</code> and they can be used interchangeably.<br>
            Unsigned integers can't hold negative values, but the maximum value is twice as high as their signed counterpart.<br>
            There are no 64 bit integers as they aren't a standard type in GLSL.
        </p>
        <p>
            See
            <a href="#values">Values</a>,
            <a href="#literals">Literals</a>,
            <a href="#implicit-conversions">Implicit conversions</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Enums                                                           -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="enums">Enums</h3>
        <p>
            Enums are used to name and group literal constants of the same type.<br>
            The base type of the enum can be specified after its name and it must be one of the primitive types.<br>
            Elements are declared in the same way as variables, but neither the type nor the const qualifier are specified explicitly.<br>
            The values of each variable are implicitly converted to the base type of the enum.
        </p>
        <p>
            Elements of integer enums which are not initizlied will have the value of the preceeding element + 1, or 0 if they are the first.<br>
            Elements of bool and float enums must always be initialized.<br>
            Multiple elements can have the same value, but each element can only be defined once.<br>
            Enums with no elements are not allowed.
        </p>
        <p>
            Enums can be referenced before their definition.<br>
            It is allowed to declare structures, enums and symbol aliases inside an enum.<br>
            The name of the enum can be used as a type to prevent unknown values to be saved in it.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line wide-lines">
            enum<span class="hidden">·</span><span class="syntax-elm">symbol identifier</span> : <span class="syntax-elm lynx-type">T</span> {
                <span class="syntax-elm">element identifier</span> = <span class="syntax-elm"><span class="lynx-type">T</span> expression</span>;
                <span class="syntax-elm">...</span>
            }
        </pre></div>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-keyword">enum</span> : <span class="lynx-type">uint</span> {                   <span class="lynx-comment">// Ok, unnamed enum</span>
                value_1,        value_2;    <span class="lynx-comment">// Ok, value_1 = 0,    value_2 = 1</span>
                value_3 = <span class="lynx-literal">9999</span>, value_4;    <span class="lynx-comment">// Ok, value_3 = 9999, value_4 = 10000</span>

                <span class="lynx-keyword">struct</span> <span class="lynx-type">s</span> { <span class="lynx-comment">                 // Ok, but this struct is unaccessible. It will generate a warning</span>
                    <span class="lynx-type">uint</span> n1;
                    <span class="lynx-type">c</span>   n2;
                }

                value_5;                    <span class="lynx-comment">// Ok, value_5 = 10001</span>
            }

            <span class="lynx-keyword">enum</span> <span class="lynx-type">c</span> : <span class="lynx-type">double</span> {
                pi          = <span class="lynx-literal">3.14159</span>;      <span class="lynx-comment">// Ok</span>
                e           = <span class="lynx-literal">2.71828</span>,      <span class="lynx-comment">// Ok</span>
                another_e,  = <span class="lynx-literal">2.71828</span>;      <span class="lynx-comment">// Ok</span>
                another_e_2 = <span class="lynx-literal">e</span>;            <span class="lynx-comment">// Ok</span>
                another_e_3 = <span class="lynx-literal">this::c::e</span>;   <span class="lynx-comment">// Ok, used absolute name</span>
                <span class="lynx-comment">//invalid_val;              // Error, uninitialized double enum value</span>
            }

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">c</span> n1 = <span class="lynx-literal">3.14159</span>;             <span class="lynx-comment">// Ok</span>
                <span class="lynx-comment">//c n2 = 5;                 // Error, unknown this::c value</span>
            }
        </pre></div>
        <p>
            When an enum doesn't have to be explicitly referenced more than once, unnamed enums can be used to define both the type and the symbol in the same construct.<br>
            Similarly to the C syntax, the name is not specified and the enum definition is used as type of the symbol.
        </p>
        <p>
            The elements and the enum can still be referenced through the <code class="lynx-type">typeof</code> specifier.<br>
            Defining an unnamed enum without declaring a symbol is allowed, but it will generate a warning as it its elements are unaccessible and the symbol hiding mechanic can be achieved through unnamed namespaces.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line wide-lines">
            enum : <span class="syntax-elm lynx-type">T</span> {
                <span class="syntax-elm">element identifier</span> = <span class="syntax-elm"><span class="lynx-type">T</span> expression</span>;
                <span class="syntax-elm">...</span>
            } <span class="syntax-elm">symbol identifier</span>;
        </pre></div>
        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-keyword">enum</span> : <span class="lynx-type">bool</span> {
                on = <span class="lynx-literal">true</span>;
                off = <span class="lynx-literal">false</span>;
            } grasses;

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                self.grasses = <span class="lynx-literal">typeof(grasses)::on</span>;
            }
        </pre></div>
        <p>
            See
            <a href="#typeof-and-baseof-specifier">Typeof and baseof specifiers</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Structs                                                         -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="structs">Structs</h3>
        <p>
            Structs are used to group multiple values of different types.<br>
            The members are declared in the same way as variables, and they can be of any type, including enums, arrays and other structures.<br>
            A member cannot be const and cannot have an initializer value.<br>
            Like variables, uninitialized members cannot be used within expressions. Struct values must also be fully initialized before they can be used in expressions.
        </p>
        <p>
            Structs can be referenced before their definition.<br>
            It is allowed to declare structures, enums and symbol aliases inside a struct.<br>
            Empty structs are not allowed.
        </p>
        <p>
            Member access is explained in <a href="#special-operators">Special operators</a>
            //TODO MOVE VALUE LISTS TO #multiple-assignments
        </p>

        <div class="fancy-code-label">Syntax</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line wide-lines">
            struct<span class="hidden">·</span><span class="syntax-elm">symbol identifier</span> {
                <span class="syntax-elm lynx-type">member type</span><span class="hidden">·</span><span class="syntax-elm">member identifier</span>;
                <span class="syntax-elm">...</span>
            }
        </pre></div>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-keyword">struct</span> <span class="lynx-type">idk</span> {
                <span class="lynx-type">uint</span> a, b;
                <span class="lynx-type">double</span> c;
            }


            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">i</span>){
                <span class="lynx-type">idk</span> var;

                var.a = <span class="lynx-literal">4</span>;              <span class="lynx-comment">// Ok, var = (4, ?, ?)</span>
                var.b = <span class="lynx-literal">var.a</span> * <span class="lynx-literal">4</span>;      <span class="lynx-comment">// Ok, var = (4, 8, ?)</span>
                var[<span class="lynx-literal">2</span>] = <span class="lynx-literal">0.33</span>;          <span class="lynx-comment">// Ok, var = (4, 8, 0.33)</span>
                var[<span class="lynx-literal">2</span>, <span class="lynx-literal">0</span>] = <span class="lynx-literal">var</span>[<span class="lynx-literal">3</span>, <span class="lynx-literal">2</span>];  <span class="lynx-comment">// Ok, var = (4, ?, ?)</span>
                <span class="lynx-comment">//var[4] = 0.33;        // Error, invalid index</span>
                <span class="lynx-comment">//var[i] = 0.33;        // Error, unknown index</span>
            }
        </pre></div>
        <p>
            Like enums, structs can also be unnamed and their symbol and members types can be referenced through `typeof`.<br>
            Defining unnamed structs without a symbol declaration will also generate a warning.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line wide-lines">
            struct {
                <span class="syntax-elm lynx-type">member type</span><span class="hidden">·</span><span class="syntax-elm">member identifier</span>;
                <span class="syntax-elm">...</span>
            } <span class="syntax-elm">symbol identifier</span>;
        </pre></div>
        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-keyword">struct</span> {
                <span class="lynx-type">uint</span> a, b;
                <span class="lynx-keyword">enum</span> {
                    idk1;
                    idk2;
                } c;
            } var;

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-comment">// Both are allowed</span>
                var.c = <span class="lynx-type">typeof</span>(var.c)::<span class="lynx-literal">idk1</span></span>;
                var.c = <span class="lynx-type">typeof</span>(<span class="lynx-type">typeof</span>(var)::c)::<span class="lynx-literal">idk2</span></span>;

                <span class="lynx-type">typeof</span>(var.a) _a = <span class="lynx-literal">0</span>;
            }
        </pre></div>
        <p>
            See
            <a href="#arrays">Arrays</a>
            <a href="#typeof-and-baseof-specifiers">Typeof and baseof specifiers</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Arrays                                                          -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="arrays">Arrays</h3>
        <p>
            Arrays can aggregate values of the same type.<br>
            Functions, parameters, right values, variables and struct member can all have array type.
        </p>
        <p>
            Arrays can use any base type, including structs, enums and other arrays.<br>
            An array of arrays is called a multidimensional array. There is no limit to the number of dimensions an array can have.<br>
        </p>
        <p>
            Array declarations are identical to normal types, but <code>[</code><code>]</code> tokens follow the type, optionally enclosing an expression to specify the number of elements.<br>
            Arrays can be initialized using any expression of a type that can be implicitly converted.<br>
            If the <code>[</code><code>]</code> are left empty, the number of elements is determined by the inizializer value, which becomes required and must be of an implicitly convertible array type.
        </p>
        <p>
            There are no dynamic arrays.
        </p>
        <p>
            Member access is explained in <a href="#special-operators">Special operators</a>
            //TODO MOVE VALUE LISTS TO #multiple-assignments
        </p>

        <div class="fancy-code-label">Syntax 1</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span>[<span class="syntax-elm"><span class="lynx-type">uint</span> expression</span>]<span class="hidden">·</span><span class="syntax-elm">symbol identifier</span>;</pre>
        <div class="fancy-code-label">Syntax 2</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span>[<span class="syntax-elm"><span class="lynx-type">uint</span> expression</span>]<span class="hidden">·</span><span class="syntax-elm">symbol identifier</span> = <span class="syntax-elm"><span class="lynx-type">T[]</span> expression</span>;</pre>
        <div class="fancy-code-label">Syntax 3</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span>[] <span class="syntax-elm">symbol identifier</span> = <span class="syntax-elm"><span class="lynx-type">T[]</span> expression</span>;</pre>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">uint</span>[<span class="lynx-literal">4</span>] arr1    = (<span class="lynx-literal">1</span>, <span class="lynx-literal">2</span>, <span class="lynx-literal">3</span>, <span class="lynx-literal">4</span>);  <span class="lynx-comment">// Ok, arr1 = (1,  2,   3, 4)</span>
            <span class="lynx-type">uint</span>[<span class="lynx-literal">2</span>][<span class="lynx-literal">2</span>] arr2 = (<span class="lynx-literal">1</span>, <span class="lynx-literal">2</span>, <span class="lynx-literal">3</span>, <span class="lynx-literal">4</span>);  <span class="lynx-comment">// Ok, arr2 = ((1, 2), (3, 4)). Explained in Constructors</span>
            <span class="lynx-type">uint</span>[<span class="lynx-literal">2</span>][<span class="lynx-literal">2</span>] arr3 = <span class="lynx-literal">arr1</span>;          <span class="lynx-comment">// Ok, arr3 = ((1, 2), (3, 4)). Explained in Constructors</span>
            <span class="lynx-type">uint</span>[<span class="lynx-literal">5</span>] arr4 = <span class="lynx-literal">1</span>;                <span class="lynx-comment">// Ok, arr4 = (1, 1, 1, 1, 1)</span>
            <span class="lynx-type">uint</span>[] arr5 = (<span class="lynx-literal">8</span>, <span class="lynx-literal">7</span>, <span class="lynx-literal">6</span>);         <span class="lynx-comment">// Ok, arr5 = (8,  7,  6)</span>
            <span class="lynx-type">uint</span>[] arr6 = <span class="lynx-literal">arr4</span> * <span class="lynx-literal">2</span>;          <span class="lynx-comment">// Ok, arr6 = (16, 14, 12)</span>

            <span class="lynx-comment">//uint[4] arr1 = (1, 2, 3);      // Error, inizializer doesn't have enough elements</span>
            <span class="lynx-comment">//uint[] arr1  = 1;              // Error, cannot determine the array size</span>
        </pre></div>
        <p>
            See
            <a href="#primitive-types">Primitive types</a>,
            <a href="#implicit-conversions">Implicit conversions</a>,
            <a href="#constructors">Constructors</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Implicit conversions                                            -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="implicit-conversions">Implicit conversions</h3>
        <p>
            Implicit conversions are performed when an expression of the incorrect type is used in place of the expected one.<br>
            In function overloads and templates, the actual type of the value always takes precedence over conversions.
        </p>
        <p>
            Primitive types are all implicitly convertible between them.<br>
            The conversions follow these rules:
        </p>
        <div class="table-container"><table>
            <thead><tr>
                <th>Expression type</th>
                <th>Expected type</th>
                <th>Behaviour</th>
            </tr></thead>
            <tbody>
                <tr>
                    <td rowspan="3"><code class="lynx-type">uint</code></td>
                    <td><code class="lynx-type">int</code></td>
                    <td>Values over <code class="lynx-literal">limits::int::max</code> overflow to <code class="lynx-literal">limits::int::min&nbsp;+&nbsp;n&nbsp;-&nbsp;1</code></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">float</code><code class="lynx-type">double</code></td>
                    <td>No changes</td>
                </tr>
                <tr>
                    <td><code class="lynx-type">bool</code></td>
                    <td><code class="lynx-literal">1</code> is evaluated as <code class="lynx-literal">true</code>, any other value as <code class="lynx-literal">false</code></td>
                </tr>
                <tr>
                    <td rowspan="3"><code class="lynx-type">int</code></td>
                    <td><code class="lynx-type">uint</code></td>
                    <td>Negative values underflow to <code class="lynx-literal">limits::uint::max&nbsp;+&nbsp;n&nbsp;+&nbsp;1</code></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">float</code><code class="lynx-type">double</code></td>
                    <td>No changes</td>
                </tr>
                <tr>
                    <td><code class="lynx-type">bool</code></td>
                    <td><code class="lynx-literal">1</code> is evaluated as <code class="lynx-literal">true</code>, any other value as <code class="lynx-literal">false</code></td>
                </tr>
                <tr>
                    <td rowspan="4"><code class="lynx-type">float</code></td>
                    <td><code class="lynx-type">uint</code></td>
                    <td>The decimal part is truncated. Negative values underflow to <code class="lynx-literal">limits::uint::max&nbsp;+&nbsp;n&nbsp;+&nbsp;1</code>.<br>
                    If the value is not between <code class="lynx-literal">limits::uint::min</code> and <code class="lynx-literal">limits::uint::max</code>, the result is <b>undefined</b></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">int</code></td>
                    <td>The decimal part is truncated.<br>
                    If the value is not between <code class="lynx-literal">limits::int::min</code> and <code class="lynx-literal">limits::int::max</code>, the result is <b>undefined</b></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">double</code></td>
                    <td>No changes</td>
                </tr>
                <tr>
                    <td><code class="lynx-type">bool</code></td>
                    <td><code class="lynx-literal">1.0</code> is evaluated as <code class="lynx-literal">true</code>, any other value as <code class="lynx-literal">false</code></td>
                </tr>
                <tr>
                    <td rowspan="4"><code class="lynx-type">double</code></td>
                    <td><code class="lynx-type">uint</code></td>
                    <td>The decimal part is truncated. Negative values underflow to <code class="lynx-literal">limits::uint::max&nbsp;+&nbsp;n&nbsp;+&nbsp;1</code>.<br>
                    If the value is not between <code class="lynx-literal">limits::uint::min</code> and <code class="lynx-literal">limits::uint::max</code>, the result is <b>undefined</b></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">int</code></td>
                    <td>The decimal part is truncated.<br>
                    If the value is not between <code class="lynx-literal">limits::int::min</code> and <code class="lynx-literal">limits::int::max</code>, the result is <b>undefined</b></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">float</code></td>
                    <td>The result is approximated using the maximum precision available</td>
                </tr>
                <tr>
                    <td><code class="lynx-type">bool</code></td>
                    <td><code class="lynx-literal">1.0</code> is evaluated as <code class="lynx-literal">true</code>, any other value as <code class="lynx-literal">false</code></td>
                </tr>
                <tr>
                    <td rowspan="3"><code class="lynx-type">bool</code></td>
                    <td><code class="lynx-type">uint</code><code class="lynx-type">int</code></td>
                    <td><code class="lynx-literal">true</code> is evaluated as <code class="lynx-literal">1</code>, <code class="lynx-literal">false</code> as <code class="lynx-literal">0</code></td>
                </tr>
                <tr>
                    <td><code class="lynx-type">float</code><code class="lynx-type">double</code></td>
                    <td><code class="lynx-literal">true</code> is evaluated as <code class="lynx-literal">1.0</code>, <code class="lynx-literal">false</code> as <code class="lynx-literal">0.0</code></td>
                </tr>
            </tbody>
        </table></div>
        <p>
            Additional conversions between arrays and primitive types are described in the following table:
        </p>
        <div class="table-container"><table>
            <tr>
                <th>Expression type  </th>
                <th>Expected type    </th>
                <th>Behaviour        </th>
            </tr>
            <td><code class="lynx-type">T</code>   </td>
            <td><code class="lynx-type">U[n]</code></td>
            <td>Each element of the result is initialized with the value of the starting data, converted from <code class="lynx-type">T</code> to <code class="lynx-type">U</code></td>
            <tr>
                <td><code class="lynx-type">T[n]</code></td>
                <td><code class="lynx-type">U[n]</code></td>
                <td>Each element of the result is initialized with the corresponding value of the starting array, converted from <code class="lynx-type">T</code> to <code class="lynx-type">U</code></td>
            </tr>
            <tr>
                <td><code class="lynx-type">T[n]</code></td>
                <td><code class="lynx-type">bool</code></td>
                <td>Evaluated as <code class="lynx-literal">true</code> if all the elements of the initial array converted from <code class="lynx-type">T</code> to <code class="lynx-type"e>bool</code> evaluate as <code class="lynx-literal">true</code>, <code class="lynx-literal">false</code> otherwise</td>
            </tr>
        </table></div>
        <p>
            Values cannot be explicitly casted as in C. To convert a value, constructors are used.<br>
            Attempting to convert incompatible types will result in a semantic error.<br>
            Structs are not convertible.
        </p>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">void</span> <span class="lynx-func">fun</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">a</span>[<span class="lynx-literal">5</span>]) {}
            <span class="lynx-type">void</span> <span class="lynx-func">fun2</span>(<span class="lynx-type">bool</span> <span class="lynx-arg">a</span>) {}

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-keyword">struct</span> { <span class="lynx-type">uint</span> n; } var = (<span class="lynx-literal">0</span>);
                <span class="lynx-comment">//fun(var);                               // Error, structs cannot be converted</span>
                <span class="lynx-comment">//fun(float[2](1.0, 4.4));                // Error, arrays have different lengths</span>
                <span class="lynx-func">fun</span>(<span class="lynx-literal">2</span>);                                   <span class="lynx-comment">// Ok, a = (2, 2, 2, 2, 2)</span>
                <span class="lynx-func">fun</span>(<span class="lynx-type">float</span>[<span class="lynx-literal">5</span>](<span class="lynx-literal">1.0</span>, <span class="lynx-literal">4.4</span>, <span class="lynx-literal">5.5</span>, <span class="lynx-literal">-33</span>, <span class="lynx-literal">2.11</span>));  <span class="lynx-comment">// Ok, a = (1, 4, 5, 4294967263, 2)</span>

                <span class="lynx-func">fun2</span>(<span class="lynx-literal">2</span>);                                  <span class="lynx-comment">// Ok, a = true</span>
                <span class="lynx-func">fun2</span>(<span class="lynx-type">float</span>[<span class="lynx-literal">5</span>](<span class="lynx-literal">1.0</span>, <span class="lynx-literal">4.4</span>, <span class="lynx-literal">5.5</span>, <span class="lynx-literal">-33</span>, <span class="lynx-literal">2.11</span>)); <span class="lynx-comment">// Ok, a = true</span>
                <span class="lynx-func">fun2</span>(<span class="lynx-type">float</span>[<span class="lynx-literal">5</span>](<span class="lynx-literal">1.0</span>, <span class="lynx-literal">4.4</span>, <span class="lynx-literal">5.5</span>, <span class="lynx-literal">-33</span>, <span class="lynx-literal">0</span>   )); <span class="lynx-comment">// Ok, a = false</span>

                <span class="lynx-type">uint</span> arr[<span class="lynx-literal">1.2</span>];                            <span class="lynx-comment">// Ok, arr has 1 element</span>
            }
        </pre></div>
        <p>
            See
            <a href="#arrays">Arrays</a>,
            <a href="#constructors">Constructors</a>,
            <a href="#standard-modules">Standard modules</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Auto specifier                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="auto-specifier">Auto specifier</h3>
        <p>
            The <code class="lynx-type">auto</code> specifier can be used as a type when declaring a variable or function.<br>
            The actual type of the symbol will be the same as the expression used to initialize it.<br>
        </p>
        <p>
            <code class="lynx-type">auto</code> is not allowed in struct members declarations and function parameters.<br>
            The type of <code class="lynx-type">auto</code> functions is determined by their return value.<br>
            There is no <code class="lynx-type">auto</code> constructor.
        </p>
        <p>
            <code class="lynx-type">auto</code> arrays and <code class="lynx-type">const</code> <code class="lynx-type">auto</code> symbols are allowed.
            //TODO auto functions that depend on an argument value
        </p>

        <div class="fancy-code-label">Example 1</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">auto</span> <span class="lynx-func">func</span>(){
                <span class="lynx-keyword">return</span> <span class="lynx-literal">true</span>;        <span class="lynx-comment">// func has type bool</span>
            }

            <span class="lynx-type">auto</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">auto</span> a = <span class="lynx-literal">2</span>;         <span class="lynx-comment">// a has type uint</span>
                <span class="lynx-type">auto</span> b = <span class="lynx-literal">5.4</span> * <span class="lynx-literal">a</span>;   <span class="lynx-comment">// b has type float</span>
                <span class="lynx-type">auto</span> c = <span class="lynx-func">func</span>();    <span class="lynx-comment">// c has type bool</span>
                <span class="lynx-comment">// No return statement, main has type void</span>
            }
        </pre></div>
        <div class="fancy-code-label">Example 2</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">auto</span>[<span class="lynx-literal">4</span>] a = <span class="lynx-literal">1</span>;          <span class="lynx-comment">// a has type int[4] and value (1, 1, 1, 1)</span>
            <span class="lynx-type">auto</span>[<span class="lynx-literal">2</span>] <span class="lynx-type">const</span> b = !<span class="lynx-literal">a</span>;   <span class="lynx-comment">// b has type bool[4][2] and value ((0, 0, 0, 0), (0, 0, 0, 0))</span>
        </pre></div>
        <p>
            See
            <a href="#functions">Functions</a>,
            <a href="#return-statement">Return statement</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Typeof and baseof specifiers                                    -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="typeof-and-baseof-specifiers">Typeof and baseof specifiers</h3>
        <p>
            The <code class="lynx-type">typeof</code> and <code class="lynx-type">baseof</code> specifiers are used in the same way as auto, but the type is defined by the expression passed to them.<br>
            <code class="lynx-type">typeof</code> returns the type of the expression, <code class="lynx-type">baseof</code> returns it's base type.
        </p>
        <p>
            <code class="lynx-type">baseof</code> can only be used on arrays, enums and primitive types.<br>
            The base type of primitive types is the type itself.<br>
            The expressions passed to those specifiers are always evaluated at compile time.
        </p>
        <p>
            The <code class="lynx-type">typeof</code> and <code class="lynx-type">baseof</code> specifiers can be used as constructors.<br>
            Circular dependencies are a semantic error.
            //TODO
        </p>

        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm">typeof</span>(<span class="syntax-elm lynx-type">T</span>)</pre>
        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm">baseof</span>(<span class="syntax-elm lynx-type">T</span>)</pre>
        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">auto</span>[<span class="lynx-literal">3</span>] <span class="lynx-func">func</span>(<span class="lynx-keyword">typeof</span>(<span class="lynx-func">func</span>(<span class="lynx-literal">0</span>)) <span class="lynx-arg">n</span>) { <span class="lynx-comment">// 2 - func::n has type bool[3]</span>
                <span class="lynx-keyword">return</span> !n * <span class="lynx-type">int</span>(<span class="lynx-literal">0</span>, <span class="lynx-literal">1</span>, <span class="lynx-literal">2</span>);    <span class="lynx-comment"> // 1 - func has type bool</span>
            }

            <span class="lynx-type">baseof</span>(<span class="lynx-func">main</span>::a) <span class="lynx-type">const</span> g = <span class="lynx-literal">4</span>;     <span class="lynx-comment"> // g has type bool and value true</span>
            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">baseof</span>(g) b = <span class="lynx-literal">a</span>;             <span class="lynx-comment"> // b has type bool and balue false</span>

                <span class="lynx-comment">/*                     bool constructor, value 0
                                    ┌───────────┴──────────┐*/</span>
                <span class="lynx-type">typeof</span>(<span class="lynx-func">func</span>(<span class="lynx-literal">0</span>))[<span class="lynx-literal">2</span>] a = <span class="lynx-type">baseof</span>(<span class="lynx-func">func</span>(<span class="lynx-literal">0</span>))(<span class="lynx-func">func</span>(<span class="lynx-literal">5</span>));<span class="lynx-comment">/* a has type bool[3][2] and value ((0, 0, 0), (0, 0, 0))
                └───────┬────────┘                     └──┬──┘
                    bool[3][2]               type bool[3], value (0, 0, 0)*/</span>
            }
            //TODO write an easier example
        </pre></div>
        <p>
            See
            <a href="#functions">Functions</a>,
            <a href="#return-statement">Return statement</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Variables                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="variables">Variables</h2>
        <p>
            Variables are <b>named memory locations</b> that can contain values of the specified type.<br>
            Each variable <b>must be declared</b> before it is used. Variables <b>cannot be redeclared</b> and their <b>type cannot be changed</b> after the declaration.
        </p>
        <p>
            A variable declaration consists of the type, the name and an optional <code>=</code> followed by an expression of a compatible type that is used to <b>inizialize it</b>.<br>
            If an initializer expression is not specified, the value of the variable is <b>undefined</b>.<br>
            <b>Evaluating</b> an expression that can result in an <b>undefined value</b> is considered a <b>logical error</b> and will stop the compilation process.<br>
            Variables with undefined value can still be passed to reference arguments of functions or be assigned a value.
        </p>

        <div class="fancy-code-label">Syntax 1</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span><span class="hidden">·</span><span class="syntax-elm">symbol identifier</span>;</pre>
        <div class="fancy-code-label">Syntax 2</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span><span class="hidden">·</span><span class="syntax-elm">symbol identifier</span> = <span class="syntax-elm"><span class="lynx-type">T</span> expression</span>;</pre>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">uint</span> variable = <span class="lynx-literal">0</span>;         <span class="lynx-comment">// Ok, variable has value 0</span>
            <span class="lynx-type">float</span> nya = <span class="lynx-literal">5</span> + <span class="lynx-literal">variable</span>;  <span class="lynx-comment">// Ok, nya ha value 5.0</span>
            <span class="lynx-type">bool</span> var$;                 <span class="lynx-comment">// Ok, var$ has undefined value</span>
            <span class="lynx-comment">//b var_2 = var$;          // Error. The syntax is correct, but undefined values (var$) cannot be used inside expressions</span>

            <span class="lynx-comment">//double variable;         // Error, the identifier "variable" is already declared</span>
            <span class="lynx-comment">//double foo               // Error, ';' is not optional</span>
            <span class="lynx-comment">//b $var;                  // Error, invalid identifier</span>
            <span class="lynx-comment">//b 2var;                  // Error, invalid identifier</span>
        </pre></div>
        <p>
            See
            <a href="#types">Types</a>,
            <a href="#expressions">Expressions</a>,
            <a href="#functions">Functions</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Temporary variables                                             -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="temporary-variables">Temporary variables</h3>
        <p>
            Temporary variables are a special set of identifiers that have dynamic type and don't need to be declared.<br>
            These identifiers are meant to replace local variables whose only purpose is holding values that don't need to be used more than a few times.<br>
            A temporary variable is identified by the <code>$</code> character followed by an arbitrary number of decimal digits, which denote its name.<br>
        </p>
        <p>
            They are always <b>function-level scoped</b> and cannot be used outside of function definitions.<br>
            There is no limit to the number of temporary variables a function can use.<br>
        </p>
        <p>
            The <b>type</b> of a temporary variable can only be changed through direct assignments (<code>=</code>) and it must be <b>unambiguously determinable</b> in order for the variable to be evaulated.
            This means that reading the value of a temporary variable after one or more branches that may have assigned it <b>different types</b> is not allowed and will result in a <b>semantic error</b>.<br>
            Using temporary variables whose type is undefined will also result in a semantic error.
        </p>
        <p>They act as normal variables for anything else.</p>

        <div class="fancy-code-label">Example 1</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">uint3</span> <span class="lynx-func">fun1</span>(<span class="lynx-type">bool</span> <span class="lynx-arg">arg</span>) {
                $0 = <span class="lynx-literal">1</span>;             <span class="lynx-comment">// Ok, $0 has type uint and value 1</span>
                <span class="lynx-comment">//$2 = $1;          // Error, $1 has undefined type</span>

                <span class="lynx-type">uint3</span> vec = { <span class="lynx-literal">0</span>, <span class="lynx-literal">1</span>, <span class="lynx-literal">2</span> };
                $2 = <span class="lynx-literal">true</span>;          <span class="lynx-comment">// Ok, $2 has type b and value true</span>
                $2 = <span class="lynx-literal">vec</span>;           <span class="lynx-comment">// Ok, $2 has type uint3 and value { 0, 1, 2 }</span>
            }

            <span class="lynx-type">void</span> <span class="lynx-func">fun2</span>(<span class="lynx-type">uint3</span> <span class="lynx-arg">vec</span>) {
                <span class="lynx-comment">//uint var = $2;    // Error, $2 has undefined type. fun2::$2 has nothing to do with fun1::$2</span>
            }

            <span class="lynx-comment">//uint var = $9;        // Error, temporary variables cannot be used outside of functions</span>
        </pre></div>
        <div class="fancy-code-label">Example 2</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">void</span> <span class="lynx-func">fun3</span>(<span class="lynx-type">bool</span> <span class="lynx-arg">arg</span>, <span class="lynx-type">uint2</span> &<span class="lynx-arg">ref</span>) {
                <span class="lynx-keyword">if</span>(arg) $0 = <span class="lynx-literal">1</span>;             <span class="lynx-comment">// $0 has type uint</span>
                <span class="lynx-keyword">else</span>    $0 = { <span class="lynx-literal">0</span>, <span class="lynx-literal">1</span> };      <span class="lynx-comment">// $0 has type uint2</span>
                <span class="lynx-comment">//ref = $0;                 // Error, cannot determine the type of $0</span>
                $0 = ref;                   <span class="lynx-comment">// Ok, $0 has type uint2 and the same value as ref</span>

                <span class="lynx-keyword">if</span>(arg) $0 = { <span class="lynx-literal">0</span>, <span class="lynx-literal">1</span> };      <span class="lynx-comment">// $0 has type uint2</span>
                <span class="lynx-keyword">else</span>    $0 = { <span class="lynx-literal">2</span>, <span class="lynx-literal">3</span> };      <span class="lynx-comment">// $0 has type uint2</span>
                ref = <span class="lynx-literal">$0</span>;                   <span class="lynx-comment">// Ok, $0 has type uint2</span>
            }
        </pre></div>
        <p>
            See
            <a href="#types">Types</a>,
            <a href="#selection">Selection</a>,
            <a href="#functions">Functions</a>,
            <a href="#expressions">Expressions</a>
        </p>




        <!--------------------------------------------------------------------->
        <!-- Functions                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="functions">Functions</h2>
        <p>
            Functions are the <b>main component</b> of the language. They contain the statements that will be executed during run time and manage inputs and outputs of the shader.<br>
        </p>
        <p>
            A function definition consists of its type and name followed by a list of arguments and its statements enclosed in <code>{</code><code>}</code> delimiters.<br>
            Functions are allowed to take no arguments.
        </p>
        <p>
            The <code class="lynx-func">main</code> function is where the <b>code execution starts and ends</b>.<br>
            Every shader <b>must define</b> the <b>main</b> as a <b>void</b> function. As such, it cannot return values.<br>
        </p>

        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm lynx-type">T</span><span class="hidden">·</span><span class="syntax-elm">symbol identifier</span>(<span class="syntax-elm lynx-type">U</span><span class="hidden">·</span><span class="syntax-elm">arg identifier</span>, <span class="syntax-elm">...</span>) {<span class="syntax-elm">...</span>}</pre>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">void</span> <span class="lynx-func">func1</span>() {}

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">int</span> n = <span class="lynx-literal">0</span>;
                <span class="lynx-comment">// ...</span>
            }
        </pre></div>
        <p>
            See
            <a href="#runtime-statements">Runtime statements</a>,
            <a href="#types">Types</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Parameters and references                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="parameters-and-references">Parameters and references</h3>
        <p>
            A function can take an <b>arbitrary number</b> of <b>parameters</b> of any type. Parameters are declared like variables and behave in the same exact way.<br>
            The expressions used to call the function are called arguments.<br>
            Each argument <b>must be implicitly convertible</b> to the type of the parameter.
        </p>
        <p>
            By <b>default</b>, the arguments are passed <b>by value</b>, which means that when the function is called, the value of each argument is <b>copied</b> in the corresponding parameter and the function <b>cannot access</b> the original variable.<br>
            If a parameter name is preceeded by a <b><code>&</code></b> token, instead, the argument is passed <b>by reference</b>, allowing the function to <b>access and modify</b> its value
        </p>
        <p>
            Declaring a reference parameter as const is a syntax error and passing an unnamed value as argument of a reference parameter is a semantic error.<br>
            Notice that in this case, the <code>&</code> token is not part of the type nor part of the name, but a language feature that is used exclusively within parameter declarations.
        </p>

        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">void</span> <span class="lynx-func">fun1</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">arg1</span>, <span class="lynx-type">uint</span> &<span class="lynx-arg">arg2</span>) {
                arg1 = <span class="lynx-literal">0</span>;     <span class="lynx-comment">// This doesn't modify main::a, but the local argument in which its value was copied</span>
                arg2 = <span class="lynx-literal">0</span>;     <span class="lynx-comment">// This modifies main::b</span>
            }

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">uint</span> a, b;
                <span class="lynx-func">fun1</span>(a, b);   <span class="lynx-comment">// a keeps an undefined value, b is set to 0</span>
                <span class="lynx-comment">//fun1(a, 5); // Error, cannot pass literals to reference parameters</span>
            }

            <span class="lynx-comment">//void fun2(const int &arg1){} // Error, references cannot be const</span>
        </pre></div>
        <p>
            See
            <a href="#const-qualifier">Const qualifier</a>,
            <a href="#literals">Literals</a>
        </p>


        <!--------------------------------------------------------------------->
        <!-- Return statement                                                -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="return-statement">Return statement</h3>
        <p>
            The <b>type</b> of the function defines the type of the <b>value</b> that is <b>returned</b> by the function when called.<br>
            Values are returned using the <code class="lynx-keyword">return</code> statement. When this happens, all the remaining statements in the function are skipped and the code execution returns to the caller function.<br>
            Functions that <b>don't return</b> a value must be defined using the <b><code class="lynx-type">void</code> type</b>.<br>
            Void functions are allowed to contain no statements. <b>Non-void</b> functions must <b>always return</b> a value.
        </p>

        <div class="fancy-code-label">Syntax</div>
        <pre class="fancy-code-single-line"><span class="syntax-elm">return</span><span class="hidden">·</span><span class="syntax-elm">expression</span>;</pre>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-type">void</span> <span class="lynx-func">empty_function_1</span>() { <span class="lynx-keyword">return</span>; }   <span class="lynx-comment">// Ok</span>
            <span class="lynx-type">void</span> <span class="lynx-func">empty_function_2</span>() {}            <span class="lynx-comment">// Ok</span>

            <span class="lynx-type">uint</span> <span class="lynx-func">empty_function_3</span>() { <span class="lynx-keyword">return</span> <span class="lynx-literal">0</span>; }  <span class="lynx-comment">// Ok</span>
            <span class="lynx-comment">//uint empty_function_4() {}           // Error, non-void functions must return a value</span>

            <span class="lynx-type">uint</span> <span class="lynx-func">f</span>(<span class="lynx-type">uint</span> <span class="lynx-arg">n</span>) { <span class="lynx-keyword">return</span> n * <span class="lynx-literal">2</span>; }       <span class="lynx-comment">// Ok</span>
            <span class="lynx-comment">//void f() { }                         // Error, f is already defined</span>

            <span class="lynx-type">void</span> <span class="lynx-func">main</span>(){
                <span class="lynx-type">uint</span> n = <span class="lynx-func">empty_function_3</span>();       <span class="lynx-comment">// Ok</span>
                n = <span class="lynx-func">f</span>(<span class="lynx-func">f</span>(<span class="lynx-literal">n</span>));                       <span class="lynx-comment">// Ok</span>
            }
        </pre></div>


        <!--------------------------------------------------------------------->
        <!-- Function calls                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="function-calls">Function calls</h3>


        <!--------------------------------------------------------------------->
        <!-- Template functions                                              -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="template-functions">Template functions</h3>


        <!--------------------------------------------------------------------->
        <!-- Type groups                                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="type-groups">Type groups</h3>




        <!--------------------------------------------------------------------->
        <!-- Const qualifier                                                 -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="const-qualifier">Const qualifier</h2>
        <p>
            The <code class="lynx-type">const</code> qualifier can be used to <b>prevent</b> named values to be <b>modified</b> after their declaration.<br>
            Reference const parameters are not allowed, as well as const functions and const struct members.<br>
        </p>
        <p>
            As opposed to C and GLSL, const identifiers can be initialized using non-const expressions.<br>
            The qualifier doesn't affect compiler optimizations or the GLSL output in any way.
        </p>
        <p>
            Passing a const identifier as argument of reference parameters is not allowed and will result in a semantic error.<br>
            Const variables cannot have undefined value.
        </p>


        <div class="fancy-code-label">Example</div>
        <div class="fancy-code-multi-line-fix"><pre class="fancy-code-multi-line">
            <span class="lynx-keyword">struct</span> <span class="lynx-type">s</span> {
                <span class="lynx-type">uint</span> a;            <span class="lynx-comment">// Ok, non-const member</span>
                <span class="lynx-comment">//uint const b;    // Error, struct members cannot be const</span>
            } <span class="lynx-type">const</span> var;           <span class="lynx-comment">// Ok, const global variable</span>

            <span class="lynx-comment">//double const fun(){}              // Error, functions cannot be const</span>
            <span class="lynx-comment">//double fun(double const &arg){}   // Error, references cannot be const</span>

            <span class="lynx-type">double</span> <span class="lynx-func">fun</span>(<span class="lynx-type">double const</span> arg) {      <span class="lynx-comment">// Ok, const parameter</span>
                <span class="lynx-comment">//uint a;                       // Error, uninitialized const</span>
                <span class="lynx-type">u64 const</span> a = 4;                <span class="lynx-comment">// Ok</span>
                <span class="lynx-type">u64 const</span> b = arg, c;           <span class="lynx-comment">// Ok</span>
                <span class="lynx-comment">//a = 2;                        // Error, cannot assign values to const variables</span>
                c = <span class="lynx-literal">a</span> + b;                      <span class="lynx-comment">// Ok</span>
            }
        </pre></div>
        <p>
            See
            <a href="#compiler-optimizations">Compiler optimizations</a>
        </p>




        <!--------------------------------------------------------------------->
        <!-- Symbol aliases                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="symbol-aliases">Symbol aliases</h2>








        <!--------------------------------------------------------------------->
        <!-- Runtime statements                                              -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1>Runtime statements</h1>



        <!--------------------------------------------------------------------->
        <!-- Expressions                                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="expressions">Expressions</h2>

        <!--------------------------------------------------------------------->
        <!-- Literals                                                        -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="literals">Literals</h3>

        <!--------------------------------------------------------------------->
        <!-- Constructors                                                    -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="constructors">Constructors</h3>
        <p>CONSTRUCTORS ARE SPECIAL FUNCTIONS //TODO</p>

        <!--------------------------------------------------------------------->
        <!-- Operators                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="operators">Operators</h3>

        <!--------------------------------------------------------------------->
        <!-- Special operators                                               -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="special-operators">Special operators</h3>

        <!--------------------------------------------------------------------->
        <!-- Array operations                                                -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="array-operations">Array operations</h3>



        <!--------------------------------------------------------------------->
        <!-- Assignments                                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="assignments">Assignments</h2>

        <!--------------------------------------------------------------------->
        <!-- Composite assignments                                           -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="composite-assignments">Composite assignments</h3>

        <!--------------------------------------------------------------------->
        <!-- Multiple assignments                                            -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="multiple-assignments">Multiple assignments</h3>



        <!--------------------------------------------------------------------->
        <!-- Selection                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="selection">Selection</h2>

        <!--------------------------------------------------------------------->
        <!-- If statement                                                    -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="if-statement">If statement</h3>

        <!--------------------------------------------------------------------->
        <!-- Select statement                                                -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="select-statement">Select statement</h3>



        <!--------------------------------------------------------------------->
        <!-- Iteration                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="iteration">Iteration</h2>

        <!--------------------------------------------------------------------->
        <!-- For loops                                                       -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="for-loops">For loops</h3>

        <!--------------------------------------------------------------------->
        <!-- While loops                                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="while-loops">While loops</h3>

        <!--------------------------------------------------------------------->
        <!-- Continue and break statements                                   -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="continue-and-break-statements">Continue and break statements</h3>

        <!--------------------------------------------------------------------->
        <!-- Once statement                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="once-statement">Once statement</h3>

        <!--------------------------------------------------------------------->
        <!-- Then statement                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-3"></div>
        <h3 id="then-statement">Then statement</h3>



        <!--------------------------------------------------------------------->
        <!-- Else statement                                                  -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="else-statement">Else statement</h2>







        <!--------------------------------------------------------------------->
        <!-- Compilation                                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1>Compilation</h1>



        <!--------------------------------------------------------------------->
        <!-- Modules                                                         -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="modules">Modules</h2>



        <!--------------------------------------------------------------------->
        <!-- Compilation phases and error types                              -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="compilation-phases-and-error-types">Compilation phases and error types</h2>



        <!--------------------------------------------------------------------->
        <!-- Global initialization order                                     -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="global-initialization-order">Global initialization order</h2>



        <!--------------------------------------------------------------------->
        <!-- Branching performance                                           -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="branching-performance">Branching performance</h2>



        <!--------------------------------------------------------------------->
        <!-- Compiler optimizations                                          -->
        <!--------------------------------------------------------------------->
        <div class="separator-2"></div>
        <h2 id="compiler-optimizations">Compiler optimizations</h2>







        <!--------------------------------------------------------------------->
        <!-- Standard modules                                                -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1>Standard modules</h1>







        <!--------------------------------------------------------------------->
        <!-- Quick reference tabs                                            -->
        <!--------------------------------------------------------------------->
        <div class="separator-1"></div>
        <h1 id="quick-reference-tabs">Quick reference tabs</h1>

        //TODO
        //this.x this.y this.z
        this::pos.x
        this::pos.y
        this::pos.z
        ^ coordinates in current workspace




        sequence function //TODO
        sequence(start, end, step)







        <div class="table-container"><table>
            <thead><tr>
                <th class="center">Precedence</th>
                <th class="center">Operator</th>
                <th class="center">Syntax</th>
                <th class="center">Result</th>
                <th class="left">Name</th>
                <th class="left">Category</th>
            </tr></thead>
            <tbody>
                <tr>
                    <td class="center" >1</td>
                    <td class="center">
                        <span class="syntax-elm"><code>(</code><code>)</code></span>
                    </td>
                    <td class="center"><span class="op_syntax">(<span class="syntax-elm lynx-type">T</span>)</span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                    <td class="left">Grouping</td>
                    <td class="left" rowspan=5>Other</td>
                </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=6>2</td>
                        <td class="center" rowspan=2>
                            <span class="op_template">-</span><br>
                            <span class="syntax-elm"><code>[</code><code>]</code></span><br>
                            <span class="op_template">with(T == struct_t)</span><br>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T[]</span>[<span class="syntax-elm lynx-type">uint</span>]</span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> l-value</span></td>
                        <td class="left" rowspan=2>Subscription</td>
                    </tr>
                    <tr>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span>[<span class="syntax-elm lynx-type">uint</span>]</span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">member type</span> l-value</span></td>
                    </tr>
                    <tr>
                        <td class="center" rowspan=2>
                            <span class="op_template">-</span><br>
                            <code>.</code><br>
                            <span class="op_template">with(T == struct_t)</span><br>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T[]</span>.<span class="syntax-elm lynx-var">identifier</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> l-value</span></td>
                        <td class="left" rowspan=2>Member access</td>
                    </tr>
                    <tr>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span>.<span class="syntax-elm lynx-var">identifier</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">member type</span> l-value</span></td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>++</code>
                        </td>
                        <td class="center"><span class="syntax-elm lynx-type">T</span>++</td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Postfix increment</td>
                        <td class="left" rowspan=6>Arithmetic</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>--</code>
                        </td>
                        <td class="center"><span class="syntax-elm lynx-type">T</span>--</td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Postfix decrement</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=6>3</td>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>++</code>
                        </td>
                        <td class="center"><span class="op_syntax">++<span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Prefix increment</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>--</code>
                        </td>
                        <td class="center"><span class="op_syntax">--<span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Prefix decrement</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>+</code>
                        </td>
                        <td class="center"><span class="op_syntax">+<span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Promotion</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>-</code>
                        </td>
                        <td class="center"><span class="op_syntax">-<span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Inversion</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T == int_t)</span><br>
                            <code>~</code>
                        </td>
                        <td class="center"><span class="op_syntax">~<span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Bitwise NOT</td>
                        <td class="left">Binary</td>
                    </tr>
                    <tr>
                        <td class="center"><code>!</code></td>
                        <td class="center"><span class="op_syntax">!<span class="syntax-elm lynx-type">bool</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</td>
                        <td class="left">Logical NOT</td>
                        <td class="left">Logical</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=3>4</td>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>*</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &#42; <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Multiplication</td>
                        <td class="left" rowspan=5>Arithmetic</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>/</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> / <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Division</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>%</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> % <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Modulo</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=2>5</td>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>+</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> + <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Addition</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>-</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> - <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Subtraction</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=2>6</td>
                        <td class="center">
                            <span class="op_template">with(T == int_t)</span><br>
                            <code>&lt;&lt;</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &lt;&lt; <span class="syntax-elm lynx-type">uint</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Left bit shift</td>
                        <td class="left" rowspan=2>Binary</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T == int_t)</span><br>
                            <code>&gt;&gt;</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &gt;&gt; <span class="syntax-elm lynx-type">uint</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                        <td class="left">Right bit shift</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=4>7</td>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>&lt;</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &lt; <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Less than</td>
                        <td class="left" rowspan=7>Comparison</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>&lt;=</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &lt;= <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Less or equal than</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>&gt;</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &gt; <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Greater than</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>&gt;=</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> &gt;= <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Greater or equal than</td>
                    </tr>
                <!-- -->
                    <tr>
                        <td class="center" rowspan=3>8</td>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>==</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> == <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Equality</td>
                    </tr>
                    <tr>
                        <td class="center">
                            <span class="op_template">with(T != struct_t)</span><br>
                            <code>!=</code>
                        </td>
                        <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> != <span class="syntax-elm lynx-type">T</span></span></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Inequality</td>
                    </tr>
                    <tr>
                        <td class="center"><code>:=</code></td>
                        <td class="center"></td>
                        <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                        <td class="left">Existence</td>
                    </tr>
                <tr>
                    <td class="center">9</td>
                    <td class="center">
                        <span class="op_template">with(T != int_t)</span><br>
                        <code>&</code>
                    </td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> & <span class="syntax-elm lynx-type">T</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                    <td class="left">Bitwise AND</td>
                    <td class="left" rowspan=3>Binary</td>
                </tr>
                <tr>
                    <td class="center">10</td>
                    <td class="center">
                        <span class="op_template">with(T != int_t)</span><br>
                        <code>^</code>
                    </td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> ^ <span class="syntax-elm lynx-type">T</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                    <td class="left">Bitwise XOR</td>
                </tr>
                <tr>
                    <td class="center">11</td>
                    <td class="center">
                        <span class="op_template">with(T != int_t)</span><br>
                        <code>|</code>
                    </td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">T</span> | <span class="syntax-elm lynx-type">T</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                    <td class="left">Bitwise OR</td>
                </tr>
                <tr>
                    <td class="center">12</td>
                    <td class="center"><code>&&</code></td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">bool</span> && <span class="syntax-elm lynx-type">bool</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                    <td class="left">Logical AND</td>
                    <td class="left" rowspan=3>Logical</td>
                </tr>
                <tr>
                    <td class="center">13</td>
                    <td class="center"><code>^^</code></td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">bool</span> ^^ <span class="syntax-elm lynx-type">bool</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                    <td class="left">Logical XOR</td>
                </tr>
                <tr>
                    <td class="center">14</td>
                    <td class="center"><code>||</code></td>
                    <td class="center"><span class="op_syntax"><span class="syntax-elm lynx-type">bool</span> || <span class="syntax-elm lynx-type">bool</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">bool</span> r-value</span></td>
                    <td class="left">Logical OR</td>
                </tr>
                <tr>
                    <td class="center" rowspan=2>15</td>
                    <td class="center" rowspan=2><span class="syntax-elm"><code>?</code><code>:</code></span></td>
                    <td class="center" rowspan=2><span class="op_syntax"><span class="syntax-elm lynx-type">bool</span> ? <span class="syntax-elm lynx-type">T</span> : <span class="syntax-elm lynx-type">T</span></span></td>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> l-value</span></td>
                    <td class="left"   rowspan=2>Selection operator</td>
                    <td class="left"   rowspan=2>Other</td>
                </tr>
                <tr>
                    <td class="center"><span class="syntax-elm"><span class="lynx-type">T</span> r-value</span></td>
                </tr>
            </tbody>
        </table></div>

        Operators cannot be used as value. Only their members can

        //TODO add as keyword
        //TODO add with keyword

    </div>
</div>
</body>
</html>



<!--
<p>
    Array <b>elements</b> are referenced through their <b>index</b>.<br>
    Negative values are not supported.
</p>
<p>
    One-dimensional arrays with a <b>maximum of 4 elements</b> can use special <b>named identifiers</b> to refer to them.<br>
    Referencing elements of multidimensional arrays require two or more indices.<br>
    Referencing elements that are <b>not</b> in the <b>array range</b> has <b>undefined behaviour</b>.
</p>
| Element | Named identifier 1 | Named identifier 2 |
|:-------:|:------------------:|:------------------:|
| <code>[0]</code>   | <code>x</code>                | <code>r</code>                |
| <code>[1]</code>   | <code>y</code>                | <code>g</code>                |
| <code>[2]</code>   | <code>z</code>                | <code>b</code>                |
| <code>[3]</code>   | <code>w</code>                | <code>a</code>                |
<p>
    //TODO MOVE VALUE LISTS TO #multiple-assignments
    Both named identifiers and indices can be listed to reference multiple elements at once.<br>
    Referencing the same element more than once in a left value is a semantic error. If it happens during runtime, it has undefined behaviour.
</p>

<h5>Syntax</h5>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]</pre>
<pre><span class="syntax-elm">symbol identifier</span>[<span class="syntax-elm">(uint) expression</span>]<span class="syntax-elm">...</span></pre>
<pre><span class="syntax-elm">symbol identifier</span>.<span class="syntax-elm">named identifier</span><span class="syntax-elm">...</span></pre>

<h5>Example</h5>
```c
void main() { //TODO multidimensional arrays
    uint arr1[5];
    arr1[3] = 0;                // Ok, arr1 = (?, ?, ?, 0, ?)
    //arr1[5] = 0;              // Undefined behaviour, index 5 is out of range
    //arr1.a = 0;               // Error, arrays with more than 5 elements don't have named identifiers

    //uint arr2[] = arr1[0, 1, 2, 3];    // Error, some of these elements are not initialized
    arr1[0, 1, 4] = 2;                  // Ok, arr1 =(2, 2, ?, 0, 2)
    uint arr2[] = arr1[0, 1, 4, 3];      // Ok, arr2 = (2, 2, 2, 0)

    uint arr2.b = 9;                     // Ok, arr2 = (2, 2, 9, 0)
    arr2.xyz = arr2.zrz;                // Ok, arr1 = (0, 2, 0, 0)
    arr2.wyrb *= 3;                     // Ok, arr1 = (0, 6, 0, 0)
    //arr2.xyz = arr2.zrga;             // Error, the arrays have different length
    //arr2.yy = arr2.xx;                // Error, element [0] referenced twice in left value
    //arr2.yy = arr2.xa;                // Error, element [0] referenced twice in left value
}
```




<p>Althought the file extension is only a convention and can be changed or omitted, it is still recommended to use the correct one, as some softwares may use it to determine the language of the source file.</p>
