
#version 450

#define WORKGROUP_SIZE 1			//The x and y size of the workgroup
#define x gl_GlobalInvocationID.x	//The x coordinate of the shader call. This does not depend on the workgroup size
#define y gl_GlobalInvocationID.y	//The y coordinate of the shader call. This does not depend on the workgroup size
#define colToInt(v) ((v.a) << 24) | ((v.b & 0xFF) << 16) | ((v.g & 0xFF) << 8) | (v.r & 0xFF)

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout(std430, binding = 0) buffer colorOutput_{ uint colorOutput[]; };
layout(std430, binding = 1) buffer windowSize_{ 
	uint width;
	uint height; 
};
layout(std430, binding = 2) buffer lineData_{ 
	//16
	int x0; int y0; 
	int x1; int y1; 
	//16
	uvec4 color;
	//4
	float wd;
//uint a;
//uint b;
//uint c;
//uint d;
};



void setPixelColor(int _x, int _y, vec4 col){
	uvec4 col_ = {uint(col.r),uint(col.g),uint(col.b),uint(col.a)};
	colorOutput[_y*width+_x] = colToInt(col_);
}



void drawLine(){ 
	float dx = distance(x0,x1);
	float dy = distance(y0,y1);
	int minx = min(x0,x1);
	int miny = min(y0,y1);
	int maxx = max(x0,x1);
	int maxy = max(y0,y1);



	
	if(wd == 1){
		for(int i = 0; i < dx; i++){
			int _y = int(dy / (dx / i));
			setPixelColor(i + minx, _y + miny, vec4(255, 0, 0, 255));
		}
	}
	else{
		int _y, /*i,*/ j;
//		for(i = 0; i < dx; i++){
			_y = int(dy / (dx / /*i*/int(x) ));
			setPixelColor(/*i*/int(x) + minx, _y + miny, vec4(255, 0, 0, 255));
			for(j = 1; j < int(wd);j++){
				setPixelColor(/*i*/int(x) + minx, _y + miny + j, vec4(255, 0, 0, 255));
				setPixelColor(/*i*/int(x) + minx + j, _y + miny, vec4(255, 0, 0, 255));
			}
//		}
//		for(i = 0; i < wd; i++) for(j = 0; j < wd; j++) setPixelColor(maxx + i, maxy + j, vec4(255, 0, 0, 255));
	}



//	if(wd == 1){
//		for(int i = 0; i < dx; i++){
//			int _y = int(dy / (dx / i));
//			setPixelColor(i + minx, _y + miny, vec4(255, 0, 0, 255));
//		}
//	}
//	else{
//		int _y, i, j;
//		for(i = 0; i < dx; i++){
//			_y = int(dy / (dx /i ));
//			setPixelColor(i + minx, _y + miny, vec4(255, 0, 0, 255));
//			for(j = 1; j < int(wd);j++){
//				setPixelColor(i + minx, _y + miny + j, vec4(255, 0, 0, 255));
//				setPixelColor(i + minx + j, _y + miny, vec4(255, 0, 0, 255));
//			}
//		}
//		for(i = 0; i < wd; i++) for(j = 0; j < wd; j++) setPixelColor(maxx + i, maxy + j, vec4(255, 0, 0, 255));
//	}
}







void main() {
	//Yeet unnecessary calls
	if(x >= width || y >= height) return;		//Out of render
	//TODO move null check to CPU
	if(wd == 0 || color.a == 0) return;	//Null line

	drawLine();


//	for(uint i = x0; i <= x1; i++){
//		colorOutput[(y0+(int(distance(y0,y1))) * (i - x0) / int(distance(x0,x1)))*width+i] = colToInt(color);
//	}
////			colorOutput[y*width+100] = colToInt(color);

//	uvec4 color;
//	color = uvec4(255,0,0,255);
//	color = (x > vertices[0]) ? uvec4(255,0,0,255) : uvec4(0);


//	colorOutput[y*width + x] = colToInt(color);
}








