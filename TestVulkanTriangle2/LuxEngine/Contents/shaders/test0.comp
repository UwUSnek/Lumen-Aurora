
#version 450

#define WORKGROUP_SIZE 32			//The x and y size of the workgroup
#define gx gl_GlobalInvocationID.x	//The x coordinate of the shader call. This does not depend on the workgroup size
#define gy gl_GlobalInvocationID.y	//The y coordinate of the shader call. This does not depend on the workgroup size
#define colToInt(v) ((v.a) << 24) | ((v.b & 0xFF) << 16) | ((v.g & 0xFF) << 8) | (v.r & 0xFF)




layout (local_size_x = WORKGROUP_SIZE * WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

layout(std430, binding = 0) buffer colorOutput_{ uint colorOutput[]; };

layout(std430, binding = 1) buffer windowSize_{ 
	uint width;
	uint height; 
};

layout(std430, binding = 2) buffer lineData_{ 
	//16
	int x0; int y0; //0		//4
	int x1; int y1; //8		//12
	//16
	vec4 col0;		//16
	//16
	vec4 col1;		//32
	//8
	float wd0;		//48
	float wd1;		//52
};








void setPixelColor(vec2 pos, vec4 col){
	colorOutput[uint(pos.y) * width + uint(pos.x)] = colToInt(uvec4(uint(col.r*255), uint(col.g*255), uint(col.b*255), uint(col.a*255)));
}



void drawLine(){ 
//	int minx = min(x0,x1);		//Minimum x
//	int miny = min(y0,y1);		//Minimum y


	//TODO add special cases: vertical, horizontal
	//TODO add vertical execution
	//TODO inverse direction lines (test already in cpp)
	//TODO antialiasing 


	float xDir = ((x1 - x0 < 0) ? -1 : 1);
	float yDir = ((y1 - y0 < 0) ? -1 : 1);
	


	float lLen = distance(vec2(x0, y0), vec2(x1, y1));						//Length of the line
	vec2 lDist = { distance(x0, x1), distance(y0, y1) };							//2D distance of the line points
	float lFac = 1 / (lLen / gx);													//Factor of the position of gx in the line length


	vec4 col = mix(col0, col1, lFac);										//Interpolated color
	float wd = mix(wd0, wd1, lFac);										//Interpolated width




	float lHwd = wd / 2;															//Half line width
	vec2 lNvec = vec2(lDist.x, lDist.y) / max(lDist.x, lDist.y);		//Normalized distance vector

	vec2 lRpos = { x0 + (xDir * (lDist.x * lFac)), y0 + (yDir * (lDist.y * lFac)) };	//Position relative to the first point
//	//TODO
//	setPixelColor(uvec2(lRpos.xy),vec4(1,1,1,1));
	vec2 s0 = { lRpos.x + (yDir * (lHwd * lNvec.y)), lRpos.y - (xDir * (lHwd * lNvec.x)) };
	vec2 s1 = { lRpos.x - (yDir * (lHwd * lNvec.y)), lRpos.y + (xDir * (lHwd * lNvec.x)) };
//	//TODO
//	setPixelColor(uvec2(s0.xy),vec4(0,1,1,1));
//	setPixelColor(uvec2(s1.xy),vec4(0,1,1,1));

	





	float sLen = distance(s0, s1);							//Length of the segment
	vec2 sDist = vec2(distance(s0.x, s1.x), distance(s0.y, s1.y));	//2D distance of the segment points
	if(yDir < 0) { s0 -= sDist; s1 -= sDist; }
	if(xDir < 0) { s0 += sDist; s1 += sDist; }
	for(float i = 0; i < sLen; i++){
		float sfac = 1 / (sLen / i);								//Factor of the position of I in the segment length
		setPixelColor(vec2(s1.x + (xDir * (sDist.x * sfac)), s1.y - (yDir * (sDist.y * sfac))), col);
	}



//	//TODO
//	setPixelColor(uvec2(x0,y0),vec4(0,1,0,1));
//	setPixelColor(uvec2(x1,y1),vec4(0,1,0,1));

}




void main() {
	//Yeet unnecessary calls
	if(gx >= distance(vec2(x0, y0), vec2(x1, y1))) return;
//	if(x >= width || y >= height) return;		//Out of render
	//TODO move null check to CPU
	if((wd0 == 0 && wd1 == 0) || (col0.a == 0 && col1.a == 0)) return;	//Null line

	drawLine();
}













//void drawLine(){ 
//	float dx = distance(x0,x1);	//x distance
//	float dy = distance(y0,y1);	//y distance
//	int minx = min(x0,x1);		//Minimum x
//	int miny = min(y0,y1);		//Minimum y
//
//
//	//TODO add special cases: vertical, horizontal
//	//TODO add vertical execution
//	//TODO inverse direction lines (test already in cpp)
//	//TODO antialiasing 
//
//
//	
//	vec2 fac = vec2(1 / (dx / gx), 1- (1 / (dx / gx)));	//Distance from the first and second point
//	vec4 col = col0 * fac[0] + col1 * fac[1];			//Interpolated color
//	float wd = wd0 * fac[0] + wd1 * fac[1];				//Interpolated width
//	float y = dy * fac[0];
//	int i, j;						//Current y
//
//	float hWd = wd / 2;									//Half width
//	vec2 nVec = vec2(dx, dy) / max(dx, dy);				//Normalized distance vector
//	vec2 s0 = vec2(minx + (hWd * nVec.y) + gx, miny - (hWd * nVec.x) + y);	//First point of the perpendicular segment
//	vec2 s1 = vec2(minx - (hWd * nVec.y) + gx, miny + (hWd * nVec.x) + y);	//Second point of the perpendicular segment
//	
//
//
//	float sLen = length(distance(s0, s1));							//Length of the segment
//	vec2 sDist = vec2(distance(s0.x, s1.x), distance(s0.y, s1.y));	//2D distance of the segment points
//	for(float i = 0; i < sLen; i+=0.4){
//		float sfac = 1 / (sLen / i);					//Factor of the position of I in the segment length
//		setPixelColor(uvec2(uint((sDist.x * sfac) + s1.x), uint(s1.y - (sDist.y * sfac))), col);
//	}
//}
