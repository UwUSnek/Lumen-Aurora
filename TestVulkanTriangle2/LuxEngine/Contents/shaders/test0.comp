
#version 450

#define WORKGROUP_SIZE 32			//The x and y size of the workgroup
#define gx gl_GlobalInvocationID.x	//The x coordinate of the shader call. This does not depend on the workgroup size
#define gy gl_GlobalInvocationID.y	//The y coordinate of the shader call. This does not depend on the workgroup size

uint colToInt(vec4 v) {
	v *= 255;
	return uint((uint(v.a) << 24) | ((uint(v.b) & 0xFF) << 16) | ((uint(v.g) & 0xFF) << 8) | (uint(v.r) & 0xFF));
}

vec4 intToCol(uint v) {
	return vec4(float(v >> 24), float((v >> 16) & 0xFF), float((v >> 8) & 0xFF), float(v.r & 0xFF)) / 255;
}








layout (local_size_x = WORKGROUP_SIZE * WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

layout(std430, binding = 0) buffer colorOutput_{ uint colorOutput[]; };

layout(std430, binding = 1) buffer windowSize_{ 
	uint width;
	uint height; 
};

layout(std430, binding = 2) buffer lineData_{ 
	//16
	ivec2 p0; //0		//4
	ivec2 p1; //8		//12
	//16
	vec4 col0;		//16
	//16
	vec4 col1;		//32
	//8
	float wd0;		//48
	float wd1;		//52
};







void setPixelColor(vec2 pos, vec4 col){
	uint i = uint(pos.y) * width + uint(pos.x);

//	vec4 lastCol = intToCol(colorOutput[i]);
//	vec4 _col = mix(lastCol, col, col.a);
//	vec4 _col = lastCol + col*col.a;

	//TODO dont multiply per alpha. just copy it
	colorOutput[i] = colToInt(col * col.a);
//	colorOutput[i] = colToInt(_col);
}




void drawLine(){ 
//	int j = 
	const vec2 pm = {1, -1};	//Plus-minus vector for fast vec2 operations
	const vec2 mp = {-1, 1};	//Minus-plus vector for fast vec2 operations




	//Calculate length and interpolated values
	float lLen = distance(p0, p1);						//Length of the line
	vec2 lDist = abs(p0 - p1);							//2D distance between the line points
	float lFac = 1 / (lLen / gx);						//Factor of the position of gx in the line length

	vec4 col = mix(col0, col1, lFac);					//Interpolated color
	float wd = mix(wd0, wd1, lFac);						//Interpolated width



	//Find perpendicular sub segment points
	vec2 dir = sign(p1 - p0);							//Direction of the line								(+1 when going from -y to y or from -x to x, false otherwise)
	vec2 sbOffset = dir * (wd / 2) * normalize(lDist);	//Base segment point offset							(direction * half width * normalized 2D line distance)

	vec2 lRpos = p0 + dir * lDist * lFac;				//Position relative to the first point of the line	(line base point + (direction *  normalized 2D line distance * line factor))
	vec2 s0 = sbOffset.yx * pm + lRpos;					//Fist point of the segment							(inverted base segment offset * -y + relative position)
	vec2 s1 = sbOffset.yx * mp + lRpos;					//Second point of the segment						(inverted base segment offset * -x + relative position)
	

	//Draw sub segment
	//TODOu se normal line algorithm
	float sLen = distance(s0, s1);						//Length of the segment
	for(float i = 0; i < sLen; i++){					//Set the current pixel with the interpolated color
		vec2 ppos =											//Calculate the base position of the pixel to draw
			(pm * (dir.x * dir.y)) * (dir *						//Invert position if x and y have different directions
			abs(s0 - s1) * (1 / (sLen / i))) 					//2D segment distance * segment factor
			+ s1;												//+ segment base point

		setPixelColor(ppos, col);							//Set the current pixel with the interpolated color
		setPixelColor(ppos + vec2(1,0), col);				//Additional pixel to prevent holes in the image
	}
}







void main() {
	if(gx >= distance(vec2(p0.x, p0.y), vec2(p1.x, p1.y))) return;			//Yeet unnecessary calls
	//TODO implement and add to render optimization exceptions (vertical, horyzontal, width 1, non rendered)
	if((wd0 == 0 && wd1 == 0) || (col0.a == 0 && col1.a == 0)) return;		//Null line

	drawLine();
}
